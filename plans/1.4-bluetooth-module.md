Now I have all the information I need. Let me create a comprehensive implementation plan with complete, copy-paste ready code for the Bluetooth scanner module.

---

# Excruciating Implementation Details: `tether-core/src/bluetooth.rs`

## Overview

This document provides complete, copy-paste ready Rust code for Bluetooth RSSI proximity detection on Raspberry Pi using the `bluer` crate. The implementation includes lazy scanning, proximity detection, device discovery for onboarding, and a mock implementation for local development.

---

## 1. Dependencies (for `tether-core/Cargo.toml`)

Add these dependencies to the `tether-core` crate's `Cargo.toml`:

```toml
[dependencies]
bluer = { version = "0.17", features = ["bluetoothd"], optional = true }
tokio = { version = "1", features = ["rt", "time", "sync", "macros"] }
thiserror = "1.0"
tracing = "0.1"
serde = { version = "1.0", features = ["derive"] }

[features]
default = ["bluetooth"]
bluetooth = ["dep:bluer"]
mock-bluetooth = []  # For local development without BT hardware
```

---

## 2. Complete Implementation: `tether-core/src/bluetooth.rs`

```rust
//! Bluetooth RSSI proximity detection for Tether.
//!
//! This module provides lazy Bluetooth scanning for proximity detection.
//! It supports:
//! - Checking if a configured device is nearby based on RSSI threshold
//! - Device discovery for onboarding (listing visible devices)
//! - Getting raw RSSI values for calibration
//!
//! # Feature Flags
//!
//! - `bluetooth`: Enables real Bluetooth hardware access via `bluer` (default)
//! - `mock-bluetooth`: Uses mock implementation for local development
//!
//! # Example
//!
//! ```rust,ignore
//! use tether_core::bluetooth::{BluetoothScanner, BluetoothConfig, ProximityResult};
//!
//! #[tokio::main]
//! async fn main() -> Result<(), BluetoothError> {
//!     let scanner = BluetoothScanner::new().await?;
//!     
//!     let config = BluetoothConfig {
//!         device_address: "AA:BB:CC:DD:EE:FF".to_string(),
//!         rssi_threshold: -70,
//!     };
//!     
//!     let result = scanner.check_proximity(&config).await?;
//!     println!("Device nearby: {}", result.nearby);
//!     Ok(())
//! }
//! ```

use serde::{Deserialize, Serialize};
use std::time::Duration;
use thiserror::Error;
use tracing::{debug, error, info, instrument, warn};

// ============================================================================
// ERROR TYPES
// ============================================================================

/// Errors that can occur during Bluetooth operations.
#[derive(Debug, Error)]
pub enum BluetoothError {
    /// No Bluetooth adapter was found on the system.
    /// This typically means BlueZ is not installed or no adapter is present.
    #[error("No Bluetooth adapter found. Ensure BlueZ is installed and a Bluetooth adapter is available.")]
    AdapterNotFound,

    /// The Bluetooth adapter exists but is powered off.
    /// Call `set_powered(true)` to enable it.
    #[error("Bluetooth adapter is powered off. Enable Bluetooth to continue.")]
    AdapterPoweredOff,

    /// The target device was not found during scanning.
    /// This can happen if the device is out of range, powered off, or not advertising.
    #[error("Device with address '{address}' was not found during scan")]
    DeviceNotFound {
        /// The MAC address that was not found.
        address: String,
    },

    /// The scan operation timed out before completing.
    /// Try increasing the scan duration or ensure the device is advertising.
    #[error("Bluetooth scan timed out after {duration_secs} seconds")]
    ScanTimeout {
        /// How long we waited before timing out.
        duration_secs: u64,
    },

    /// Invalid Bluetooth MAC address format.
    /// Expected format: "XX:XX:XX:XX:XX:XX" where X is a hex digit.
    #[error("Invalid Bluetooth address format: '{address}'. Expected format: XX:XX:XX:XX:XX:XX")]
    InvalidAddress {
        /// The invalid address that was provided.
        address: String,
    },

    /// Failed to initialize the Bluetooth session.
    /// This usually means BlueZ daemon (bluetoothd) is not running.
    #[error("Failed to initialize Bluetooth session: {message}")]
    SessionInitFailed {
        /// Detailed error message from the underlying library.
        message: String,
    },

    /// Failed to start device discovery.
    #[error("Failed to start device discovery: {message}")]
    DiscoveryFailed {
        /// Detailed error message.
        message: String,
    },

    /// A generic internal error occurred.
    #[error("Bluetooth internal error: {message}")]
    Internal {
        /// Detailed error message.
        message: String,
    },
}

/// Result type alias for Bluetooth operations.
pub type BluetoothResult<T> = Result<T, BluetoothError>;

// ============================================================================
// DATA STRUCTURES
// ============================================================================

/// Configuration for proximity checking.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BluetoothConfig {
    /// The MAC address of the device to track.
    /// Format: "XX:XX:XX:XX:XX:XX" (colon-separated hex).
    pub device_address: String,

    /// RSSI threshold for considering a device "nearby".
    /// Typical values:
    /// - `-30` to `-50`: Very close (within 1 meter)
    /// - `-50` to `-70`: Nearby (within 3-5 meters)
    /// - `-70` to `-90`: Far (within 10 meters)
    /// - Below `-90`: Very far or weak signal
    ///
    /// A device is considered "nearby" if its RSSI >= this threshold.
    pub rssi_threshold: i16,
}

impl BluetoothConfig {
    /// Validates the configuration.
    pub fn validate(&self) -> BluetoothResult<()> {
        self.validate_address()?;
        Ok(())
    }

    /// Validates the Bluetooth address format.
    fn validate_address(&self) -> BluetoothResult<()> {
        let parts: Vec<&str> = self.device_address.split(':').collect();
        if parts.len() != 6 {
            return Err(BluetoothError::InvalidAddress {
                address: self.device_address.clone(),
            });
        }

        for part in parts {
            if part.len() != 2 {
                return Err(BluetoothError::InvalidAddress {
                    address: self.device_address.clone(),
                });
            }
            if !part.chars().all(|c| c.is_ascii_hexdigit()) {
                return Err(BluetoothError::InvalidAddress {
                    address: self.device_address.clone(),
                });
            }
        }

        Ok(())
    }
}

/// A discovered Bluetooth device.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BluetoothDevice {
    /// The MAC address of the device.
    pub address: String,

    /// The human-readable name of the device, if available.
    /// This may be `None` if the device hasn't advertised its name.
    pub name: Option<String>,

    /// The received signal strength indicator (RSSI) in dBm.
    /// Higher values (closer to 0) indicate stronger signals.
    /// This may be `None` if RSSI wasn't available during discovery.
    pub rssi: Option<i16>,
}

/// Result of a proximity check.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProximityResult {
    /// Whether the device is considered nearby based on the RSSI threshold.
    pub nearby: bool,

    /// The actual RSSI value if the device was found.
    /// `None` if the device was not detected during the scan.
    pub rssi: Option<i16>,

    /// The device name if available.
    pub device_name: Option<String>,

    /// The MAC address that was checked.
    pub device_address: String,

    /// Timestamp of the check (Unix timestamp in seconds).
    pub timestamp: u64,
}

// ============================================================================
// REAL BLUETOOTH IMPLEMENTATION (feature = "bluetooth")
// ============================================================================

#[cfg(all(feature = "bluetooth", not(feature = "mock-bluetooth")))]
mod real_impl {
    use super::*;
    use bluer::{Adapter, AdapterEvent, Address, DiscoveryFilter, DiscoveryTransport, Session};
    use futures::StreamExt;
    use std::collections::HashMap;
    use std::str::FromStr;
    use std::sync::Arc;
    use tokio::sync::Mutex;
    use tokio::time::{timeout, Instant};

    /// Bluetooth scanner for proximity detection.
    ///
    /// This struct manages a connection to the BlueZ daemon and provides
    /// methods for scanning devices and checking proximity.
    ///
    /// # Thread Safety
    ///
    /// `BluetoothScanner` is thread-safe and can be shared across tasks
    /// using `Arc<BluetoothScanner>`.
    pub struct BluetoothScanner {
        /// The BlueZ session handle.
        session: Session,
        /// The default Bluetooth adapter.
        adapter: Adapter,
        /// Mutex to prevent concurrent scans (BlueZ doesn't support this well).
        scan_lock: Mutex<()>,
    }

    impl BluetoothScanner {
        /// Default scan duration in seconds for proximity checks.
        const DEFAULT_SCAN_DURATION_SECS: u64 = 3;

        /// Maximum scan duration to prevent indefinite hangs.
        const MAX_SCAN_DURATION_SECS: u64 = 30;

        /// Creates a new Bluetooth scanner.
        ///
        /// This initializes a connection to the BlueZ daemon and obtains
        /// a handle to the default Bluetooth adapter.
        ///
        /// # Errors
        ///
        /// - `BluetoothError::SessionInitFailed`: BlueZ daemon not running
        /// - `BluetoothError::AdapterNotFound`: No Bluetooth adapter available
        /// - `BluetoothError::AdapterPoweredOff`: Adapter exists but is off
        ///
        /// # Example
        ///
        /// ```rust,ignore
        /// let scanner = BluetoothScanner::new().await?;
        /// ```
        #[instrument(name = "bluetooth_scanner_new")]
        pub async fn new() -> BluetoothResult<Self> {
            info!("Initializing Bluetooth scanner");

            // Create session to BlueZ daemon
            let session = Session::new().await.map_err(|e| {
                error!("Failed to create BlueZ session: {}", e);
                BluetoothError::SessionInitFailed {
                    message: e.to_string(),
                }
            })?;

            // Get default adapter
            let adapter = session.default_adapter().await.map_err(|e| {
                error!("Failed to get default adapter: {}", e);
                BluetoothError::AdapterNotFound
            })?;

            // Check if adapter is powered
            let is_powered = adapter.is_powered().await.map_err(|e| {
                error!("Failed to check adapter power state: {}", e);
                BluetoothError::Internal {
                    message: format!("Failed to check adapter power: {}", e),
                }
            })?;

            if !is_powered {
                warn!("Bluetooth adapter is powered off, attempting to power on");
                adapter.set_powered(true).await.map_err(|e| {
                    error!("Failed to power on adapter: {}", e);
                    BluetoothError::AdapterPoweredOff
                })?;
                info!("Bluetooth adapter powered on successfully");
            }

            let adapter_addr = adapter.address().await.map_err(|e| {
                BluetoothError::Internal {
                    message: format!("Failed to get adapter address: {}", e),
                }
            })?;

            info!(
                adapter_address = %adapter_addr,
                "Bluetooth scanner initialized successfully"
            );

            Ok(Self {
                session,
                adapter,
                scan_lock: Mutex::new(()),
            })
        }

        /// Checks if a configured device is nearby based on RSSI threshold.
        ///
        /// This performs a lazy scan (only when called) for 2-3 seconds,
        /// looking for the configured device and comparing its RSSI to
        /// the threshold.
        ///
        /// # Arguments
        ///
        /// * `config` - The Bluetooth configuration with device address and threshold
        ///
        /// # Returns
        ///
        /// A `ProximityResult` indicating whether the device is nearby.
        ///
        /// # Errors
        ///
        /// - `BluetoothError::InvalidAddress`: Malformed MAC address
        /// - `BluetoothError::ScanTimeout`: Scan didn't complete in time
        /// - `BluetoothError::DiscoveryFailed`: Failed to start scanning
        ///
        /// # Example
        ///
        /// ```rust,ignore
        /// let config = BluetoothConfig {
        ///     device_address: "AA:BB:CC:DD:EE:FF".to_string(),
        ///     rssi_threshold: -70,
        /// };
        ///
        /// let result = scanner.check_proximity(&config).await?;
        /// if result.nearby {
        ///     println!("Phone is nearby! RSSI: {:?}", result.rssi);
        /// }
        /// ```
        #[instrument(skip(self), fields(device_address = %config.device_address, threshold = config.rssi_threshold))]
        pub async fn check_proximity(&self, config: &BluetoothConfig) -> BluetoothResult<ProximityResult> {
            // Validate configuration
            config.validate()?;

            let target_address = Address::from_str(&config.device_address).map_err(|_| {
                BluetoothError::InvalidAddress {
                    address: config.device_address.clone(),
                }
            })?;

            info!("Checking proximity for device {}", config.device_address);

            // Acquire scan lock to prevent concurrent scans
            let _lock = self.scan_lock.lock().await;

            let timestamp = std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap_or_default()
                .as_secs();

            // Try to get device info from a quick scan
            let scan_result = self
                .scan_for_device(&target_address, Duration::from_secs(Self::DEFAULT_SCAN_DURATION_SECS))
                .await?;

            let (rssi, device_name) = match scan_result {
                Some((rssi, name)) => (Some(rssi), name),
                None => {
                    // Device not found during scan
                    debug!("Device {} not found during scan", config.device_address);
                    (None, None)
                }
            };

            // Determine if nearby based on RSSI threshold
            let nearby = rssi.map(|r| r >= config.rssi_threshold).unwrap_or(false);

            let result = ProximityResult {
                nearby,
                rssi,
                device_name,
                device_address: config.device_address.clone(),
                timestamp,
            };

            info!(
                nearby = result.nearby,
                rssi = ?result.rssi,
                device_name = ?result.device_name,
                "Proximity check complete"
            );

            Ok(result)
        }

        /// Discovers all visible Bluetooth devices.
        ///
        /// This is used during onboarding to let the user select which
        /// device to track. It performs a longer scan to find all
        /// advertising devices.
        ///
        /// # Arguments
        ///
        /// * `duration_secs` - How long to scan (capped at 30 seconds)
        ///
        /// # Returns
        ///
        /// A list of discovered devices with their addresses, names, and RSSI values.
        ///
        /// # Errors
        ///
        /// - `BluetoothError::DiscoveryFailed`: Failed to start scanning
        /// - `BluetoothError::ScanTimeout`: Scan timed out unexpectedly
        ///
        /// # Example
        ///
        /// ```rust,ignore
        /// let devices = scanner.discover_devices(5).await?;
        /// for device in devices {
        ///     println!("{}: {} (RSSI: {:?})",
        ///         device.address,
        ///         device.name.unwrap_or_else(|| "Unknown".to_string()),
        ///         device.rssi
        ///     );
        /// }
        /// ```
        #[instrument(skip(self), fields(duration_secs))]
        pub async fn discover_devices(&self, duration_secs: u64) -> BluetoothResult<Vec<BluetoothDevice>> {
            let duration_secs = duration_secs.min(Self::MAX_SCAN_DURATION_SECS);
            let duration = Duration::from_secs(duration_secs);

            info!("Starting device discovery for {} seconds", duration_secs);

            // Acquire scan lock
            let _lock = self.scan_lock.lock().await;

            // Set up discovery filter for all devices (BR/EDR and LE)
            let filter = DiscoveryFilter {
                transport: DiscoveryTransport::Auto,
                duplicate_data: false,
                ..Default::default()
            };

            self.adapter.set_discovery_filter(filter).await.map_err(|e| {
                error!("Failed to set discovery filter: {}", e);
                BluetoothError::DiscoveryFailed {
                    message: e.to_string(),
                }
            })?;

            // Start discovery
            let events = self.adapter.discover_devices().await.map_err(|e| {
                error!("Failed to start device discovery: {}", e);
                BluetoothError::DiscoveryFailed {
                    message: e.to_string(),
                }
            })?;

            // Collect devices during the scan period
            let mut devices: HashMap<Address, BluetoothDevice> = HashMap::new();
            let start = Instant::now();

            tokio::pin!(events);

            loop {
                let remaining = duration.saturating_sub(start.elapsed());
                if remaining.is_zero() {
                    break;
                }

                match timeout(remaining, events.next()).await {
                    Ok(Some(event)) => {
                        if let AdapterEvent::DeviceAdded(addr) = event {
                            if let Ok(device) = self.adapter.device(addr) {
                                // Query device properties
                                let name = device.name().await.ok().flatten();
                                let rssi = device.rssi().await.ok().flatten();

                                let bt_device = BluetoothDevice {
                                    address: addr.to_string(),
                                    name,
                                    rssi,
                                };

                                debug!(
                                    address = %addr,
                                    name = ?bt_device.name,
                                    rssi = ?bt_device.rssi,
                                    "Discovered device"
                                );

                                devices.insert(addr, bt_device);
                            }
                        }
                    }
                    Ok(None) => {
                        // Stream ended
                        break;
                    }
                    Err(_) => {
                        // Timeout - scan duration complete
                        break;
                    }
                }
            }

            let result: Vec<BluetoothDevice> = devices.into_values().collect();

            info!(
                device_count = result.len(),
                "Device discovery complete"
            );

            Ok(result)
        }

        /// Gets the current RSSI value for a specific device.
        ///
        /// This is useful for calibration - letting the user see the
        /// signal strength in real-time to determine an appropriate threshold.
        ///
        /// # Arguments
        ///
        /// * `address` - The MAC address of the device to query
        ///
        /// # Returns
        ///
        /// The current RSSI value if the device is detected, `None` otherwise.
        ///
        /// # Errors
        ///
        /// - `BluetoothError::InvalidAddress`: Malformed MAC address
        /// - `BluetoothError::ScanTimeout`: Couldn't find device in time
        ///
        /// # Example
        ///
        /// ```rust,ignore
        /// match scanner.get_device_rssi("AA:BB:CC:DD:EE:FF").await? {
        ///     Some(rssi) => println!("Current RSSI: {} dBm", rssi),
        ///     None => println!("Device not in range"),
        /// }
        /// ```
        #[instrument(skip(self), fields(address = %address))]
        pub async fn get_device_rssi(&self, address: &str) -> BluetoothResult<Option<i16>> {
            // Validate address format
            let target_address = Address::from_str(address).map_err(|_| {
                BluetoothError::InvalidAddress {
                    address: address.to_string(),
                }
            })?;

            debug!("Getting RSSI for device {}", address);

            // Acquire scan lock
            let _lock = self.scan_lock.lock().await;

            // Quick scan to find the device
            let result = self
                .scan_for_device(&target_address, Duration::from_secs(Self::DEFAULT_SCAN_DURATION_SECS))
                .await?;

            let rssi = result.map(|(rssi, _)| rssi);

            debug!(rssi = ?rssi, "RSSI query complete");

            Ok(rssi)
        }

        /// Internal helper to scan for a specific device.
        ///
        /// Returns the RSSI and name if found within the timeout.
        async fn scan_for_device(
            &self,
            target_address: &Address,
            duration: Duration,
        ) -> BluetoothResult<Option<(i16, Option<String>)>> {
            // Set up discovery filter
            let filter = DiscoveryFilter {
                transport: DiscoveryTransport::Auto,
                duplicate_data: true, // Get updates for RSSI changes
                ..Default::default()
            };

            self.adapter.set_discovery_filter(filter).await.map_err(|e| {
                BluetoothError::DiscoveryFailed {
                    message: e.to_string(),
                }
            })?;

            // Start discovery with property change notifications
            let events = self.adapter.discover_devices_with_changes().await.map_err(|e| {
                BluetoothError::DiscoveryFailed {
                    message: e.to_string(),
                }
            })?;

            let start = Instant::now();
            let mut found_device: Option<(i16, Option<String>)> = None;

            tokio::pin!(events);

            loop {
                let remaining = duration.saturating_sub(start.elapsed());
                if remaining.is_zero() {
                    break;
                }

                match timeout(remaining, events.next()).await {
                    Ok(Some(event)) => {
                        match event {
                            AdapterEvent::DeviceAdded(addr) | AdapterEvent::PropertyChanged(bluer::AdapterProperty::Address) => {
                                // For DeviceAdded, addr is the device address
                                // Check if this is our target device
                                let addr = if let AdapterEvent::DeviceAdded(a) = event { a } else { continue };
                                
                                if addr == *target_address {
                                    if let Ok(device) = self.adapter.device(addr) {
                                        if let Ok(Some(rssi)) = device.rssi().await {
                                            let name = device.name().await.ok().flatten();
                                            debug!(
                                                rssi = rssi,
                                                name = ?name,
                                                "Found target device"
                                            );
                                            found_device = Some((rssi, name));
                                            // Continue scanning to get potentially better RSSI reading
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                    Ok(None) => break,
                    Err(_) => break, // Timeout
                }
            }

            // Also check if we already know about this device (from previous scans)
            if found_device.is_none() {
                if let Ok(device) = self.adapter.device(*target_address) {
                    if let Ok(Some(rssi)) = device.rssi().await {
                        let name = device.name().await.ok().flatten();
                        found_device = Some((rssi, name));
                    }
                }
            }

            Ok(found_device)
        }

        /// Checks if the Bluetooth adapter is powered on.
        pub async fn is_adapter_powered(&self) -> BluetoothResult<bool> {
            self.adapter.is_powered().await.map_err(|e| {
                BluetoothError::Internal {
                    message: format!("Failed to check adapter power: {}", e),
                }
            })
        }

        /// Gets the adapter's Bluetooth address.
        pub async fn adapter_address(&self) -> BluetoothResult<String> {
            let addr = self.adapter.address().await.map_err(|e| {
                BluetoothError::Internal {
                    message: format!("Failed to get adapter address: {}", e),
                }
            })?;
            Ok(addr.to_string())
        }
    }
}

// ============================================================================
// MOCK IMPLEMENTATION (feature = "mock-bluetooth")
// ============================================================================

#[cfg(any(feature = "mock-bluetooth", not(feature = "bluetooth")))]
mod mock_impl {
    use super::*;
    use std::collections::HashMap;
    use std::sync::Arc;
    use tokio::sync::RwLock;

    /// Mock device configuration for testing.
    #[derive(Debug, Clone)]
    pub struct MockDevice {
        pub address: String,
        pub name: Option<String>,
        pub rssi: Option<i16>,
        pub is_visible: bool,
    }

    /// Mock Bluetooth scanner for local development and testing.
    ///
    /// This implementation simulates Bluetooth scanning without requiring
    /// actual hardware. Configure mock devices using `add_mock_device()`.
    ///
    /// # Example
    ///
    /// ```rust
    /// use tether_core::bluetooth::{BluetoothScanner, MockDevice};
    ///
    /// #[tokio::main]
    /// async fn main() {
    ///     let scanner = BluetoothScanner::new().await.unwrap();
    ///     
    ///     // Add a simulated device
    ///     scanner.add_mock_device(MockDevice {
    ///         address: "AA:BB:CC:DD:EE:FF".to_string(),
    ///         name: Some("iPhone".to_string()),
    ///         rssi: Some(-65),
    ///         is_visible: true,
    ///     }).await;
    /// }
    /// ```
    pub struct BluetoothScanner {
        /// Mock devices keyed by address.
        mock_devices: Arc<RwLock<HashMap<String, MockDevice>>>,
        /// Simulated scan delay.
        scan_delay_ms: u64,
        /// Whether the adapter is "powered on".
        is_powered: Arc<RwLock<bool>>,
    }

    impl BluetoothScanner {
        /// Creates a new mock Bluetooth scanner.
        ///
        /// This always succeeds in mock mode.
        #[instrument(name = "mock_bluetooth_scanner_new")]
        pub async fn new() -> BluetoothResult<Self> {
            info!("Initializing MOCK Bluetooth scanner (no hardware access)");

            let mut mock_devices = HashMap::new();

            // Add some default mock devices for testing
            mock_devices.insert(
                "AA:BB:CC:DD:EE:FF".to_string(),
                MockDevice {
                    address: "AA:BB:CC:DD:EE:FF".to_string(),
                    name: Some("Test iPhone".to_string()),
                    rssi: Some(-55),
                    is_visible: true,
                },
            );

            mock_devices.insert(
                "11:22:33:44:55:66".to_string(),
                MockDevice {
                    address: "11:22:33:44:55:66".to_string(),
                    name: Some("Test Android".to_string()),
                    rssi: Some(-72),
                    is_visible: true,
                },
            );

            mock_devices.insert(
                "DE:AD:BE:EF:CA:FE".to_string(),
                MockDevice {
                    address: "DE:AD:BE:EF:CA:FE".to_string(),
                    name: None, // No name advertised
                    rssi: Some(-85),
                    is_visible: true,
                },
            );

            Ok(Self {
                mock_devices: Arc::new(RwLock::new(mock_devices)),
                scan_delay_ms: 500, // Simulate 500ms scan time
                is_powered: Arc::new(RwLock::new(true)),
            })
        }

        /// Adds a mock device for testing.
        pub async fn add_mock_device(&self, device: MockDevice) {
            let mut devices = self.mock_devices.write().await;
            info!(
                address = %device.address,
                name = ?device.name,
                rssi = ?device.rssi,
                "Adding mock device"
            );
            devices.insert(device.address.clone(), device);
        }

        /// Removes a mock device.
        pub async fn remove_mock_device(&self, address: &str) {
            let mut devices = self.mock_devices.write().await;
            devices.remove(address);
        }

        /// Updates a mock device's RSSI (useful for simulating movement).
        pub async fn set_mock_device_rssi(&self, address: &str, rssi: Option<i16>) {
            let mut devices = self.mock_devices.write().await;
            if let Some(device) = devices.get_mut(address) {
                device.rssi = rssi;
            }
        }

        /// Sets whether a mock device is visible (simulates going out of range).
        pub async fn set_mock_device_visible(&self, address: &str, is_visible: bool) {
            let mut devices = self.mock_devices.write().await;
            if let Some(device) = devices.get_mut(address) {
                device.is_visible = is_visible;
            }
        }

        /// Sets the simulated scan delay in milliseconds.
        pub fn set_scan_delay_ms(&mut self, delay_ms: u64) {
            self.scan_delay_ms = delay_ms;
        }

        /// Checks proximity for a configured device (mock implementation).
        #[instrument(skip(self), fields(device_address = %config.device_address, threshold = config.rssi_threshold))]
        pub async fn check_proximity(&self, config: &BluetoothConfig) -> BluetoothResult<ProximityResult> {
            config.validate()?;

            // Check if adapter is "powered"
            if !*self.is_powered.read().await {
                return Err(BluetoothError::AdapterPoweredOff);
            }

            info!("[MOCK] Checking proximity for device {}", config.device_address);

            // Simulate scan delay
            tokio::time::sleep(Duration::from_millis(self.scan_delay_ms)).await;

            let timestamp = std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap_or_default()
                .as_secs();

            let devices = self.mock_devices.read().await;

            // Normalize address to uppercase for comparison
            let normalized_address = config.device_address.to_uppercase();

            let (rssi, device_name) = if let Some(device) = devices.get(&normalized_address) {
                if device.is_visible {
                    (device.rssi, device.name.clone())
                } else {
                    (None, None)
                }
            } else {
                (None, None)
            };

            let nearby = rssi.map(|r| r >= config.rssi_threshold).unwrap_or(false);

            let result = ProximityResult {
                nearby,
                rssi,
                device_name,
                device_address: config.device_address.clone(),
                timestamp,
            };

            info!(
                nearby = result.nearby,
                rssi = ?result.rssi,
                "[MOCK] Proximity check complete"
            );

            Ok(result)
        }

        /// Discovers all visible mock devices.
        #[instrument(skip(self), fields(duration_secs))]
        pub async fn discover_devices(&self, duration_secs: u64) -> BluetoothResult<Vec<BluetoothDevice>> {
            // Check if adapter is "powered"
            if !*self.is_powered.read().await {
                return Err(BluetoothError::AdapterPoweredOff);
            }

            info!("[MOCK] Discovering devices for {} seconds", duration_secs);

            // Simulate some scan time (shorter than requested for testing)
            let delay = std::cmp::min(duration_secs * 100, self.scan_delay_ms);
            tokio::time::sleep(Duration::from_millis(delay)).await;

            let devices = self.mock_devices.read().await;
            let result: Vec<BluetoothDevice> = devices
                .values()
                .filter(|d| d.is_visible)
                .map(|d| BluetoothDevice {
                    address: d.address.clone(),
                    name: d.name.clone(),
                    rssi: d.rssi,
                })
                .collect();

            info!(device_count = result.len(), "[MOCK] Discovery complete");

            Ok(result)
        }

        /// Gets the RSSI for a specific mock device.
        #[instrument(skip(self), fields(address = %address))]
        pub async fn get_device_rssi(&self, address: &str) -> BluetoothResult<Option<i16>> {
            // Validate address format
            let config = BluetoothConfig {
                device_address: address.to_string(),
                rssi_threshold: -100,
            };
            config.validate()?;

            // Check if adapter is "powered"
            if !*self.is_powered.read().await {
                return Err(BluetoothError::AdapterPoweredOff);
            }

            // Simulate scan delay
            tokio::time::sleep(Duration::from_millis(self.scan_delay_ms)).await;

            let devices = self.mock_devices.read().await;
            let normalized = address.to_uppercase();

            let rssi = devices
                .get(&normalized)
                .filter(|d| d.is_visible)
                .and_then(|d| d.rssi);

            debug!(rssi = ?rssi, "[MOCK] RSSI query complete");

            Ok(rssi)
        }

        /// Checks if the mock adapter is "powered on".
        pub async fn is_adapter_powered(&self) -> BluetoothResult<bool> {
            Ok(*self.is_powered.read().await)
        }

        /// Sets the mock adapter power state.
        pub async fn set_adapter_powered(&self, powered: bool) {
            *self.is_powered.write().await = powered;
        }

        /// Returns a mock adapter address.
        pub async fn adapter_address(&self) -> BluetoothResult<String> {
            Ok("00:00:00:00:00:00".to_string())
        }
    }
}

// ============================================================================
// RE-EXPORTS
// ============================================================================

#[cfg(all(feature = "bluetooth", not(feature = "mock-bluetooth")))]
pub use real_impl::BluetoothScanner;

#[cfg(any(feature = "mock-bluetooth", not(feature = "bluetooth")))]
pub use mock_impl::{BluetoothScanner, MockDevice};

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_bluetooth_config_validation_valid() {
        let config = BluetoothConfig {
            device_address: "AA:BB:CC:DD:EE:FF".to_string(),
            rssi_threshold: -70,
        };
        assert!(config.validate().is_ok());
    }

    #[test]
    fn test_bluetooth_config_validation_lowercase() {
        let config = BluetoothConfig {
            device_address: "aa:bb:cc:dd:ee:ff".to_string(),
            rssi_threshold: -70,
        };
        assert!(config.validate().is_ok());
    }

    #[test]
    fn test_bluetooth_config_validation_invalid_too_short() {
        let config = BluetoothConfig {
            device_address: "AA:BB:CC".to_string(),
            rssi_threshold: -70,
        };
        assert!(matches!(
            config.validate(),
            Err(BluetoothError::InvalidAddress { .. })
        ));
    }

    #[test]
    fn test_bluetooth_config_validation_invalid_format() {
        let config = BluetoothConfig {
            device_address: "AABBCCDDEEFF".to_string(),
            rssi_threshold: -70,
        };
        assert!(matches!(
            config.validate(),
            Err(BluetoothError::InvalidAddress { .. })
        ));
    }

    #[test]
    fn test_bluetooth_config_validation_invalid_chars() {
        let config = BluetoothConfig {
            device_address: "GG:HH:II:JJ:KK:LL".to_string(),
            rssi_threshold: -70,
        };
        assert!(matches!(
            config.validate(),
            Err(BluetoothError::InvalidAddress { .. })
        ));
    }

    #[tokio::test]
    #[cfg(any(feature = "mock-bluetooth", not(feature = "bluetooth")))]
    async fn test_mock_scanner_proximity_nearby() {
        let scanner = BluetoothScanner::new().await.unwrap();

        let config = BluetoothConfig {
            device_address: "AA:BB:CC:DD:EE:FF".to_string(),
            rssi_threshold: -60,
        };

        let result = scanner.check_proximity(&config).await.unwrap();
        assert!(result.nearby); // Default mock device has RSSI -55
        assert_eq!(result.rssi, Some(-55));
        assert_eq!(result.device_name, Some("Test iPhone".to_string()));
    }

    #[tokio::test]
    #[cfg(any(feature = "mock-bluetooth", not(feature = "bluetooth")))]
    async fn test_mock_scanner_proximity_too_far() {
        let scanner = BluetoothScanner::new().await.unwrap();

        let config = BluetoothConfig {
            device_address: "AA:BB:CC:DD:EE:FF".to_string(),
            rssi_threshold: -50, // Threshold higher than device's -55
        };

        let result = scanner.check_proximity(&config).await.unwrap();
        assert!(!result.nearby);
        assert_eq!(result.rssi, Some(-55));
    }

    #[tokio::test]
    #[cfg(any(feature = "mock-bluetooth", not(feature = "bluetooth")))]
    async fn test_mock_scanner_device_not_found() {
        let scanner = BluetoothScanner::new().await.unwrap();

        let config = BluetoothConfig {
            device_address: "99:99:99:99:99:99".to_string(),
            rssi_threshold: -70,
        };

        let result = scanner.check_proximity(&config).await.unwrap();
        assert!(!result.nearby);
        assert!(result.rssi.is_none());
    }

    #[tokio::test]
    #[cfg(any(feature = "mock-bluetooth", not(feature = "bluetooth")))]
    async fn test_mock_scanner_discover_devices() {
        let scanner = BluetoothScanner::new().await.unwrap();

        let devices = scanner.discover_devices(1).await.unwrap();
        assert_eq!(devices.len(), 3); // Three default mock devices
    }

    #[tokio::test]
    #[cfg(any(feature = "mock-bluetooth", not(feature = "bluetooth")))]
    async fn test_mock_scanner_device_visibility() {
        let scanner = BluetoothScanner::new().await.unwrap();

        // Make device invisible
        scanner.set_mock_device_visible("AA:BB:CC:DD:EE:FF", false).await;

        let config = BluetoothConfig {
            device_address: "AA:BB:CC:DD:EE:FF".to_string(),
            rssi_threshold: -70,
        };

        let result = scanner.check_proximity(&config).await.unwrap();
        assert!(!result.nearby);
        assert!(result.rssi.is_none());

        // Device should not appear in discovery
        let devices = scanner.discover_devices(1).await.unwrap();
        assert_eq!(devices.len(), 2); // Only 2 visible now
    }

    #[tokio::test]
    #[cfg(any(feature = "mock-bluetooth", not(feature = "bluetooth")))]
    async fn test_mock_scanner_powered_off() {
        let scanner = BluetoothScanner::new().await.unwrap();
        scanner.set_adapter_powered(false).await;

        let config = BluetoothConfig {
            device_address: "AA:BB:CC:DD:EE:FF".to_string(),
            rssi_threshold: -70,
        };

        let result = scanner.check_proximity(&config).await;
        assert!(matches!(result, Err(BluetoothError::AdapterPoweredOff)));
    }
}
```

---

## 3. Module Registration

In `/Users/jeffrey/code/tether/tether-core/src/lib.rs`, add:

```rust
pub mod bluetooth;

pub use bluetooth::{
    BluetoothConfig,
    BluetoothDevice,
    BluetoothError,
    BluetoothResult,
    BluetoothScanner,
    ProximityResult,
};

#[cfg(any(feature = "mock-bluetooth", not(feature = "bluetooth")))]
pub use bluetooth::MockDevice;
```

---

## 4. Usage Examples

### Basic Proximity Check

```rust
use tether_core::bluetooth::{BluetoothScanner, BluetoothConfig, BluetoothError};

#[tokio::main]
async fn main() -> Result<(), BluetoothError> {
    // Initialize scanner (handles adapter power-on automatically)
    let scanner = BluetoothScanner::new().await?;

    // Configure target device
    let config = BluetoothConfig {
        device_address: "AA:BB:CC:DD:EE:FF".to_string(),
        rssi_threshold: -70, // Consider nearby if RSSI >= -70 dBm
    };

    // Check proximity (performs 2-3 second lazy scan)
    let result = scanner.check_proximity(&config).await?;

    if result.nearby {
        println!(
            "Phone is nearby! RSSI: {} dBm",
            result.rssi.unwrap_or_default()
        );
    } else {
        println!("Phone is not nearby or out of range");
    }

    Ok(())
}
```

### Device Discovery for Onboarding

```rust
use tether_core::bluetooth::{BluetoothScanner, BluetoothError};

async fn discover_for_onboarding() -> Result<(), BluetoothError> {
    let scanner = BluetoothScanner::new().await?;

    println!("Scanning for devices (5 seconds)...");
    let devices = scanner.discover_devices(5).await?;

    println!("\nFound {} devices:\n", devices.len());
    for (i, device) in devices.iter().enumerate() {
        let name = device.name.as_deref().unwrap_or("Unknown");
        let rssi = device
            .rssi
            .map(|r| format!("{} dBm", r))
            .unwrap_or_else(|| "N/A".to_string());

        println!("{}. {} ({}) - RSSI: {}", i + 1, name, device.address, rssi);
    }

    Ok(())
}
```

### Real-time RSSI Calibration

```rust
use tether_core::bluetooth::{BluetoothScanner, BluetoothError};
use std::time::Duration;

async fn calibrate_rssi(address: &str) -> Result<i16, BluetoothError> {
    let scanner = BluetoothScanner::new().await?;

    println!("Calibrating RSSI for {}...", address);
    println!("Place your phone at the desired 'nearby' distance.");
    println!("Taking 5 readings...\n");

    let mut readings = Vec::new();

    for i in 1..=5 {
        print!("Reading {}/5: ", i);

        match scanner.get_device_rssi(address).await? {
            Some(rssi) => {
                println!("{} dBm", rssi);
                readings.push(rssi);
            }
            None => {
                println!("Device not found!");
            }
        }

        tokio::time::sleep(Duration::from_secs(2)).await;
    }

    if readings.is_empty() {
        return Err(BluetoothError::DeviceNotFound {
            address: address.to_string(),
        });
    }

    // Calculate average and suggest threshold
    let avg: i16 = readings.iter().sum::<i16>() / readings.len() as i16;
    let suggested_threshold = avg - 10; // 10 dBm buffer

    println!("\nResults:");
    println!("  Average RSSI: {} dBm", avg);
    println!("  Min RSSI: {} dBm", readings.iter().min().unwrap());
    println!("  Max RSSI: {} dBm", readings.iter().max().unwrap());
    println!("  Suggested threshold: {} dBm", suggested_threshold);

    Ok(suggested_threshold)
}
```

### Integration with Axum HTTP Handler

```rust
use axum::{extract::State, Json};
use std::sync::Arc;
use tether_core::bluetooth::{BluetoothScanner, BluetoothConfig, ProximityResult};

// Application state
pub struct AppState {
    pub bluetooth: Arc<BluetoothScanner>,
    pub config: BluetoothConfig,
}

// HTTP handler for proximity check
pub async fn check_proximity_handler(
    State(state): State<Arc<AppState>>,
) -> Result<Json<ProximityResult>, (axum::http::StatusCode, String)> {
    state
        .bluetooth
        .check_proximity(&state.config)
        .await
        .map(Json)
        .map_err(|e| {
            (
                axum::http::StatusCode::INTERNAL_SERVER_ERROR,
                e.to_string(),
            )
        })
}
```

---

## 5. Error Handling Patterns

### Comprehensive Error Handling

```rust
use tether_core::bluetooth::{BluetoothScanner, BluetoothConfig, BluetoothError};

async fn handle_bluetooth_operation() {
    let config = BluetoothConfig {
        device_address: "AA:BB:CC:DD:EE:FF".to_string(),
        rssi_threshold: -70,
    };

    // Validate config first (cheap operation)
    if let Err(e) = config.validate() {
        eprintln!("Invalid configuration: {}", e);
        return;
    }

    // Initialize scanner with proper error handling
    let scanner = match BluetoothScanner::new().await {
        Ok(s) => s,
        Err(BluetoothError::AdapterNotFound) => {
            eprintln!("No Bluetooth adapter found. Please ensure:");
            eprintln!("  1. A Bluetooth adapter is connected");
            eprintln!("  2. BlueZ is installed (apt install bluez)");
            eprintln!("  3. The bluetoothd service is running");
            return;
        }
        Err(BluetoothError::AdapterPoweredOff) => {
            eprintln!("Bluetooth adapter is powered off.");
            eprintln!("Run: sudo hciconfig hci0 up");
            return;
        }
        Err(BluetoothError::SessionInitFailed { message }) => {
            eprintln!("Failed to connect to BlueZ daemon: {}", message);
            eprintln!("Ensure bluetoothd is running: systemctl status bluetooth");
            return;
        }
        Err(e) => {
            eprintln!("Unexpected error initializing Bluetooth: {}", e);
            return;
        }
    };

    // Check proximity with error handling
    match scanner.check_proximity(&config).await {
        Ok(result) => {
            println!("Proximity check successful:");
            println!("  Nearby: {}", result.nearby);
            println!("  RSSI: {:?}", result.rssi);
            println!("  Device name: {:?}", result.device_name);
        }
        Err(BluetoothError::ScanTimeout { duration_secs }) => {
            eprintln!("Scan timed out after {} seconds", duration_secs);
            eprintln!("The device may be out of range or not advertising");
        }
        Err(BluetoothError::DiscoveryFailed { message }) => {
            eprintln!("Failed to start discovery: {}", message);
            eprintln!("Another application may be using Bluetooth");
        }
        Err(e) => {
            eprintln!("Error during proximity check: {}", e);
        }
    }
}
```

---

## 6. Testing Strategy

### Unit Tests (with Mock)

The mock implementation is automatically used when building with `--features mock-bluetooth` or when the `bluetooth` feature is disabled. Tests are included in the module.

Run tests:

```bash
# Test with mock implementation
cargo test -p tether-core --features mock-bluetooth

# Or without bluetooth feature (uses mock automatically)
cargo test -p tether-core --no-default-features
```

### Integration Tests (Raspberry Pi)

Create `/Users/jeffrey/code/tether/tether-core/tests/bluetooth_integration.rs`:

```rust
//! Integration tests for Bluetooth scanner.
//! These tests require actual Bluetooth hardware and should be run on a Raspberry Pi.

#![cfg(all(feature = "bluetooth", not(feature = "mock-bluetooth")))]

use tether_core::bluetooth::{BluetoothScanner, BluetoothConfig};

#[tokio::test]
#[ignore] // Run with: cargo test -- --ignored
async fn test_real_bluetooth_scanner_init() {
    // This test verifies the scanner can initialize with real hardware
    let result = BluetoothScanner::new().await;
    assert!(result.is_ok(), "Failed to initialize scanner: {:?}", result.err());

    let scanner = result.unwrap();
    assert!(scanner.is_adapter_powered().await.unwrap());
}

#[tokio::test]
#[ignore]
async fn test_real_device_discovery() {
    let scanner = BluetoothScanner::new().await.unwrap();

    // Scan for 5 seconds
    let devices = scanner.discover_devices(5).await.unwrap();

    println!("Found {} devices", devices.len());
    for device in &devices {
        println!("  {} - {:?} (RSSI: {:?})", device.address, device.name, device.rssi);
    }

    // We should find at least something if BT devices are around
    // This assertion may fail if no devices are nearby
}
```

---

## 7. Key Implementation Notes

### Async Patterns

1. **Scan Lock**: A `Mutex` prevents concurrent scans because BlueZ doesn't handle them well
2. **Timeouts**: All scans use `tokio::time::timeout` to prevent indefinite hangs
3. **Streams**: Device events use `futures::StreamExt` for async iteration
4. **Pin**: The `tokio::pin!` macro is required for stream iteration

### RSSI Interpretation

| RSSI Range | Interpretation | Typical Distance |
|------------|----------------|------------------|
| -30 to -50 | Excellent      | < 1 meter        |
| -50 to -60 | Good           | 1-2 meters       |
| -60 to -70 | Fair           | 2-5 meters       |
| -70 to -80 | Weak           | 5-10 meters      |
| < -80      | Very Weak      | > 10 meters      |

### Thread Safety

`BluetoothScanner` uses internal synchronization (`Mutex` for scans, `RwLock` for mock devices) and can be safely shared across tasks using `Arc<BluetoothScanner>`.

### Platform Requirements

- Linux with BlueZ 5.60+
- `libdbus-1-dev` for building (`apt install libdbus-1-dev`)
- `bluetoothd` service running
- User in `bluetooth` group or running as root

---

## 8. Sources

- [BlueR GitHub Repository](https://github.com/bluez/bluer)
- [BlueR Documentation](https://docs.rs/bluer/latest/bluer/)
- [BlueR Adapter Documentation](https://docs.rs/bluer/latest/bluer/struct.Adapter.html)
- [BlueR Device Documentation](https://docs.rs/bluer/latest/bluer/struct.Device.html)
- [BlueR DiscoveryFilter Documentation](https://docs.rs/bluer/latest/bluer/struct.DiscoveryFilter.html)
- [BlueR ErrorKind Documentation](https://docs.rs/bluer/latest/bluer/enum.ErrorKind.html)

---

### Critical Files for Implementation

- `/Users/jeffrey/code/tether/tether-core/src/bluetooth.rs` - The main Bluetooth scanner implementation (this entire file needs to be created)
- `/Users/jeffrey/code/tether/tether-core/src/lib.rs` - Module registration and re-exports for the bluetooth module
- `/Users/jeffrey/code/tether/tether-core/Cargo.toml` - Dependencies including bluer, tokio, thiserror, tracing, and serde with feature flags
- `/Users/jeffrey/code/tether/tether-core/tests/bluetooth_integration.rs` - Integration tests for real hardware validation on Raspberry Pi
