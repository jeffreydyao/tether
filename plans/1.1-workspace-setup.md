Now I have all the information needed. Let me compile the excruciating implementation details for setting up the tether Rust workspace.

---

# Tether Rust Workspace Setup - Excruciating Implementation Details

This document provides exact, copy-paste-ready content for setting up the tether Rust workspace. It is intended for Claude Code instances to execute without ambiguity.

---

## 1. Directory Structure to Create

Execute these commands in order from `/Users/jeffrey/code/tether`:

```
mkdir -p crates/tether-core/src
mkdir -p crates/tether-server/src
mkdir -p .cargo
```

The final structure will be:

```
/Users/jeffrey/code/tether/
├── .cargo/
│   └── config.toml
├── crates/
│   ├── tether-core/
│   │   ├── Cargo.toml
│   │   └── src/
│   │       └── lib.rs
│   └── tether-server/
│       ├── Cargo.toml
│       └── src/
│           └── main.rs
├── Cargo.toml           (workspace root)
├── Cross.toml
├── rust-toolchain.toml
└── claude-spec.md       (already exists)
```

---

## 2. Workspace Root `Cargo.toml`

**File:** `/Users/jeffrey/code/tether/Cargo.toml`

```toml
[workspace]
resolver = "2"
members = [
    "crates/tether-core",
    "crates/tether-server",
]

[workspace.package]
version = "0.1.0"
edition = "2021"
rust-version = "1.75"
authors = ["Jeffrey <jeffrey@example.com>"]
license = "MIT"
repository = "https://github.com/jeffrey/tether"

[workspace.dependencies]
# Async runtime
tokio = { version = "1.43", features = ["full"] }

# Web framework
axum = { version = "0.8", features = ["macros"] }
tower = { version = "0.5", features = ["full"] }
tower-http = { version = "0.6", features = ["cors", "trace", "compression-gzip"] }

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
toml = "0.8"

# OpenAPI documentation
utoipa = { version = "5.3", features = ["axum_extras", "chrono", "uuid"] }
utoipa-axum = "0.2"
utoipa-swagger-ui = { version = "9.0", features = ["axum"] }

# Bluetooth
btleplug = { version = "0.11", features = ["serde"] }

# Date/Time
chrono = { version = "0.4", features = ["serde"] }
chrono-tz = "0.10"

# Identifiers
uuid = { version = "1.11", features = ["v4", "v7", "serde"] }

# Error handling
thiserror = "2.0"
anyhow = "1.0"

# Logging/Tracing
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter", "json"] }
tracing-appender = "0.2"

# Configuration
config = "0.14"
directories = "5.0"

# Internal crates
tether-core = { path = "crates/tether-core" }

[workspace.lints.rust]
unsafe_code = "forbid"

[workspace.lints.clippy]
all = "warn"
pedantic = "warn"
nursery = "warn"

[profile.release]
lto = true
codegen-units = 1
panic = "abort"
strip = true
opt-level = "z"

[profile.dev]
opt-level = 0
debug = true
```

---

## 3. `tether-core` Crate `Cargo.toml`

**File:** `/Users/jeffrey/code/tether/crates/tether-core/Cargo.toml`

```toml
[package]
name = "tether-core"
description = "Core business logic for tether - phone proximity tracking for Raspberry Pi"
version.workspace = true
edition.workspace = true
rust-version.workspace = true
authors.workspace = true
license.workspace = true

[dependencies]
# Async runtime
tokio = { workspace = true }

# Serialization
serde = { workspace = true }
serde_json = { workspace = true }
toml = { workspace = true }

# Bluetooth
btleplug = { workspace = true }

# Date/Time
chrono = { workspace = true }
chrono-tz = { workspace = true }

# Identifiers
uuid = { workspace = true }

# Error handling
thiserror = { workspace = true }
anyhow = { workspace = true }

# Logging
tracing = { workspace = true }

# Configuration
config = { workspace = true }
directories = { workspace = true }

# OpenAPI schema generation (for shared types)
utoipa = { workspace = true }

[dev-dependencies]
tokio-test = "0.4"

[lints]
workspace = true
```

---

## 4. `tether-server` Crate `Cargo.toml`

**File:** `/Users/jeffrey/code/tether/crates/tether-server/Cargo.toml`

```toml
[package]
name = "tether-server"
description = "HTTP server for tether - exposes proximity tracking and pass management via REST API"
version.workspace = true
edition.workspace = true
rust-version.workspace = true
authors.workspace = true
license.workspace = true

[[bin]]
name = "tether-server"
path = "src/main.rs"

[dependencies]
# Internal crates
tether-core = { workspace = true }

# Async runtime
tokio = { workspace = true }

# Web framework
axum = { workspace = true }
tower = { workspace = true }
tower-http = { workspace = true }

# Serialization
serde = { workspace = true }
serde_json = { workspace = true }

# OpenAPI documentation
utoipa = { workspace = true }
utoipa-axum = { workspace = true }
utoipa-swagger-ui = { workspace = true }

# Date/Time
chrono = { workspace = true }
chrono-tz = { workspace = true }

# Identifiers
uuid = { workspace = true }

# Error handling
thiserror = { workspace = true }
anyhow = { workspace = true }

# Logging
tracing = { workspace = true }
tracing-subscriber = { workspace = true }
tracing-appender = { workspace = true }

[dev-dependencies]
axum-test = "16.4"
tokio-test = "0.4"

[lints]
workspace = true
```

---

## 5. `tether-core/src/lib.rs` Content

**File:** `/Users/jeffrey/code/tether/crates/tether-core/src/lib.rs`

```rust
//! # tether-core
//!
//! Core business logic for the tether phone proximity tracking system.
//!
//! This crate provides:
//! - Bluetooth device discovery and proximity detection
//! - Pass management (monthly passes with history tracking)
//! - Configuration management (Wi-Fi, Bluetooth device, timezone)
//! - Persistent storage for pass data
//!
//! ## Architecture
//!
//! The crate is organized into the following modules:
//!
//! - [`bluetooth`] - Bluetooth Low Energy scanning and RSSI-based proximity detection
//! - [`config`] - Application configuration loading, saving, and validation
//! - [`passes`] - Monthly pass allocation, usage tracking, and history
//! - [`storage`] - Persistent storage for pass data using JSON files
//! - [`error`] - Unified error types for the crate
//! - [`types`] - Shared types and OpenAPI schemas

#![forbid(unsafe_code)]
#![warn(clippy::all, clippy::pedantic, clippy::nursery)]
#![warn(missing_docs)]

pub mod bluetooth;
pub mod config;
pub mod error;
pub mod passes;
pub mod storage;
pub mod types;

// Re-export primary types for convenience
pub use bluetooth::BluetoothScanner;
pub use config::TetherConfig;
pub use error::{Error, Result};
pub use passes::PassManager;
pub use storage::Storage;
pub use types::*;
```

---

## 6. `tether-server/src/main.rs` Stub

**File:** `/Users/jeffrey/code/tether/crates/tether-server/src/main.rs`

```rust
//! # tether-server
//!
//! HTTP server for the tether phone proximity tracking system.
//!
//! This binary provides:
//! - REST API for proximity checking, pass management, and configuration
//! - OpenAPI documentation via Swagger UI
//! - Structured logging to file and stdout
//!
//! ## Running
//!
//! ```bash
//! # Development
//! cargo run --package tether-server
//!
//! # Production (on Raspberry Pi)
//! ./tether-server
//! ```

#![forbid(unsafe_code)]
#![warn(clippy::all, clippy::pedantic, clippy::nursery)]

use std::net::SocketAddr;

use axum::Router;
use tokio::net::TcpListener;
use tracing::info;

mod api;
mod logging;
mod state;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Initialize logging
    logging::init()?;

    info!("Starting tether-server");

    // Build the application router
    let app = Router::new();
    // TODO: Add routes from api module

    // Bind to address
    let addr = SocketAddr::from(([0, 0, 0, 0], 3000));
    let listener = TcpListener::bind(addr).await?;

    info!("Listening on {}", addr);

    axum::serve(listener, app).await?;

    Ok(())
}
```

---

## 7. `.cargo/config.toml` for Cross-Compilation

**File:** `/Users/jeffrey/code/tether/.cargo/config.toml`

```toml
# Cargo configuration for tether
# Optimized for Raspberry Pi Zero 2 W (32-bit armhf) cross-compilation
# Using 32-bit because Pi Zero 2 W has only 512MB RAM

[build]
# Use sccache if available for faster rebuilds
# rustc-wrapper = "sccache"

[target.armv7-unknown-linux-gnueabihf]
# Primary target: 32-bit ARM for Raspberry Pi Zero 2 W
# Using armhf for better memory efficiency on 512MB RAM device
linker = "arm-linux-gnueabihf-gcc"

# Runner for cross-compiled binaries (useful for testing with QEMU)
# runner = "qemu-arm"

# Optimization flags for Raspberry Pi Zero 2 W (Cortex-A53 in 32-bit mode)
rustflags = [
    "-C", "target-cpu=cortex-a53",
    "-C", "link-arg=-Wl,--as-needed",
]

[target.aarch64-unknown-linux-gnu]
# Alternative: 64-bit ARM target (not recommended for Pi Zero 2 W due to RAM constraints)
linker = "aarch64-linux-gnu-gcc"
rustflags = [
    "-C", "target-cpu=cortex-a53",
    "-C", "link-arg=-Wl,--as-needed",
]

[alias]
# Convenience aliases
br = "build --release"
rr = "run --release"

# Cross-compilation aliases
build-pi = "build --release --target armv7-unknown-linux-gnueabihf"
build-pi64 = "build --release --target aarch64-unknown-linux-gnu"

[env]
# Environment variables for builds
RUST_BACKTRACE = "1"

[net]
# Retry configuration for crates.io
retry = 3
git-fetch-with-cli = true

[registries.crates-io]
protocol = "sparse"
```

---

## 8. `Cross.toml` for ARM64 Cross-Compilation

**File:** `/Users/jeffrey/code/tether/Cross.toml`

```toml
# Cross.toml - Configuration for cross-rs
# Used for cross-compiling tether to Raspberry Pi Zero 2 W (32-bit armhf)
#
# Usage:
#   cross build --release --target armv7-unknown-linux-gnueabihf
#
# Prerequisites:
#   cargo install cross --git https://github.com/cross-rs/cross
#   Docker or Podman must be running

[build]
# Build configuration - using 32-bit for Pi Zero 2 W (512MB RAM)
default-target = "armv7-unknown-linux-gnueabihf"

[build.env]
# Pass through environment variables to the container
passthrough = [
    "RUST_LOG",
    "RUST_BACKTRACE",
]

[target.armv7-unknown-linux-gnueabihf]
# Primary target: 32-bit ARM for Raspberry Pi Zero 2 W
image = "ghcr.io/cross-rs/armv7-unknown-linux-gnueabihf:0.2.5"

# Pre-build script (install additional packages if needed)
# pre-build = [
#     "apt-get update && apt-get install -y libbluetooth-dev libdbus-1-dev"
# ]

# Environment variables for this target
[target.armv7-unknown-linux-gnueabihf.env]
passthrough = [
    "RUST_LOG",
    "RUST_BACKTRACE",
]

[target.aarch64-unknown-linux-gnu]
# Alternative: 64-bit ARM target (not recommended for Pi Zero 2 W)
image = "ghcr.io/cross-rs/aarch64-unknown-linux-gnu:0.2.5"

[target.aarch64-unknown-linux-gnu.env]
passthrough = [
    "RUST_LOG",
    "RUST_BACKTRACE",
]

# Custom image configuration (uncomment if you need Bluetooth dev libraries)
# [target.armv7-unknown-linux-gnueabihf]
# dockerfile = "./docker/Dockerfile.armv7"
# context = "./docker"
```

---

## 9. `rust-toolchain.toml`

**File:** `/Users/jeffrey/code/tether/rust-toolchain.toml`

```toml
[toolchain]
channel = "1.83"
components = ["rustfmt", "clippy", "rust-analyzer"]
targets = [
    "armv7-unknown-linux-gnueabihf",
    "aarch64-unknown-linux-gnu",
]
profile = "default"
```

---

## 10. Module Stub Files for `tether-core`

Create these empty module files:

**File:** `/Users/jeffrey/code/tether/crates/tether-core/src/bluetooth.rs`

```rust
//! Bluetooth Low Energy scanning and proximity detection.
//!
//! This module provides functionality to:
//! - Scan for BLE devices
//! - Track RSSI (signal strength) of configured devices
//! - Determine if a device is "nearby" based on configurable thresholds

use crate::error::Result;
use crate::types::{BluetoothDevice, ProximityStatus};

/// Bluetooth scanner for detecting phone proximity.
pub struct BluetoothScanner {
    // TODO: Add btleplug adapter
}

impl BluetoothScanner {
    /// Create a new Bluetooth scanner.
    ///
    /// # Errors
    ///
    /// Returns an error if Bluetooth is not available on the system.
    pub async fn new() -> Result<Self> {
        todo!("Initialize btleplug adapter")
    }

    /// Scan for available Bluetooth devices.
    ///
    /// Returns a list of discovered devices with their names and addresses.
    pub async fn scan_devices(&self) -> Result<Vec<BluetoothDevice>> {
        todo!("Implement device scanning")
    }

    /// Check if the configured device is nearby.
    ///
    /// # Arguments
    ///
    /// * `device_address` - The MAC address of the device to check
    /// * `rssi_threshold` - The minimum RSSI value to consider "nearby" (typically -70 to -50)
    pub async fn is_device_nearby(
        &self,
        device_address: &str,
        rssi_threshold: i16,
    ) -> Result<ProximityStatus> {
        todo!("Implement proximity check")
    }

    /// Get the current RSSI for a device.
    pub async fn get_device_rssi(&self, device_address: &str) -> Result<Option<i16>> {
        todo!("Implement RSSI retrieval")
    }
}
```

**File:** `/Users/jeffrey/code/tether/crates/tether-core/src/config.rs`

```rust
//! Application configuration management.
//!
//! Handles loading, saving, and validating tether configuration including:
//! - Bluetooth device to track
//! - RSSI threshold for proximity
//! - Monthly pass allocation
//! - Timezone settings
//! - Wi-Fi network configuration

use std::path::PathBuf;

use chrono_tz::Tz;
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

use crate::error::Result;

/// Main application configuration.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
pub struct TetherConfig {
    /// Bluetooth device MAC address to track.
    pub bluetooth_device: Option<String>,

    /// RSSI threshold for considering device "nearby".
    /// Typical values: -70 (far) to -30 (very close).
    #[schema(example = -60)]
    pub rssi_threshold: i16,

    /// Number of passes available per month.
    #[schema(example = 3)]
    pub passes_per_month: u8,

    /// Timezone for pass refresh (midnight local time).
    #[schema(example = "America/New_York")]
    #[serde(with = "timezone_serde")]
    pub timezone: Tz,

    /// Wi-Fi networks in priority order.
    pub wifi_networks: Vec<WifiNetwork>,

    /// Whether initial setup has been completed.
    pub setup_completed: bool,
}

/// Wi-Fi network configuration.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
pub struct WifiNetwork {
    /// Network SSID.
    pub ssid: String,

    /// Network password (stored securely).
    #[serde(skip_serializing)]
    pub password: Option<String>,

    /// Whether this is the primary network.
    pub is_primary: bool,
}

impl Default for TetherConfig {
    fn default() -> Self {
        Self {
            bluetooth_device: None,
            rssi_threshold: -60,
            passes_per_month: 3,
            timezone: chrono_tz::UTC,
            wifi_networks: Vec::new(),
            setup_completed: false,
        }
    }
}

impl TetherConfig {
    /// Load configuration from disk.
    ///
    /// # Errors
    ///
    /// Returns an error if the config file cannot be read or parsed.
    pub fn load() -> Result<Self> {
        let path = Self::config_path()?;
        if path.exists() {
            let content = std::fs::read_to_string(&path)?;
            let config: Self = toml::from_str(&content)?;
            Ok(config)
        } else {
            Ok(Self::default())
        }
    }

    /// Save configuration to disk.
    ///
    /// # Errors
    ///
    /// Returns an error if the config file cannot be written.
    pub fn save(&self) -> Result<()> {
        let path = Self::config_path()?;
        if let Some(parent) = path.parent() {
            std::fs::create_dir_all(parent)?;
        }
        let content = toml::to_string_pretty(self)?;
        std::fs::write(path, content)?;
        Ok(())
    }

    /// Get the configuration file path.
    fn config_path() -> Result<PathBuf> {
        // On Raspberry Pi: /etc/tether/config.toml
        // For development: ~/.config/tether/config.toml
        #[cfg(target_os = "linux")]
        {
            Ok(PathBuf::from("/etc/tether/config.toml"))
        }
        #[cfg(not(target_os = "linux"))]
        {
            let dirs = directories::ProjectDirs::from("", "", "tether")
                .ok_or_else(|| crate::error::Error::Config("Cannot determine config directory".into()))?;
            Ok(dirs.config_dir().join("config.toml"))
        }
    }
}

mod timezone_serde {
    use chrono_tz::Tz;
    use serde::{self, Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(tz: &Tz, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(tz.name())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Tz, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}
```

**File:** `/Users/jeffrey/code/tether/crates/tether-core/src/error.rs`

```rust
//! Error types for tether-core.

use thiserror::Error;

/// Result type alias using tether's Error type.
pub type Result<T> = std::result::Result<T, Error>;

/// Unified error type for tether-core operations.
#[derive(Debug, Error)]
pub enum Error {
    /// Bluetooth-related errors.
    #[error("Bluetooth error: {0}")]
    Bluetooth(String),

    /// Configuration errors.
    #[error("Configuration error: {0}")]
    Config(String),

    /// Storage/persistence errors.
    #[error("Storage error: {0}")]
    Storage(String),

    /// Pass management errors.
    #[error("Pass error: {0}")]
    Pass(String),

    /// No passes remaining for the current month.
    #[error("No passes remaining for this month")]
    NoPassesRemaining,

    /// Device not found.
    #[error("Device not found: {0}")]
    DeviceNotFound(String),

    /// IO errors.
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    /// Serialization errors.
    #[error("Serialization error: {0}")]
    Serialization(String),

    /// TOML parsing errors.
    #[error("TOML error: {0}")]
    Toml(#[from] toml::de::Error),

    /// TOML serialization errors.
    #[error("TOML serialization error: {0}")]
    TomlSer(#[from] toml::ser::Error),

    /// JSON errors.
    #[error("JSON error: {0}")]
    Json(#[from] serde_json::Error),
}
```

**File:** `/Users/jeffrey/code/tether/crates/tether-core/src/passes.rs`

```rust
//! Monthly pass allocation and tracking.
//!
//! Passes allow users to bypass the proximity requirement for a night.
//! They refresh automatically at midnight on the first day of each month.

use chrono::{DateTime, Datelike, Utc};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

use crate::config::TetherConfig;
use crate::error::{Error, Result};
use crate::storage::Storage;

/// A single pass usage record.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
pub struct PassUsage {
    /// When the pass was used (UTC).
    pub used_at_utc: DateTime<Utc>,

    /// User-provided reason for using the pass.
    #[schema(example = "Traveling for work")]
    pub reason: String,
}

/// Pass state for a specific month.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
pub struct MonthlyPassState {
    /// Year of this pass state.
    pub year: i32,

    /// Month of this pass state (1-12).
    pub month: u32,

    /// Passes allocated for this month.
    pub allocated: u8,

    /// Passes used this month.
    pub used: Vec<PassUsage>,
}

impl MonthlyPassState {
    /// Get the number of remaining passes.
    #[must_use]
    pub fn remaining(&self) -> u8 {
        self.allocated.saturating_sub(self.used.len() as u8)
    }
}

/// Manager for pass allocation and usage tracking.
pub struct PassManager {
    storage: Storage,
    config: TetherConfig,
}

impl PassManager {
    /// Create a new pass manager.
    pub fn new(storage: Storage, config: TetherConfig) -> Self {
        Self { storage, config }
    }

    /// Get the current month's pass state.
    ///
    /// If no state exists for the current month, creates a new one.
    pub fn current_month_state(&self) -> Result<MonthlyPassState> {
        let now = Utc::now();
        self.get_or_create_month_state(now.year(), now.month())
    }

    /// Get passes remaining for the current month.
    pub fn remaining_passes(&self) -> Result<u8> {
        Ok(self.current_month_state()?.remaining())
    }

    /// Use a pass with the given reason.
    ///
    /// # Errors
    ///
    /// Returns `Error::NoPassesRemaining` if no passes are available.
    pub fn use_pass(&mut self, reason: String) -> Result<PassUsage> {
        let mut state = self.current_month_state()?;

        if state.remaining() == 0 {
            return Err(Error::NoPassesRemaining);
        }

        let usage = PassUsage {
            used_at_utc: Utc::now(),
            reason,
        };

        state.used.push(usage.clone());
        self.storage.save_month_state(&state)?;

        Ok(usage)
    }

    /// Get pass history for a specific month.
    pub fn get_month_history(&self, year: i32, month: u32) -> Result<Option<MonthlyPassState>> {
        self.storage.load_month_state(year, month)
    }

    fn get_or_create_month_state(&self, year: i32, month: u32) -> Result<MonthlyPassState> {
        match self.storage.load_month_state(year, month)? {
            Some(state) => Ok(state),
            None => Ok(MonthlyPassState {
                year,
                month,
                allocated: self.config.passes_per_month,
                used: Vec::new(),
            }),
        }
    }
}
```

**File:** `/Users/jeffrey/code/tether/crates/tether-core/src/storage.rs`

```rust
//! Persistent storage for pass data.
//!
//! Uses JSON files organized by year/month for efficient lookup.

use std::path::PathBuf;

use crate::error::Result;
use crate::passes::MonthlyPassState;

/// Storage backend for tether data.
#[derive(Debug, Clone)]
pub struct Storage {
    data_dir: PathBuf,
}

impl Storage {
    /// Create a new storage instance.
    ///
    /// # Arguments
    ///
    /// * `data_dir` - Directory to store data files
    pub fn new(data_dir: PathBuf) -> Self {
        Self { data_dir }
    }

    /// Get the default storage location.
    ///
    /// On Raspberry Pi: `/var/lib/tether/`
    /// For development: `~/.local/share/tether/`
    pub fn default() -> Result<Self> {
        #[cfg(target_os = "linux")]
        {
            Ok(Self::new(PathBuf::from("/var/lib/tether")))
        }
        #[cfg(not(target_os = "linux"))]
        {
            let dirs = directories::ProjectDirs::from("", "", "tether")
                .ok_or_else(|| crate::error::Error::Storage("Cannot determine data directory".into()))?;
            Ok(Self::new(dirs.data_dir().to_path_buf()))
        }
    }

    /// Load pass state for a specific month.
    pub fn load_month_state(&self, year: i32, month: u32) -> Result<Option<MonthlyPassState>> {
        let path = self.month_path(year, month);
        if path.exists() {
            let content = std::fs::read_to_string(&path)?;
            let state: MonthlyPassState = serde_json::from_str(&content)?;
            Ok(Some(state))
        } else {
            Ok(None)
        }
    }

    /// Save pass state for a specific month.
    pub fn save_month_state(&self, state: &MonthlyPassState) -> Result<()> {
        let path = self.month_path(state.year, state.month);
        if let Some(parent) = path.parent() {
            std::fs::create_dir_all(parent)?;
        }
        let content = serde_json::to_string_pretty(state)?;
        std::fs::write(path, content)?;
        Ok(())
    }

    fn month_path(&self, year: i32, month: u32) -> PathBuf {
        self.data_dir
            .join("passes")
            .join(format!("{year}"))
            .join(format!("{month:02}.json"))
    }
}
```

**File:** `/Users/jeffrey/code/tether/crates/tether-core/src/types.rs`

```rust
//! Shared types and OpenAPI schemas.

use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

/// Bluetooth device information.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
pub struct BluetoothDevice {
    /// Device name (if available).
    #[schema(example = "iPhone")]
    pub name: Option<String>,

    /// Device MAC address.
    #[schema(example = "AA:BB:CC:DD:EE:FF")]
    pub address: String,

    /// Current RSSI value (signal strength).
    #[schema(example = -55)]
    pub rssi: Option<i16>,
}

/// Proximity status for a tracked device.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
pub struct ProximityStatus {
    /// The device being tracked.
    pub device: BluetoothDevice,

    /// Whether the device is considered nearby.
    pub is_nearby: bool,

    /// Current RSSI value.
    pub current_rssi: Option<i16>,

    /// Configured RSSI threshold.
    pub threshold: i16,
}

/// Health check response.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
pub struct HealthResponse {
    /// Service status.
    #[schema(example = "ok")]
    pub status: String,

    /// Service version.
    #[schema(example = "0.1.0")]
    pub version: String,
}
```

---

## 11. Server Module Stubs

**File:** `/Users/jeffrey/code/tether/crates/tether-server/src/api.rs`

```rust
//! HTTP API routes and handlers.

pub mod bluetooth;
pub mod config;
pub mod health;
pub mod passes;
```

**File:** `/Users/jeffrey/code/tether/crates/tether-server/src/logging.rs`

```rust
//! Logging initialization and configuration.

use std::path::PathBuf;

use tracing_appender::rolling::{RollingFileAppender, Rotation};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};

/// Initialize the logging system.
///
/// Logs are written to both stdout and a rolling file.
pub fn init() -> anyhow::Result<()> {
    let log_dir = log_directory();

    // Create rolling file appender
    let file_appender = RollingFileAppender::new(Rotation::DAILY, &log_dir, "tether.log");
    let (non_blocking, _guard) = tracing_appender::non_blocking(file_appender);

    // Build subscriber with multiple layers
    tracing_subscriber::registry()
        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info")))
        .with(tracing_subscriber::fmt::layer().with_writer(std::io::stdout))
        .with(tracing_subscriber::fmt::layer().with_writer(non_blocking).json())
        .init();

    // Store guard to keep file writer alive
    // Note: In production, store _guard in application state
    std::mem::forget(_guard);

    Ok(())
}

fn log_directory() -> PathBuf {
    #[cfg(target_os = "linux")]
    {
        PathBuf::from("/var/log/tether")
    }
    #[cfg(not(target_os = "linux"))]
    {
        directories::ProjectDirs::from("", "", "tether")
            .map(|dirs| dirs.data_dir().join("logs"))
            .unwrap_or_else(|| PathBuf::from("./logs"))
    }
}
```

**File:** `/Users/jeffrey/code/tether/crates/tether-server/src/state.rs`

```rust
//! Application state shared across handlers.

use std::sync::Arc;

use tether_core::{BluetoothScanner, PassManager, Storage, TetherConfig};
use tokio::sync::RwLock;

/// Shared application state.
#[derive(Clone)]
pub struct AppState {
    inner: Arc<AppStateInner>,
}

struct AppStateInner {
    pub config: RwLock<TetherConfig>,
    pub pass_manager: RwLock<PassManager>,
    pub bluetooth: RwLock<Option<BluetoothScanner>>,
}

impl AppState {
    /// Create new application state.
    pub async fn new() -> anyhow::Result<Self> {
        let config = TetherConfig::load()?;
        let storage = Storage::default()?;
        let pass_manager = PassManager::new(storage, config.clone());

        Ok(Self {
            inner: Arc::new(AppStateInner {
                config: RwLock::new(config),
                pass_manager: RwLock::new(pass_manager),
                bluetooth: RwLock::new(None),
            }),
        })
    }

    /// Get read access to config.
    pub async fn config(&self) -> tokio::sync::RwLockReadGuard<'_, TetherConfig> {
        self.inner.config.read().await
    }

    /// Get write access to config.
    pub async fn config_mut(&self) -> tokio::sync::RwLockWriteGuard<'_, TetherConfig> {
        self.inner.config.write().await
    }

    /// Get write access to pass manager.
    pub async fn pass_manager(&self) -> tokio::sync::RwLockWriteGuard<'_, PassManager> {
        self.inner.pass_manager.write().await
    }
}
```

---

## 12. Verification Commands

After creating all files, run these commands to verify the workspace:

```bash
# From /Users/jeffrey/code/tether

# 1. Check that workspace compiles
cargo check

# 2. Run clippy for linting
cargo clippy --all-targets --all-features

# 3. Format code
cargo fmt

# 4. Run tests
cargo test

# 5. Add cross-compilation targets
rustup target add armv7-unknown-linux-gnueabihf
rustup target add aarch64-unknown-linux-gnu

# 6. Install cross for cross-compilation
cargo install cross --git https://github.com/cross-rs/cross

# 7. Build for Raspberry Pi (requires Docker)
cross build --release --target armv7-unknown-linux-gnueabihf
```

---

## 13. Dependency Version Summary

| Crate | Version | Purpose |
|-------|---------|---------|
| tokio | 1.43 | Async runtime |
| axum | 0.8 | HTTP framework |
| tower | 0.5 | Middleware ecosystem |
| tower-http | 0.6 | HTTP-specific middleware |
| serde | 1.0 | Serialization framework |
| serde_json | 1.0 | JSON serialization |
| toml | 0.8 | TOML config parsing |
| utoipa | 5.3 | OpenAPI generation |
| utoipa-axum | 0.2 | Axum integration |
| utoipa-swagger-ui | 9.0 | Swagger UI serving |
| btleplug | 0.11 | Bluetooth Low Energy |
| chrono | 0.4 | Date/time handling |
| chrono-tz | 0.10 | Timezone support |
| uuid | 1.11 | UUID generation |
| thiserror | 2.0 | Error derive macros |
| anyhow | 1.0 | Error handling |
| tracing | 0.1 | Structured logging |
| tracing-subscriber | 0.3 | Log subscriber |
| tracing-appender | 0.2 | File appender |
| config | 0.14 | Configuration loading |
| directories | 5.0 | Platform directories |

---

### Critical Files for Implementation

- `/Users/jeffrey/code/tether/Cargo.toml` - Workspace root defining all shared dependencies and workspace members
- `/Users/jeffrey/code/tether/crates/tether-core/src/lib.rs` - Core library entry point with module declarations and re-exports
- `/Users/jeffrey/code/tether/crates/tether-core/Cargo.toml` - Core crate dependencies for business logic
- `/Users/jeffrey/code/tether/crates/tether-server/Cargo.toml` - Server crate dependencies for HTTP API
- `/Users/jeffrey/code/tether/Cross.toml` - Cross-compilation configuration for Raspberry Pi 32-bit ARM target (armv7-unknown-linux-gnueabihf)
