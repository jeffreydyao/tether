Now I have all the information needed to create comprehensive implementation details for the dashboard components. Let me compile this into excruciating detail.

---

# Dashboard Components Implementation Details

This document provides complete, copy-paste ready code for the Tether dashboard components. These components use React, TypeScript, TanStack Query, and shadcn/ui.

## Prerequisites and Project Setup

Before implementing these components, ensure you have:

1. **TanStack Query configured** in your project
2. **shadcn/ui components installed**: Card, Dialog, Button, Progress, Skeleton, Textarea
3. **Generated API client** from openapi-ts at `@/client`

### Required shadcn/ui Component Installation

```bash
bunx shadcn@latest add card dialog button progress skeleton textarea alert
```

### TanStack Query Provider Setup

File: `/Users/jeffrey/code/tether/web-ui/src/providers/QueryProvider.tsx`

```tsx
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactNode, useState } from "react";

interface QueryProviderProps {
  children: ReactNode;
}

export function QueryProvider({ children }: QueryProviderProps) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 1000, // Consider data stale after 1 second
            retry: 3,
            retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
          },
          mutations: {
            retry: 1,
          },
        },
      })
  );

  return (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );
}
```

---

## 1. ProximityCard Component

File: `/Users/jeffrey/code/tether/web-ui/src/components/dashboard/ProximityCard.tsx`

```tsx
"use client";

import { useQuery } from "@tanstack/react-query";
import { CheckCircle2, XCircle, AlertTriangle, RefreshCw, Bluetooth } from "lucide-react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Skeleton } from "@/components/ui/skeleton";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { cn } from "@/lib/utils";
import { getProximityStatus } from "@/client/services.gen";
import type { ProximityStatus } from "@/client/types.gen";

// Polling interval in milliseconds
const PROXIMITY_POLL_INTERVAL = 2000;

// RSSI thresholds for signal strength indication
const RSSI_THRESHOLDS = {
  EXCELLENT: -50, // Greater than -50 dBm
  GOOD: -60,      // -50 to -60 dBm
  FAIR: -70,      // -60 to -70 dBm
  WEAK: -80,      // -70 to -80 dBm
  // Below -80 is considered very weak
} as const;

interface ProximityCardProps {
  className?: string;
}

/**
 * ProximityCard displays the real-time proximity status of the configured Bluetooth device.
 * 
 * Features:
 * - Polls every 2 seconds for updated proximity status
 * - Large visual indicator (green check when nearby, red X when away)
 * - Displays device name and current RSSI value
 * - Shows loading skeleton during initial load
 * - Error state with retry functionality
 * - Signal strength indicator based on RSSI value
 */
export function ProximityCard({ className }: ProximityCardProps) {
  const {
    data: proximityStatus,
    isLoading,
    isError,
    error,
    refetch,
    isFetching,
  } = useQuery<ProximityStatus>({
    queryKey: ["proximity", "status"],
    queryFn: async () => {
      const response = await getProximityStatus();
      if (response.error) {
        throw new Error(response.error.message || "Failed to fetch proximity status");
      }
      return response.data;
    },
    refetchInterval: PROXIMITY_POLL_INTERVAL,
    refetchIntervalInBackground: false, // Stop polling when tab is not focused
    staleTime: PROXIMITY_POLL_INTERVAL - 500, // Consider stale just before next poll
  });

  // Determine signal strength category from RSSI
  const getSignalStrength = (rssi: number): "excellent" | "good" | "fair" | "weak" | "very-weak" => {
    if (rssi > RSSI_THRESHOLDS.EXCELLENT) return "excellent";
    if (rssi > RSSI_THRESHOLDS.GOOD) return "good";
    if (rssi > RSSI_THRESHOLDS.FAIR) return "fair";
    if (rssi > RSSI_THRESHOLDS.WEAK) return "weak";
    return "very-weak";
  };

  // Get color classes for signal strength
  const getSignalColor = (rssi: number): string => {
    const strength = getSignalStrength(rssi);
    switch (strength) {
      case "excellent":
      case "good":
        return "text-green-500";
      case "fair":
        return "text-yellow-500";
      case "weak":
      case "very-weak":
        return "text-red-500";
    }
  };

  // Loading skeleton state
  if (isLoading) {
    return (
      <Card className={cn("relative overflow-hidden", className)}>
        <CardHeader className="pb-2">
          <div className="flex items-center gap-2">
            <Skeleton className="h-5 w-5 rounded" />
            <Skeleton className="h-6 w-32" />
          </div>
          <Skeleton className="h-4 w-48 mt-1" />
        </CardHeader>
        <CardContent className="flex flex-col items-center justify-center py-8">
          <Skeleton className="h-24 w-24 rounded-full" />
          <Skeleton className="h-6 w-40 mt-4" />
          <Skeleton className="h-4 w-24 mt-2" />
        </CardContent>
      </Card>
    );
  }

  // Error state with retry
  if (isError) {
    return (
      <Card className={cn("relative overflow-hidden", className)}>
        <CardHeader className="pb-2">
          <CardTitle className="flex items-center gap-2 text-lg">
            <Bluetooth className="h-5 w-5" />
            Proximity Status
          </CardTitle>
          <CardDescription>Device tracking</CardDescription>
        </CardHeader>
        <CardContent className="flex flex-col items-center justify-center py-6">
          <Alert variant="destructive" className="mb-4">
            <AlertTriangle className="h-4 w-4" />
            <AlertDescription>
              {error instanceof Error
                ? error.message
                : "Failed to check proximity status"}
            </AlertDescription>
          </Alert>
          <Button
            variant="outline"
            onClick={() => refetch()}
            disabled={isFetching}
            className="gap-2"
          >
            <RefreshCw className={cn("h-4 w-4", isFetching && "animate-spin")} />
            Retry
          </Button>
        </CardContent>
      </Card>
    );
  }

  const isNearby = proximityStatus?.is_nearby ?? false;
  const deviceName = proximityStatus?.device_name ?? "Unknown Device";
  const rssi = proximityStatus?.rssi;

  return (
    <Card className={cn("relative overflow-hidden", className)}>
      {/* Subtle polling indicator */}
      {isFetching && (
        <div className="absolute top-2 right-2">
          <div className="h-2 w-2 rounded-full bg-blue-500 animate-pulse" />
        </div>
      )}

      <CardHeader className="pb-2">
        <CardTitle className="flex items-center gap-2 text-lg">
          <Bluetooth className="h-5 w-5" />
          Proximity Status
        </CardTitle>
        <CardDescription>Real-time device tracking</CardDescription>
      </CardHeader>

      <CardContent className="flex flex-col items-center justify-center py-6">
        {/* Large status indicator */}
        <div
          className={cn(
            "flex items-center justify-center rounded-full p-6 transition-all duration-300",
            isNearby
              ? "bg-green-100 dark:bg-green-900/30"
              : "bg-red-100 dark:bg-red-900/30"
          )}
        >
          {isNearby ? (
            <CheckCircle2 className="h-16 w-16 text-green-500 dark:text-green-400" />
          ) : (
            <XCircle className="h-16 w-16 text-red-500 dark:text-red-400" />
          )}
        </div>

        {/* Status text */}
        <p
          className={cn(
            "mt-4 text-xl font-semibold",
            isNearby
              ? "text-green-600 dark:text-green-400"
              : "text-red-600 dark:text-red-400"
          )}
        >
          {isNearby ? "Device Nearby" : "Device Away"}
        </p>

        {/* Device name */}
        <p className="mt-1 text-sm text-muted-foreground">{deviceName}</p>

        {/* RSSI value (only shown when device is detected) */}
        {rssi !== undefined && rssi !== null && (
          <div className="mt-3 flex items-center gap-2">
            <span className="text-xs text-muted-foreground">Signal:</span>
            <span className={cn("text-sm font-mono font-medium", getSignalColor(rssi))}>
              {rssi} dBm
            </span>
            <span className="text-xs text-muted-foreground capitalize">
              ({getSignalStrength(rssi)})
            </span>
          </div>
        )}

        {/* Manual refresh button */}
        <Button
          variant="ghost"
          size="sm"
          onClick={() => refetch()}
          disabled={isFetching}
          className="mt-4 gap-2 text-xs text-muted-foreground"
        >
          <RefreshCw className={cn("h-3 w-3", isFetching && "animate-spin")} />
          Refresh now
        </Button>
      </CardContent>
    </Card>
  );
}

export default ProximityCard;
```

---

## 2. PassesCard Component

File: `/Users/jeffrey/code/tether/web-ui/src/components/dashboard/PassesCard.tsx`

```tsx
"use client";

import { useState } from "react";
import { useQuery } from "@tanstack/react-query";
import { Ticket, AlertCircle } from "lucide-react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { Skeleton } from "@/components/ui/skeleton";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { cn } from "@/lib/utils";
import { getPassesRemaining } from "@/client/services.gen";
import type { PassesInfo } from "@/client/types.gen";
import { UsePassDialog } from "./UsePassDialog";

interface PassesCardProps {
  className?: string;
}

/**
 * PassesCard displays the remaining passes for the current month.
 * 
 * Features:
 * - Large number display for remaining passes
 * - Total passes for the month
 * - Visual progress indicator
 * - "Use Pass" button that opens a dialog
 * - Disabled state when no passes remaining
 * - Color-coded based on remaining passes (green/yellow/red)
 */
export function PassesCard({ className }: PassesCardProps) {
  const [isDialogOpen, setIsDialogOpen] = useState(false);

  const {
    data: passesInfo,
    isLoading,
    isError,
    error,
    refetch,
  } = useQuery<PassesInfo>({
    queryKey: ["passes", "remaining"],
    queryFn: async () => {
      const response = await getPassesRemaining();
      if (response.error) {
        throw new Error(response.error.message || "Failed to fetch passes info");
      }
      return response.data;
    },
    staleTime: 30000, // Consider stale after 30 seconds
  });

  // Calculate progress percentage and color
  const getProgressInfo = (remaining: number, total: number) => {
    const usedPercentage = ((total - remaining) / total) * 100;
    const remainingPercentage = (remaining / total) * 100;

    let colorClass: string;
    if (remainingPercentage > 50) {
      colorClass = "bg-green-500";
    } else if (remainingPercentage > 25) {
      colorClass = "bg-yellow-500";
    } else {
      colorClass = "bg-red-500";
    }

    return { usedPercentage, remainingPercentage, colorClass };
  };

  // Get text color based on remaining passes
  const getRemainingColor = (remaining: number, total: number): string => {
    const percentage = (remaining / total) * 100;
    if (percentage > 50) return "text-green-600 dark:text-green-400";
    if (percentage > 25) return "text-yellow-600 dark:text-yellow-400";
    return "text-red-600 dark:text-red-400";
  };

  // Get current month name
  const getCurrentMonthName = (): string => {
    return new Intl.DateTimeFormat("en-US", { month: "long", year: "numeric" }).format(
      new Date()
    );
  };

  // Loading skeleton
  if (isLoading) {
    return (
      <Card className={cn("relative", className)}>
        <CardHeader className="pb-2">
          <div className="flex items-center gap-2">
            <Skeleton className="h-5 w-5 rounded" />
            <Skeleton className="h-6 w-32" />
          </div>
          <Skeleton className="h-4 w-40 mt-1" />
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex items-baseline justify-center gap-2">
            <Skeleton className="h-16 w-20" />
            <Skeleton className="h-6 w-16" />
          </div>
          <Skeleton className="h-2 w-full rounded-full" />
          <Skeleton className="h-10 w-full rounded-md" />
        </CardContent>
      </Card>
    );
  }

  // Error state
  if (isError) {
    return (
      <Card className={cn("relative", className)}>
        <CardHeader className="pb-2">
          <CardTitle className="flex items-center gap-2 text-lg">
            <Ticket className="h-5 w-5" />
            Passes
          </CardTitle>
          <CardDescription>{getCurrentMonthName()}</CardDescription>
        </CardHeader>
        <CardContent>
          <Alert variant="destructive">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>
              {error instanceof Error ? error.message : "Failed to load passes"}
            </AlertDescription>
          </Alert>
          <Button variant="outline" onClick={() => refetch()} className="w-full mt-4">
            Retry
          </Button>
        </CardContent>
      </Card>
    );
  }

  const remaining = passesInfo?.remaining ?? 0;
  const total = passesInfo?.total_for_month ?? 0;
  const { usedPercentage, colorClass } = getProgressInfo(remaining, total);
  const hasPassesRemaining = remaining > 0;

  return (
    <>
      <Card className={cn("relative", className)}>
        <CardHeader className="pb-2">
          <CardTitle className="flex items-center gap-2 text-lg">
            <Ticket className="h-5 w-5" />
            Passes
          </CardTitle>
          <CardDescription>{getCurrentMonthName()}</CardDescription>
        </CardHeader>

        <CardContent className="space-y-4">
          {/* Large remaining count display */}
          <div className="flex items-baseline justify-center gap-2 py-4">
            <span
              className={cn(
                "text-5xl font-bold tabular-nums",
                getRemainingColor(remaining, total)
              )}
            >
              {remaining}
            </span>
            <span className="text-lg text-muted-foreground">/ {total}</span>
          </div>

          {/* Progress bar showing used passes */}
          <div className="space-y-1.5">
            <div className="flex justify-between text-xs text-muted-foreground">
              <span>Used this month</span>
              <span>
                {total - remaining} of {total}
              </span>
            </div>
            <div className="relative h-2 w-full overflow-hidden rounded-full bg-secondary">
              <div
                className={cn("h-full transition-all duration-500", colorClass)}
                style={{ width: `${usedPercentage}%` }}
              />
            </div>
          </div>

          {/* Use Pass button */}
          <Button
            className="w-full"
            variant={hasPassesRemaining ? "default" : "secondary"}
            disabled={!hasPassesRemaining}
            onClick={() => setIsDialogOpen(true)}
          >
            {hasPassesRemaining ? "Use Pass" : "No Passes Remaining"}
          </Button>

          {/* Warning when low on passes */}
          {hasPassesRemaining && remaining <= 2 && (
            <p className="text-xs text-center text-yellow-600 dark:text-yellow-400">
              {remaining === 1
                ? "Last pass for this month!"
                : `Only ${remaining} passes remaining`}
            </p>
          )}
        </CardContent>
      </Card>

      {/* Use Pass Dialog */}
      <UsePassDialog
        open={isDialogOpen}
        onOpenChange={setIsDialogOpen}
        currentRemaining={remaining}
        totalForMonth={total}
      />
    </>
  );
}

export default PassesCard;
```

---

## 3. PassHistoryList Component

File: `/Users/jeffrey/code/tether/web-ui/src/components/dashboard/PassHistoryList.tsx`

```tsx
"use client";

import { useState } from "react";
import { useQuery } from "@tanstack/react-query";
import { ChevronLeft, ChevronRight, History, FileText } from "lucide-react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Skeleton } from "@/components/ui/skeleton";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { cn } from "@/lib/utils";
import { getPassHistory } from "@/client/services.gen";
import type { PassHistoryEntry, PassHistoryResponse } from "@/client/types.gen";

interface PassHistoryListProps {
  className?: string;
  /** If true, shows month navigation controls */
  showNavigation?: boolean;
  /** Maximum number of entries to display (undefined = all) */
  maxEntries?: number;
}

/**
 * PassHistoryList displays a list of used passes for the selected month.
 * 
 * Features:
 * - Lists all passes used in the current/selected month
 * - Each entry shows date, time, and reason
 * - Empty state when no passes have been used
 * - Optional month navigation (previous/next)
 * - Relative time display (e.g., "2 days ago")
 */
export function PassHistoryList({
  className,
  showNavigation = true,
  maxEntries,
}: PassHistoryListProps) {
  // Track the selected month (format: YYYY-MM)
  const [selectedMonth, setSelectedMonth] = useState<string>(() => {
    const now = new Date();
    return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, "0")}`;
  });

  const {
    data: historyResponse,
    isLoading,
    isError,
    error,
    refetch,
  } = useQuery<PassHistoryResponse>({
    queryKey: ["passes", "history", selectedMonth],
    queryFn: async () => {
      const response = await getPassHistory({ month: selectedMonth });
      if (response.error) {
        throw new Error(response.error.message || "Failed to fetch pass history");
      }
      return response.data;
    },
    staleTime: 60000, // Consider stale after 1 minute
  });

  // Navigate to previous month
  const goToPreviousMonth = () => {
    const [year, month] = selectedMonth.split("-").map(Number);
    const date = new Date(year, month - 2, 1); // month - 2 because months are 0-indexed
    setSelectedMonth(
      `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}`
    );
  };

  // Navigate to next month
  const goToNextMonth = () => {
    const [year, month] = selectedMonth.split("-").map(Number);
    const date = new Date(year, month, 1);
    setSelectedMonth(
      `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}`
    );
  };

  // Check if we can navigate to next month (can't go past current month)
  const canGoToNextMonth = (): boolean => {
    const now = new Date();
    const currentMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, "0")}`;
    return selectedMonth < currentMonth;
  };

  // Format the selected month for display
  const formatMonthDisplay = (monthStr: string): string => {
    const [year, month] = monthStr.split("-").map(Number);
    return new Intl.DateTimeFormat("en-US", { month: "long", year: "numeric" }).format(
      new Date(year, month - 1)
    );
  };

  // Format a UTC timestamp for display
  const formatDateTime = (
    utcTimestamp: string
  ): { date: string; time: string; relative: string } => {
    const date = new Date(utcTimestamp);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

    // Format date
    const dateStr = new Intl.DateTimeFormat("en-US", {
      weekday: "short",
      month: "short",
      day: "numeric",
    }).format(date);

    // Format time
    const timeStr = new Intl.DateTimeFormat("en-US", {
      hour: "numeric",
      minute: "2-digit",
      hour12: true,
    }).format(date);

    // Relative time
    let relative: string;
    if (diffDays === 0) {
      relative = "Today";
    } else if (diffDays === 1) {
      relative = "Yesterday";
    } else if (diffDays < 7) {
      relative = `${diffDays} days ago`;
    } else if (diffDays < 30) {
      const weeks = Math.floor(diffDays / 7);
      relative = `${weeks} ${weeks === 1 ? "week" : "weeks"} ago`;
    } else {
      relative = dateStr;
    }

    return { date: dateStr, time: timeStr, relative };
  };

  // Loading skeleton
  if (isLoading) {
    return (
      <Card className={cn("relative", className)}>
        <CardHeader className="pb-2">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <Skeleton className="h-5 w-5 rounded" />
              <Skeleton className="h-6 w-24" />
            </div>
            {showNavigation && (
              <div className="flex items-center gap-1">
                <Skeleton className="h-8 w-8 rounded" />
                <Skeleton className="h-5 w-32" />
                <Skeleton className="h-8 w-8 rounded" />
              </div>
            )}
          </div>
        </CardHeader>
        <CardContent className="space-y-3">
          {[1, 2, 3].map((i) => (
            <div key={i} className="flex items-start gap-3 p-3 rounded-lg border">
              <Skeleton className="h-10 w-10 rounded-full" />
              <div className="flex-1 space-y-2">
                <Skeleton className="h-4 w-24" />
                <Skeleton className="h-3 w-full" />
              </div>
            </div>
          ))}
        </CardContent>
      </Card>
    );
  }

  // Error state
  if (isError) {
    return (
      <Card className={cn("relative", className)}>
        <CardHeader className="pb-2">
          <CardTitle className="flex items-center gap-2 text-lg">
            <History className="h-5 w-5" />
            Pass History
          </CardTitle>
        </CardHeader>
        <CardContent>
          <Alert variant="destructive">
            <AlertDescription>
              {error instanceof Error ? error.message : "Failed to load history"}
            </AlertDescription>
          </Alert>
          <Button variant="outline" onClick={() => refetch()} className="w-full mt-4">
            Retry
          </Button>
        </CardContent>
      </Card>
    );
  }

  const entries = historyResponse?.entries ?? [];
  const displayEntries = maxEntries ? entries.slice(0, maxEntries) : entries;

  return (
    <Card className={cn("relative", className)}>
      <CardHeader className="pb-2">
        <div className="flex items-center justify-between">
          <CardTitle className="flex items-center gap-2 text-lg">
            <History className="h-5 w-5" />
            Pass History
          </CardTitle>

          {/* Month navigation */}
          {showNavigation && (
            <div className="flex items-center gap-1">
              <Button
                variant="ghost"
                size="icon"
                className="h-8 w-8"
                onClick={goToPreviousMonth}
              >
                <ChevronLeft className="h-4 w-4" />
                <span className="sr-only">Previous month</span>
              </Button>

              <span className="text-sm font-medium min-w-[140px] text-center">
                {formatMonthDisplay(selectedMonth)}
              </span>

              <Button
                variant="ghost"
                size="icon"
                className="h-8 w-8"
                onClick={goToNextMonth}
                disabled={!canGoToNextMonth()}
              >
                <ChevronRight className="h-4 w-4" />
                <span className="sr-only">Next month</span>
              </Button>
            </div>
          )}
        </div>
        {!showNavigation && (
          <CardDescription>{formatMonthDisplay(selectedMonth)}</CardDescription>
        )}
      </CardHeader>

      <CardContent>
        {/* Empty state */}
        {entries.length === 0 ? (
          <div className="flex flex-col items-center justify-center py-8 text-center">
            <div className="rounded-full bg-muted p-3 mb-3">
              <FileText className="h-6 w-6 text-muted-foreground" />
            </div>
            <p className="text-sm font-medium">No passes used</p>
            <p className="text-xs text-muted-foreground mt-1">
              You haven&apos;t used any passes in {formatMonthDisplay(selectedMonth)}
            </p>
          </div>
        ) : (
          <div className="space-y-2">
            {displayEntries.map((entry: PassHistoryEntry, index: number) => {
              const { date, time, relative } = formatDateTime(entry.used_at_utc);

              return (
                <div
                  key={entry.used_at_utc + index}
                  className="flex items-start gap-3 p-3 rounded-lg border bg-card hover:bg-accent/50 transition-colors"
                >
                  {/* Date indicator */}
                  <div className="flex flex-col items-center justify-center min-w-[60px] py-1 px-2 rounded bg-muted">
                    <span className="text-xs text-muted-foreground">{date}</span>
                    <span className="text-xs font-medium">{time}</span>
                  </div>

                  {/* Entry details */}
                  <div className="flex-1 min-w-0">
                    <div className="flex items-center justify-between gap-2">
                      <span className="text-xs text-muted-foreground">{relative}</span>
                    </div>
                    <p className="text-sm mt-1 line-clamp-2">{entry.reason}</p>
                  </div>
                </div>
              );
            })}

            {/* Show more indicator if truncated */}
            {maxEntries && entries.length > maxEntries && (
              <p className="text-xs text-center text-muted-foreground pt-2">
                +{entries.length - maxEntries} more entries
              </p>
            )}
          </div>
        )}
      </CardContent>
    </Card>
  );
}

export default PassHistoryList;
```

---

## 4. DumbpipeCard Component

File: `/Users/jeffrey/code/tether/web-ui/src/components/dashboard/DumbpipeCard.tsx`

```tsx
"use client";

import { useState } from "react";
import { useQuery } from "@tanstack/react-query";
import { Copy, Check, Link2, AlertCircle, ExternalLink } from "lucide-react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Skeleton } from "@/components/ui/skeleton";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { cn } from "@/lib/utils";
import { getDumbpipeTicket } from "@/client/services.gen";
import type { DumbpipeTicketResponse } from "@/client/types.gen";

interface DumbpipeCardProps {
  className?: string;
}

// Duration to show "Copied!" feedback (in milliseconds)
const COPY_FEEDBACK_DURATION = 2000;

/**
 * DumbpipeCard displays the dumbpipe ticket for remote access.
 * 
 * Features:
 * - Displays the full ticket string in a monospace format
 * - Copy to clipboard button with visual feedback
 * - Truncated display with expand option for long tickets
 * - Explanation text about what the ticket is for
 * - Links to iroh/dumbpipe documentation
 */
export function DumbpipeCard({ className }: DumbpipeCardProps) {
  const [isCopied, setIsCopied] = useState(false);
  const [isExpanded, setIsExpanded] = useState(false);

  const {
    data: ticketResponse,
    isLoading,
    isError,
    error,
    refetch,
  } = useQuery<DumbpipeTicketResponse>({
    queryKey: ["dumbpipe", "ticket"],
    queryFn: async () => {
      const response = await getDumbpipeTicket();
      if (response.error) {
        throw new Error(response.error.message || "Failed to fetch dumbpipe ticket");
      }
      return response.data;
    },
    staleTime: 300000, // Consider stale after 5 minutes (ticket doesn't change often)
    retry: 2,
  });

  // Copy ticket to clipboard
  const handleCopy = async () => {
    if (!ticketResponse?.ticket) return;

    try {
      await navigator.clipboard.writeText(ticketResponse.ticket);
      setIsCopied(true);
      setTimeout(() => setIsCopied(false), COPY_FEEDBACK_DURATION);
    } catch (err) {
      console.error("Failed to copy to clipboard:", err);
      // Fallback: select the text for manual copying
      const textArea = document.createElement("textarea");
      textArea.value = ticketResponse.ticket;
      document.body.appendChild(textArea);
      textArea.select();
      document.execCommand("copy");
      document.body.removeChild(textArea);
      setIsCopied(true);
      setTimeout(() => setIsCopied(false), COPY_FEEDBACK_DURATION);
    }
  };

  // Truncate long tickets for display
  const truncateTicket = (ticket: string, maxLength: number = 80): string => {
    if (ticket.length <= maxLength) return ticket;
    const halfLength = Math.floor((maxLength - 3) / 2);
    return `${ticket.slice(0, halfLength)}...${ticket.slice(-halfLength)}`;
  };

  // Loading skeleton
  if (isLoading) {
    return (
      <Card className={cn("relative", className)}>
        <CardHeader className="pb-2">
          <div className="flex items-center gap-2">
            <Skeleton className="h-5 w-5 rounded" />
            <Skeleton className="h-6 w-36" />
          </div>
          <Skeleton className="h-4 w-48 mt-1" />
        </CardHeader>
        <CardContent className="space-y-4">
          <Skeleton className="h-20 w-full rounded-md" />
          <Skeleton className="h-10 w-full rounded-md" />
          <Skeleton className="h-4 w-full" />
          <Skeleton className="h-4 w-3/4" />
        </CardContent>
      </Card>
    );
  }

  // Error state
  if (isError) {
    return (
      <Card className={cn("relative", className)}>
        <CardHeader className="pb-2">
          <CardTitle className="flex items-center gap-2 text-lg">
            <Link2 className="h-5 w-5" />
            Remote Access
          </CardTitle>
          <CardDescription>Dumbpipe connection ticket</CardDescription>
        </CardHeader>
        <CardContent>
          <Alert variant="destructive">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>
              {error instanceof Error ? error.message : "Failed to load ticket"}
            </AlertDescription>
          </Alert>
          <Button variant="outline" onClick={() => refetch()} className="w-full mt-4">
            Retry
          </Button>
        </CardContent>
      </Card>
    );
  }

  const ticket = ticketResponse?.ticket ?? "";
  const isLongTicket = ticket.length > 80;
  const displayTicket = isExpanded ? ticket : truncateTicket(ticket);

  return (
    <Card className={cn("relative", className)}>
      <CardHeader className="pb-2">
        <CardTitle className="flex items-center gap-2 text-lg">
          <Link2 className="h-5 w-5" />
          Remote Access
        </CardTitle>
        <CardDescription>Dumbpipe connection ticket for MCP server</CardDescription>
      </CardHeader>

      <CardContent className="space-y-4">
        {/* Ticket display */}
        <div className="relative">
          <div
            className={cn(
              "p-3 rounded-md bg-muted font-mono text-xs break-all",
              "min-h-[60px] max-h-[200px] overflow-y-auto"
            )}
          >
            {displayTicket || <span className="text-muted-foreground italic">No ticket available</span>}
          </div>

          {/* Expand/collapse for long tickets */}
          {isLongTicket && (
            <Button
              variant="ghost"
              size="sm"
              className="absolute bottom-1 right-1 h-6 text-xs"
              onClick={() => setIsExpanded(!isExpanded)}
            >
              {isExpanded ? "Show less" : "Show full"}
            </Button>
          )}
        </div>

        {/* Copy button */}
        <Button
          variant="outline"
          className="w-full gap-2"
          onClick={handleCopy}
          disabled={!ticket}
        >
          {isCopied ? (
            <>
              <Check className="h-4 w-4 text-green-500" />
              Copied!
            </>
          ) : (
            <>
              <Copy className="h-4 w-4" />
              Copy Ticket
            </>
          )}
        </Button>

        {/* Explanation text */}
        <div className="text-xs text-muted-foreground space-y-2">
          <p>
            This ticket allows secure remote access to your Tether device using{" "}
            <a
              href="https://github.com/n0-computer/dumbpipe"
              target="_blank"
              rel="noopener noreferrer"
              className="inline-flex items-center gap-1 text-primary underline-offset-4 hover:underline"
            >
              dumbpipe
              <ExternalLink className="h-3 w-3" />
            </a>
            , a peer-to-peer connection tool powered by{" "}
            <a
              href="https://github.com/n0-computer/iroh"
              target="_blank"
              rel="noopener noreferrer"
              className="inline-flex items-center gap-1 text-primary underline-offset-4 hover:underline"
            >
              iroh
              <ExternalLink className="h-3 w-3" />
            </a>
            .
          </p>
          <p>
            Use this ticket with the MCP server to query your Tether device from
            anywhere. Set it as the <code className="px-1 py-0.5 rounded bg-muted font-mono">TETHER_TICKET</code> environment
            variable.
          </p>
        </div>
      </CardContent>
    </Card>
  );
}

export default DumbpipeCard;
```

---

## 5. UsePassDialog Component

File: `/Users/jeffrey/code/tether/web-ui/src/components/dashboard/UsePassDialog.tsx`

```tsx
"use client";

import { useState, useEffect } from "react";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { AlertTriangle, Loader2 } from "lucide-react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Label } from "@/components/ui/label";
import { cn } from "@/lib/utils";
import { usePass } from "@/client/services.gen";
import type { UsePassRequest, PassesInfo, PassHistoryResponse, PassHistoryEntry } from "@/client/types.gen";

interface UsePassDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  currentRemaining: number;
  totalForMonth: number;
}

// Minimum reason length required
const MIN_REASON_LENGTH = 10;
// Maximum reason length allowed
const MAX_REASON_LENGTH = 500;

/**
 * UsePassDialog is a modal dialog for using an emergency pass.
 * 
 * Features:
 * - Reason textarea (required, with character count)
 * - Validation for minimum/maximum length
 * - Confirm/cancel buttons
 * - Loading state during mutation
 * - Error display with retry capability
 * - Optimistic updates for immediate UI feedback
 * - Confirmation warning showing remaining passes
 */
export function UsePassDialog({
  open,
  onOpenChange,
  currentRemaining,
  totalForMonth,
}: UsePassDialogProps) {
  const [reason, setReason] = useState("");
  const [validationError, setValidationError] = useState<string | null>(null);

  const queryClient = useQueryClient();

  // Reset form when dialog opens/closes
  useEffect(() => {
    if (!open) {
      // Delay reset to allow close animation
      const timer = setTimeout(() => {
        setReason("");
        setValidationError(null);
      }, 200);
      return () => clearTimeout(timer);
    }
  }, [open]);

  // Mutation for using a pass
  const usePassMutation = useMutation({
    mutationFn: async (request: UsePassRequest) => {
      const response = await usePass({ body: request });
      if (response.error) {
        throw new Error(response.error.message || "Failed to use pass");
      }
      return response.data;
    },
    // Optimistic update
    onMutate: async (newPassRequest) => {
      // Cancel any outgoing refetches
      await queryClient.cancelQueries({ queryKey: ["passes"] });

      // Snapshot previous values
      const previousPasses = queryClient.getQueryData<PassesInfo>(["passes", "remaining"]);
      const previousHistory = queryClient.getQueryData<PassHistoryResponse>([
        "passes",
        "history",
      ]);

      // Optimistically update remaining passes
      if (previousPasses) {
        queryClient.setQueryData<PassesInfo>(["passes", "remaining"], {
          ...previousPasses,
          remaining: Math.max(0, previousPasses.remaining - 1),
        });
      }

      // Optimistically add to history
      const currentMonth = new Date().toISOString().slice(0, 7);
      const historyKey = ["passes", "history", currentMonth];
      const currentHistory = queryClient.getQueryData<PassHistoryResponse>(historyKey);
      
      if (currentHistory) {
        const newEntry: PassHistoryEntry = {
          used_at_utc: new Date().toISOString(),
          reason: newPassRequest.reason,
        };
        queryClient.setQueryData<PassHistoryResponse>(historyKey, {
          ...currentHistory,
          entries: [newEntry, ...currentHistory.entries],
        });
      }

      return { previousPasses, previousHistory, historyKey };
    },
    // Rollback on error
    onError: (err, newPassRequest, context) => {
      if (context?.previousPasses) {
        queryClient.setQueryData(["passes", "remaining"], context.previousPasses);
      }
      if (context?.previousHistory && context?.historyKey) {
        queryClient.setQueryData(context.historyKey, context.previousHistory);
      }
    },
    // Refetch after success or error
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ["passes"] });
    },
    // Close dialog on success
    onSuccess: () => {
      onOpenChange(false);
    },
  });

  // Validate reason
  const validateReason = (value: string): string | null => {
    const trimmed = value.trim();
    if (trimmed.length === 0) {
      return "Please provide a reason for using this pass";
    }
    if (trimmed.length < MIN_REASON_LENGTH) {
      return `Reason must be at least ${MIN_REASON_LENGTH} characters`;
    }
    if (trimmed.length > MAX_REASON_LENGTH) {
      return `Reason cannot exceed ${MAX_REASON_LENGTH} characters`;
    }
    return null;
  };

  // Handle form submission
  const handleSubmit = () => {
    const error = validateReason(reason);
    if (error) {
      setValidationError(error);
      return;
    }

    setValidationError(null);
    usePassMutation.mutate({ reason: reason.trim() });
  };

  // Handle reason change
  const handleReasonChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const value = e.target.value;
    setReason(value);
    // Clear validation error when user starts typing
    if (validationError) {
      setValidationError(null);
    }
  };

  const isSubmitting = usePassMutation.isPending;
  const mutationError = usePassMutation.error;
  const remainingAfterUse = currentRemaining - 1;
  const isLastPass = currentRemaining === 1;
  const characterCount = reason.trim().length;

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Use Emergency Pass</DialogTitle>
          <DialogDescription>
            You have {currentRemaining} {currentRemaining === 1 ? "pass" : "passes"}{" "}
            remaining this month.
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4 py-4">
          {/* Warning for last pass */}
          {isLastPass && (
            <Alert variant="destructive" className="border-yellow-500 bg-yellow-50 dark:bg-yellow-900/20">
              <AlertTriangle className="h-4 w-4 text-yellow-600" />
              <AlertDescription className="text-yellow-700 dark:text-yellow-400">
                This is your last pass for the month! Use it wisely.
              </AlertDescription>
            </Alert>
          )}

          {/* Reason textarea */}
          <div className="space-y-2">
            <Label htmlFor="reason" className="text-sm font-medium">
              Reason <span className="text-destructive">*</span>
            </Label>
            <Textarea
              id="reason"
              placeholder="Why do you need to use an emergency pass? (e.g., early morning flight, medical emergency...)"
              value={reason}
              onChange={handleReasonChange}
              disabled={isSubmitting}
              className={cn(
                "min-h-[100px] resize-none",
                validationError && "border-destructive focus-visible:ring-destructive"
              )}
              maxLength={MAX_REASON_LENGTH}
            />
            <div className="flex justify-between text-xs">
              {validationError ? (
                <span className="text-destructive">{validationError}</span>
              ) : (
                <span className="text-muted-foreground">
                  Minimum {MIN_REASON_LENGTH} characters required
                </span>
              )}
              <span
                className={cn(
                  "text-muted-foreground tabular-nums",
                  characterCount > MAX_REASON_LENGTH * 0.9 && "text-yellow-600",
                  characterCount >= MAX_REASON_LENGTH && "text-destructive"
                )}
              >
                {characterCount}/{MAX_REASON_LENGTH}
              </span>
            </div>
          </div>

          {/* Mutation error display */}
          {mutationError && (
            <Alert variant="destructive">
              <AlertDescription>
                {mutationError instanceof Error
                  ? mutationError.message
                  : "Failed to use pass. Please try again."}
              </AlertDescription>
            </Alert>
          )}

          {/* Confirmation text */}
          <p className="text-sm text-muted-foreground">
            After using this pass, you will have{" "}
            <span className="font-semibold text-foreground">
              {remainingAfterUse} {remainingAfterUse === 1 ? "pass" : "passes"}
            </span>{" "}
            remaining for the month.
          </p>
        </div>

        <DialogFooter className="gap-2 sm:gap-0">
          <Button
            type="button"
            variant="outline"
            onClick={() => onOpenChange(false)}
            disabled={isSubmitting}
          >
            Cancel
          </Button>
          <Button
            type="button"
            onClick={handleSubmit}
            disabled={isSubmitting || reason.trim().length < MIN_REASON_LENGTH}
            className="gap-2"
          >
            {isSubmitting ? (
              <>
                <Loader2 className="h-4 w-4 animate-spin" />
                Using Pass...
              </>
            ) : (
              "Confirm Use Pass"
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

export default UsePassDialog;
```

---

## 6. Dashboard Page Assembly

File: `/Users/jeffrey/code/tether/web-ui/src/pages/Dashboard.tsx`

```tsx
"use client";

import { ProximityCard } from "@/components/dashboard/ProximityCard";
import { PassesCard } from "@/components/dashboard/PassesCard";
import { PassHistoryList } from "@/components/dashboard/PassHistoryList";
import { DumbpipeCard } from "@/components/dashboard/DumbpipeCard";

/**
 * Dashboard page displaying all core Tether status information.
 * 
 * Layout:
 * - Mobile: Single column, stacked cards
 * - Desktop: 2-column grid with responsive sizing
 * 
 * Components:
 * - ProximityCard: Real-time device proximity status
 * - PassesCard: Remaining passes with use pass functionality
 * - PassHistoryList: History of used passes
 * - DumbpipeCard: Remote access ticket
 */
export function Dashboard() {
  return (
    <div className="container mx-auto px-4 py-6 max-w-4xl">
      <header className="mb-6">
        <h1 className="text-2xl font-bold tracking-tight">Tether Dashboard</h1>
        <p className="text-muted-foreground">
          Monitor your device and manage emergency passes
        </p>
      </header>

      <div className="grid gap-4 md:grid-cols-2">
        {/* Proximity status - full width on mobile, half on desktop */}
        <ProximityCard className="md:col-span-1" />

        {/* Passes card - full width on mobile, half on desktop */}
        <PassesCard className="md:col-span-1" />

        {/* Pass history - full width */}
        <PassHistoryList className="md:col-span-2" maxEntries={5} />

        {/* Dumbpipe ticket - full width */}
        <DumbpipeCard className="md:col-span-2" />
      </div>
    </div>
  );
}

export default Dashboard;
```

---

## 7. API Client Types (Expected from openapi-ts)

File: `/Users/jeffrey/code/tether/web-ui/src/client/types.gen.ts` (Generated - example structure)

```tsx
/**
 * These types would be auto-generated by @hey-api/openapi-ts from the 
 * Rust backend's OpenAPI specification. This serves as a reference for 
 * what the components expect.
 */

/** Response from GET /proximity/status */
export interface ProximityStatus {
  /** Whether the device is considered nearby based on RSSI threshold */
  is_nearby: boolean;
  /** The configured Bluetooth device name */
  device_name: string;
  /** Current RSSI value in dBm (null if device not detected) */
  rssi: number | null;
  /** The configured RSSI threshold for "nearby" */
  threshold: number;
}

/** Response from GET /passes/remaining */
export interface PassesInfo {
  /** Number of passes remaining for the current month */
  remaining: number;
  /** Total passes allowed per month */
  total_for_month: number;
  /** The month this data applies to (YYYY-MM format) */
  month: string;
}

/** A single pass history entry */
export interface PassHistoryEntry {
  /** UTC timestamp when the pass was used (ISO 8601 format) */
  used_at_utc: string;
  /** The reason provided when using the pass */
  reason: string;
}

/** Response from GET /passes/history */
export interface PassHistoryResponse {
  /** The month this history applies to (YYYY-MM format) */
  month: string;
  /** List of pass usage entries, ordered by date descending */
  entries: PassHistoryEntry[];
}

/** Request body for POST /passes/use */
export interface UsePassRequest {
  /** Reason for using the emergency pass */
  reason: string;
}

/** Response from POST /passes/use */
export interface UsePassResponse {
  /** Whether the pass was successfully used */
  success: boolean;
  /** Number of passes remaining after this use */
  remaining: number;
  /** The recorded history entry */
  entry: PassHistoryEntry;
}

/** Response from GET /dumbpipe/ticket */
export interface DumbpipeTicketResponse {
  /** The dumbpipe connection ticket string */
  ticket: string;
  /** When the ticket was generated (ISO 8601 format) */
  generated_at_utc: string;
}

/** Generic API error response */
export interface ApiError {
  /** Error message */
  message: string;
  /** Error code for programmatic handling */
  code?: string;
}
```

---

## 8. API Client Services (Expected from openapi-ts)

File: `/Users/jeffrey/code/tether/web-ui/src/client/services.gen.ts` (Generated - example structure)

```tsx
/**
 * These service functions would be auto-generated by @hey-api/openapi-ts.
 * This serves as a reference for what the components expect.
 */

import { client } from "./client";
import type {
  ProximityStatus,
  PassesInfo,
  PassHistoryResponse,
  UsePassRequest,
  UsePassResponse,
  DumbpipeTicketResponse,
  ApiError,
} from "./types.gen";

interface ApiResponse<T> {
  data: T;
  error?: ApiError;
}

/** GET /proximity/status - Get current proximity status */
export async function getProximityStatus(): Promise<ApiResponse<ProximityStatus>> {
  return client.get("/proximity/status");
}

/** GET /passes/remaining - Get remaining passes for current month */
export async function getPassesRemaining(): Promise<ApiResponse<PassesInfo>> {
  return client.get("/passes/remaining");
}

/** GET /passes/history - Get pass history for a specific month */
export async function getPassHistory(options?: {
  month?: string;
}): Promise<ApiResponse<PassHistoryResponse>> {
  const params = options?.month ? { month: options.month } : {};
  return client.get("/passes/history", { params });
}

/** POST /passes/use - Use an emergency pass */
export async function usePass(options: {
  body: UsePassRequest;
}): Promise<ApiResponse<UsePassResponse>> {
  return client.post("/passes/use", { body: options.body });
}

/** GET /dumbpipe/ticket - Get the dumbpipe connection ticket */
export async function getDumbpipeTicket(): Promise<ApiResponse<DumbpipeTicketResponse>> {
  return client.get("/dumbpipe/ticket");
}
```

---

## 9. Client Configuration

File: `/Users/jeffrey/code/tether/web-ui/src/client/client.ts`

```tsx
import { createClient } from "@hey-api/client-fetch";

/**
 * Configure the API client.
 * 
 * In development, the Vite dev server proxies /api requests to the backend.
 * In production (on the Raspberry Pi), the web UI and API are served from 
 * the same origin.
 */
export const client = createClient({
  baseUrl: import.meta.env.VITE_API_BASE_URL || "",
  headers: {
    "Content-Type": "application/json",
  },
});

// Re-export for convenience
export { client as apiClient };
```

---

## 10. Utility Functions

File: `/Users/jeffrey/code/tether/web-ui/src/lib/utils.ts`

```tsx
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

/**
 * Utility function for merging Tailwind CSS classes safely.
 * Combines clsx for conditional classes with tailwind-merge for 
 * proper Tailwind class conflict resolution.
 */
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
```

---

## 11. Vite Configuration for API Proxy (Development)

File: `/Users/jeffrey/code/tether/web-ui/vite.config.ts`

```tsx
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
  server: {
    port: 3000,
    proxy: {
      // Proxy API requests to the Rust backend during development
      "/api": {
        target: "http://localhost:8080",
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, ""),
      },
    },
  },
});
```

---

## 12. openapi-ts Configuration

File: `/Users/jeffrey/code/tether/web-ui/openapi-ts.config.ts`

```tsx
import { defineConfig } from "@hey-api/openapi-ts";

export default defineConfig({
  client: "@hey-api/client-fetch",
  input: "../openapi.json", // Path to the OpenAPI spec generated by the Rust backend
  output: {
    path: "src/client",
    format: "prettier",
  },
  plugins: [
    "@hey-api/typescript",
    {
      name: "@hey-api/sdk",
      asClass: false, // Use functions instead of classes
    },
  ],
});
```

---

## Package.json Scripts

Add these scripts to `/Users/jeffrey/code/tether/web-ui/package.json`:

```json
{
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "generate-client": "openapi-ts",
    "lint": "biome check --write src",
    "format": "biome format --write src"
  }
}
```

---

## Component Index File

File: `/Users/jeffrey/code/tether/web-ui/src/components/dashboard/index.ts`

```tsx
export { ProximityCard } from "./ProximityCard";
export { PassesCard } from "./PassesCard";
export { PassHistoryList } from "./PassHistoryList";
export { DumbpipeCard } from "./DumbpipeCard";
export { UsePassDialog } from "./UsePassDialog";
```

---

## Required Dependencies

These are the npm packages required for the dashboard components:

```json
{
  "dependencies": {
    "@hey-api/client-fetch": "^0.4.0",
    "@radix-ui/react-dialog": "^1.1.0",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-progress": "^1.1.0",
    "@radix-ui/react-slot": "^1.1.0",
    "@tanstack/react-query": "^5.60.0",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.0",
    "lucide-react": "^0.460.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "tailwind-merge": "^2.5.0",
    "tailwindcss-animate": "^1.0.7"
  },
  "devDependencies": {
    "@biomejs/biome": "^1.9.0",
    "@hey-api/openapi-ts": "^0.54.0",
    "@types/react": "^18.3.0",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.0",
    "autoprefixer": "^10.4.20",
    "postcss": "^8.4.49",
    "tailwindcss": "^3.4.0",
    "typescript": "^5.6.0",
    "vite": "^5.4.0"
  }
}
```

---

## Summary of Key Implementation Details

### Polling Configuration
- **ProximityCard**: Polls every 2000ms with `refetchInterval`
- Stops polling when tab is not focused (`refetchIntervalInBackground: false`)
- Shows subtle pulse indicator during refetch

### Optimistic Updates
- **UsePassDialog**: Implements full optimistic update pattern
- Snapshots previous state in `onMutate`
- Rollback on error in `onError`
- Invalidates queries in `onSettled`

### Error Handling
- All components have dedicated error states
- Retry buttons that call `refetch()`
- Error messages extracted from API responses

### Loading States
- All components use Skeleton components matching their layout
- Smooth transitions between states

### Accessibility
- Proper ARIA labels and descriptions
- Focus management in dialogs
- Keyboard navigation support (via Radix primitives)

---

### Critical Files for Implementation

- `/Users/jeffrey/code/tether/web-ui/src/components/dashboard/ProximityCard.tsx` - Core proximity status display with real-time polling
- `/Users/jeffrey/code/tether/web-ui/src/components/dashboard/UsePassDialog.tsx` - Critical mutation handling with optimistic updates
- `/Users/jeffrey/code/tether/web-ui/src/client/types.gen.ts` - Type definitions that must match Rust backend OpenAPI spec
- `/Users/jeffrey/code/tether/web-ui/src/providers/QueryProvider.tsx` - TanStack Query configuration for all data fetching
- `/Users/jeffrey/code/tether/claude-spec.md` - Project specification defining API contracts and requirements
