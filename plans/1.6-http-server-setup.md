Now I have all the information I need to create the detailed implementation plan. Let me compile this into excruciating implementation details for both files.

---

# Excruciating Implementation Details for `tether-server`

## Overview

This document provides complete, copy-paste ready code for `tether-server/src/main.rs` and `tether-server/src/state.rs`. These files form the core of the Axum HTTP server for the tether project.

---

## File 1: `/Users/jeffrey/code/tether/tether-server/src/state.rs`

This file defines the application state that will be shared across all request handlers.

```rust
//! Application state management for the tether server.
//!
//! This module provides the [`AppState`] struct which holds all shared state
//! including configuration, pass management, and Bluetooth connectivity.
//! State is wrapped in [`SharedState`] (Arc<RwLock<AppState>>) for safe
//! concurrent access across async request handlers.

use std::sync::Arc;
use tokio::sync::RwLock;

use crate::config::Config;
use tether_core::bluetooth::BluetoothManager;
use tether_core::pass_manager::PassManager;

/// Type alias for thread-safe shared application state.
///
/// Uses `Arc` for reference counting across async tasks and `RwLock` for
/// interior mutability with read-write semantics. Prefer `read()` when
/// only reading state to allow concurrent readers.
pub type SharedState = Arc<RwLock<AppState>>;

/// Core application state shared across all HTTP handlers.
///
/// # Fields
///
/// - `config`: Server and application configuration loaded from disk
/// - `pass_manager`: Manages monthly passes, history, and persistence
/// - `bluetooth`: Handles Bluetooth device proximity detection
///
/// # Thread Safety
///
/// All fields are designed to be accessed through the `SharedState` wrapper.
/// The `PassManager` handles its own persistence, so writes to state should
/// be followed by explicit persistence calls where needed.
#[derive(Debug)]
pub struct AppState {
    /// Application configuration loaded from TETHER_CONFIG_PATH.
    /// Contains bluetooth target, wifi networks, timezone, pass limits, etc.
    pub config: Config,

    /// Manages pass allocation, usage, and history.
    /// Handles monthly refresh logic and persistence to disk.
    pub pass_manager: PassManager,

    /// Bluetooth manager for proximity detection.
    /// Lazily checks device proximity on each request.
    pub bluetooth: BluetoothManager,
}

impl AppState {
    /// Creates a new `AppState` instance from the provided components.
    ///
    /// # Arguments
    ///
    /// * `config` - Loaded configuration from disk
    /// * `pass_manager` - Initialized pass manager with loaded history
    /// * `bluetooth` - Configured Bluetooth manager
    ///
    /// # Example
    ///
    /// ```ignore
    /// let state = AppState::new(config, pass_manager, bluetooth);
    /// let shared = AppState::into_shared(state);
    /// ```
    pub fn new(config: Config, pass_manager: PassManager, bluetooth: BluetoothManager) -> Self {
        Self {
            config,
            pass_manager,
            bluetooth,
        }
    }

    /// Wraps the `AppState` in an `Arc<RwLock<_>>` for shared access.
    ///
    /// This is the preferred way to create state for use with Axum handlers.
    pub fn into_shared(self) -> SharedState {
        Arc::new(RwLock::new(self))
    }

    /// Convenience method to create shared state directly.
    ///
    /// Equivalent to `AppState::new(...).into_shared()`.
    pub fn new_shared(
        config: Config,
        pass_manager: PassManager,
        bluetooth: BluetoothManager,
    ) -> SharedState {
        Arc::new(RwLock::new(Self::new(config, pass_manager, bluetooth)))
    }
}

/// Extension trait for SharedState to provide ergonomic access patterns.
///
/// These methods reduce boilerplate when accessing state in handlers.
pub trait SharedStateExt {
    /// Acquires a read lock and returns a clone of the config.
    ///
    /// Use this when you need the config but don't need to hold the lock.
    async fn get_config(&self) -> Config;

    /// Checks if the application has completed initial setup.
    ///
    /// Returns `true` if a Bluetooth device and at least one WiFi network
    /// are configured.
    async fn is_configured(&self) -> bool;
}

impl SharedStateExt for SharedState {
    async fn get_config(&self) -> Config {
        self.read().await.config.clone()
    }

    async fn is_configured(&self) -> bool {
        let state = self.read().await;
        state.config.bluetooth.target_device.is_some()
            && !state.config.wifi.networks.is_empty()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_shared_state_creation() {
        // Test would require mock implementations of Config, PassManager, etc.
        // Left as placeholder for actual test implementation.
    }
}
```

### Key Design Decisions for `state.rs`:

1. **`RwLock` over `Mutex`**: Uses `tokio::sync::RwLock` to allow multiple concurrent readers. Most handlers only read state (checking passes, config, proximity), so this improves throughput.

2. **`Arc` for reference counting**: Required for sharing state across async tasks spawned by Axum.

3. **Extension trait pattern**: `SharedStateExt` provides convenience methods that encapsulate common read patterns, reducing boilerplate in handlers.

4. **Explicit types for tether-core**: The `PassManager` and `BluetoothManager` come from the `tether-core` crate where business logic lives.

5. **Clone for Config**: Config implements `Clone` so handlers can clone it out of the lock for processing without holding the lock.

---

## File 2: `/Users/jeffrey/code/tether/tether-server/src/main.rs`

```rust
//! Tether HTTP Server
//!
//! This is the main entry point for the tether server, which provides:
//! - REST API at `/api/*` for device management and pass tracking
//! - OpenAPI specification at `/api/openapi.json`
//! - Health check at `/health`
//! - Static file serving for the web UI with SPA fallback
//!
//! # Environment Variables
//!
//! - `TETHER_CONFIG_PATH`: Path to config file (default: `/etc/tether/config.toml`)
//! - `TETHER_ENV`: `production` or `development` (default: `production`)
//! - `TETHER_LOG_LEVEL`: Log level filter (default: `info`)
//! - `TETHER_HOST`: Bind address (default: `0.0.0.0`)
//! - `TETHER_PORT`: Bind port (default: `8080`)

use std::env;
use std::net::SocketAddr;
use std::path::PathBuf;
use std::time::Duration;

use axum::{
    http::{header, Method, StatusCode},
    response::IntoResponse,
    routing::get,
    Json, Router,
};
use tokio::net::TcpListener;
use tokio::signal;
use tower::ServiceBuilder;
use tower_http::{
    cors::{Any, CorsLayer},
    services::{ServeDir, ServeFile},
    trace::{DefaultMakeSpan, DefaultOnRequest, DefaultOnResponse, TraceLayer},
};
use tracing::{info, warn, Level};
use tracing_appender::rolling::{RollingFileAppender, Rotation};
use tracing_subscriber::{
    fmt::{self, format::FmtSpan},
    layer::SubscriberExt,
    util::SubscriberInitExt,
    EnvFilter,
};
use utoipa::OpenApi;

mod api;
mod config;
mod error;
mod state;

use config::Config;
use state::{AppState, SharedState};
use tether_core::bluetooth::BluetoothManager;
use tether_core::pass_manager::PassManager;

// ============================================================================
// OpenAPI Documentation
// ============================================================================

/// OpenAPI documentation for the tether API.
///
/// This struct aggregates all API paths and schemas for OpenAPI generation.
/// The generated spec is served at `/api/openapi.json`.
#[derive(OpenApi)]
#[openapi(
    info(
        title = "Tether API",
        version = "1.0.0",
        description = "API for managing phone proximity tracking and emergency passes. \
                       This API is consumed by the tether MCP server to provide AI agents \
                       with the ability to check phone proximity and manage passes.",
        license(name = "MIT"),
    ),
    paths(
        api::health::health_check,
        api::proximity::get_proximity,
        api::passes::get_remaining_passes,
        api::passes::get_pass_history,
        api::passes::use_pass,
        api::config::get_config,
        api::config::update_bluetooth,
        api::config::update_wifi,
        api::config::update_timezone,
        api::config::update_passes_per_month,
        api::wifi::scan_networks,
        api::wifi::add_network,
        api::wifi::remove_network,
        api::wifi::set_primary_network,
        api::bluetooth::scan_devices,
        api::system::restart,
        api::system::get_dumbpipe_ticket,
    ),
    components(schemas(
        api::proximity::ProximityResponse,
        api::passes::PassesRemainingResponse,
        api::passes::PassHistoryResponse,
        api::passes::PassHistoryEntry,
        api::passes::UsePassRequest,
        api::passes::UsePassResponse,
        api::config::ConfigResponse,
        api::config::UpdateBluetoothRequest,
        api::config::UpdateWifiRequest,
        api::config::UpdateTimezoneRequest,
        api::config::UpdatePassesPerMonthRequest,
        api::wifi::WifiNetwork,
        api::wifi::WifiScanResponse,
        api::wifi::AddNetworkRequest,
        api::bluetooth::BluetoothDevice,
        api::bluetooth::BluetoothScanResponse,
        api::system::DumbpipeTicketResponse,
        api::error::ApiError,
    )),
    tags(
        (name = "proximity", description = "Phone proximity detection"),
        (name = "passes", description = "Emergency pass management"),
        (name = "config", description = "Configuration management"),
        (name = "wifi", description = "WiFi network management"),
        (name = "bluetooth", description = "Bluetooth device management"),
        (name = "system", description = "System operations"),
    )
)]
pub struct ApiDoc;

// ============================================================================
// Main Entry Point
// ============================================================================

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Step 1: Determine environment (production vs development)
    let is_production = env::var("TETHER_ENV")
        .map(|v| v.to_lowercase() != "development")
        .unwrap_or(true);

    // Step 2: Initialize logging/tracing
    init_tracing(is_production)?;

    info!(
        env = if is_production { "production" } else { "development" },
        "Starting tether server"
    );

    // Step 3: Load configuration
    let config_path = env::var("TETHER_CONFIG_PATH")
        .map(PathBuf::from)
        .unwrap_or_else(|_| {
            if is_production {
                PathBuf::from("/etc/tether/config.toml")
            } else {
                PathBuf::from("./config.toml")
            }
        });

    info!(path = %config_path.display(), "Loading configuration");
    let config = Config::load(&config_path).await?;

    // Step 4: Initialize components
    let pass_data_path = if is_production {
        PathBuf::from("/var/lib/tether/passes.json")
    } else {
        PathBuf::from("./data/passes.json")
    };

    let pass_manager = PassManager::load_or_create(&pass_data_path, config.passes.per_month).await?;
    let bluetooth = BluetoothManager::new(config.bluetooth.clone()).await?;

    // Step 5: Create shared state
    let state = AppState::new_shared(config.clone(), pass_manager, bluetooth);

    // Step 6: Build the router
    let app = build_router(state.clone(), is_production);

    // Step 7: Determine bind address
    let host = env::var("TETHER_HOST").unwrap_or_else(|_| "0.0.0.0".to_string());
    let port: u16 = env::var("TETHER_PORT")
        .ok()
        .and_then(|p| p.parse().ok())
        .unwrap_or(8080);
    let addr: SocketAddr = format!("{}:{}", host, port).parse()?;

    info!(%addr, "Server listening");

    // Step 8: Start server with graceful shutdown
    let listener = TcpListener::bind(addr).await?;

    axum::serve(listener, app)
        .with_graceful_shutdown(shutdown_signal())
        .await?;

    info!("Server shutdown complete");
    Ok(())
}

// ============================================================================
// Tracing/Logging Initialization
// ============================================================================

/// Initialize the tracing subscriber with appropriate configuration.
///
/// # Production Mode
/// - Logs to rolling daily files in `/var/log/tether/`
/// - Also logs to stdout for systemd journal capture
/// - JSON format for structured logging
///
/// # Development Mode
/// - Logs to stdout only with pretty formatting
/// - Includes span events for debugging
fn init_tracing(is_production: bool) -> anyhow::Result<()> {
    let log_level = env::var("TETHER_LOG_LEVEL").unwrap_or_else(|_| "info".to_string());

    let env_filter = EnvFilter::try_from_default_env()
        .or_else(|_| EnvFilter::try_new(&log_level))?;

    if is_production {
        // Production: file + stdout logging
        let log_dir = PathBuf::from("/var/log/tether");

        // Ensure log directory exists (will fail gracefully if not writable)
        if !log_dir.exists() {
            std::fs::create_dir_all(&log_dir).ok();
        }

        // Rolling file appender - creates new file daily
        // Files named: tether.YYYY-MM-DD
        let file_appender = RollingFileAppender::new(Rotation::DAILY, &log_dir, "tether");

        // Non-blocking writer for file output
        let (non_blocking_file, _guard) = tracing_appender::non_blocking(file_appender);

        // Store guard in a static to prevent it from being dropped
        // This is safe because we only call init_tracing once
        static FILE_GUARD: std::sync::OnceLock<tracing_appender::non_blocking::WorkerGuard> =
            std::sync::OnceLock::new();

        // Non-blocking writer for stdout
        let (non_blocking_stdout, stdout_guard) = tracing_appender::non_blocking(std::io::stdout());

        static STDOUT_GUARD: std::sync::OnceLock<tracing_appender::non_blocking::WorkerGuard> =
            std::sync::OnceLock::new();

        // File layer - JSON format for structured logging
        let file_layer = fmt::layer()
            .json()
            .with_writer(non_blocking_file)
            .with_target(true)
            .with_thread_ids(true)
            .with_file(true)
            .with_line_number(true);

        // Stdout layer - compact format for journald
        let stdout_layer = fmt::layer()
            .compact()
            .with_writer(non_blocking_stdout)
            .with_target(true)
            .with_ansi(false); // No ANSI colors for journald

        tracing_subscriber::registry()
            .with(env_filter)
            .with(file_layer)
            .with(stdout_layer)
            .init();

        // Store guards to prevent dropping
        let _ = FILE_GUARD.set(_guard);
        let _ = STDOUT_GUARD.set(stdout_guard);
    } else {
        // Development: pretty stdout logging only
        let stdout_layer = fmt::layer()
            .pretty()
            .with_target(true)
            .with_thread_ids(false)
            .with_file(true)
            .with_line_number(true)
            .with_span_events(FmtSpan::NEW | FmtSpan::CLOSE);

        tracing_subscriber::registry()
            .with(env_filter)
            .with(stdout_layer)
            .init();
    }

    Ok(())
}

// ============================================================================
// Router Construction
// ============================================================================

/// Builds the complete application router with all routes and middleware.
///
/// # Middleware Order (bottom to top execution)
///
/// 1. **TraceLayer** (outermost): Logs all requests/responses
/// 2. **CorsLayer** (dev only): Handles CORS preflight and headers
/// 3. Route-specific handlers
///
/// # Route Structure
///
/// ```text
/// /
/// ├── /health              - Health check endpoint
/// ├── /api
/// │   ├── /openapi.json    - OpenAPI specification
/// │   ├── /proximity       - Bluetooth proximity check
/// │   ├── /passes          - Pass management
/// │   │   ├── /remaining   - GET remaining passes
/// │   │   ├── /history     - GET pass history
/// │   │   └── /use         - POST use a pass
/// │   ├── /config          - Configuration endpoints
/// │   ├── /wifi            - WiFi management
/// │   ├── /bluetooth       - Bluetooth management
/// │   └── /system          - System operations
/// └── /*                   - Static files (SPA fallback)
/// ```
fn build_router(state: SharedState, is_production: bool) -> Router {
    // API routes
    let api_routes = Router::new()
        // OpenAPI spec endpoint
        .route("/openapi.json", get(serve_openapi))
        // Proximity routes
        .route("/proximity", get(api::proximity::get_proximity))
        // Pass routes
        .route("/passes/remaining", get(api::passes::get_remaining_passes))
        .route("/passes/history", get(api::passes::get_pass_history))
        .route("/passes/use", axum::routing::post(api::passes::use_pass))
        // Config routes
        .route("/config", get(api::config::get_config))
        .route(
            "/config/bluetooth",
            axum::routing::put(api::config::update_bluetooth),
        )
        .route(
            "/config/wifi",
            axum::routing::put(api::config::update_wifi),
        )
        .route(
            "/config/timezone",
            axum::routing::put(api::config::update_timezone),
        )
        .route(
            "/config/passes-per-month",
            axum::routing::put(api::config::update_passes_per_month),
        )
        // WiFi routes
        .route("/wifi/scan", get(api::wifi::scan_networks))
        .route("/wifi/networks", axum::routing::post(api::wifi::add_network))
        .route(
            "/wifi/networks/:ssid",
            axum::routing::delete(api::wifi::remove_network),
        )
        .route(
            "/wifi/networks/:ssid/primary",
            axum::routing::put(api::wifi::set_primary_network),
        )
        // Bluetooth routes
        .route("/bluetooth/scan", get(api::bluetooth::scan_devices))
        // System routes
        .route("/system/restart", axum::routing::post(api::system::restart))
        .route(
            "/system/dumbpipe-ticket",
            get(api::system::get_dumbpipe_ticket),
        )
        .with_state(state.clone());

    // Static file serving for web UI
    let static_dir = if is_production {
        PathBuf::from("/var/www/tether")
    } else {
        PathBuf::from("./web/dist")
    };

    // SPA fallback: serve index.html for any unmatched routes
    // This allows client-side routing to work correctly
    let static_service = ServeDir::new(&static_dir)
        .not_found_service(ServeFile::new(static_dir.join("index.html")));

    // Build the main router
    let mut app = Router::new()
        // Health check at root level (not under /api)
        .route("/health", get(api::health::health_check))
        // API routes under /api prefix
        .nest("/api", api_routes)
        // Static files with SPA fallback (must be last for catch-all behavior)
        .fallback_service(static_service);

    // Apply middleware using ServiceBuilder (executes bottom-to-top)
    //
    // IMPORTANT: Order matters!
    // - TraceLayer should be outermost to capture all requests
    // - CorsLayer should be before route handling for preflight requests
    let middleware = ServiceBuilder::new()
        // TraceLayer: Log all HTTP requests and responses
        .layer(
            TraceLayer::new_for_http()
                .make_span_with(DefaultMakeSpan::new().level(Level::INFO))
                .on_request(DefaultOnRequest::new().level(Level::INFO))
                .on_response(DefaultOnResponse::new().level(Level::INFO)),
        );

    // Add CORS layer only in development mode
    if !is_production {
        info!("CORS enabled for development");

        let cors = CorsLayer::new()
            // Allow any origin in development (for Vite dev server)
            .allow_origin(Any)
            // Allow common HTTP methods
            .allow_methods([
                Method::GET,
                Method::POST,
                Method::PUT,
                Method::DELETE,
                Method::PATCH,
                Method::OPTIONS,
            ])
            // Allow common headers
            .allow_headers([
                header::CONTENT_TYPE,
                header::AUTHORIZATION,
                header::ACCEPT,
            ])
            // Allow credentials (cookies, auth headers)
            .allow_credentials(false) // Set to true if you need cookies
            // Cache preflight requests for 1 hour
            .max_age(Duration::from_secs(3600));

        app = app.layer(cors);
    }

    app.layer(middleware)
}

// ============================================================================
// OpenAPI Endpoint Handler
// ============================================================================

/// Serves the OpenAPI specification as JSON.
///
/// This endpoint returns the complete OpenAPI 3.0 specification for the
/// tether API. It is used by:
/// - The web UI for API client generation (openapi-ts)
/// - The MCP server for tool generation (rmcp-openapi)
/// - External documentation tools
#[utoipa::path(
    get,
    path = "/api/openapi.json",
    responses(
        (status = 200, description = "OpenAPI specification", content_type = "application/json")
    ),
    tag = "system"
)]
async fn serve_openapi() -> impl IntoResponse {
    let spec = ApiDoc::openapi();
    (
        StatusCode::OK,
        [(header::CONTENT_TYPE, "application/json")],
        Json(spec),
    )
}

// ============================================================================
// Graceful Shutdown
// ============================================================================

/// Creates a future that resolves when a shutdown signal is received.
///
/// Handles both Ctrl+C (SIGINT) and SIGTERM signals on Unix systems.
/// On Windows, only Ctrl+C is handled.
///
/// # Shutdown Behavior
///
/// When triggered:
/// 1. Server stops accepting new connections
/// 2. Existing requests are allowed to complete
/// 3. After completion (or timeout), the server exits
async fn shutdown_signal() {
    let ctrl_c = async {
        signal::ctrl_c()
            .await
            .expect("Failed to install Ctrl+C handler");
    };

    #[cfg(unix)]
    let terminate = async {
        signal::unix::signal(signal::unix::SignalKind::terminate())
            .expect("Failed to install SIGTERM handler")
            .recv()
            .await;
    };

    #[cfg(not(unix))]
    let terminate = std::future::pending::<()>();

    tokio::select! {
        _ = ctrl_c => {
            info!("Received Ctrl+C, initiating graceful shutdown");
        }
        _ = terminate => {
            info!("Received SIGTERM, initiating graceful shutdown");
        }
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use axum::body::Body;
    use axum::http::Request;
    use tower::ServiceExt;

    #[tokio::test]
    async fn test_health_check() {
        // Create a minimal test state
        // In real tests, use test fixtures/mocks
    }

    #[tokio::test]
    async fn test_openapi_endpoint() {
        // Verify OpenAPI spec is valid JSON
        let spec = ApiDoc::openapi();
        let json = serde_json::to_string(&spec).expect("Failed to serialize OpenAPI spec");
        assert!(!json.is_empty());
    }
}
```

---

## Required `Cargo.toml` Dependencies

For reference, here are the dependencies needed in `tether-server/Cargo.toml`:

```toml
[package]
name = "tether-server"
version = "0.1.0"
edition = "2021"

[dependencies]
# Async runtime
tokio = { version = "1", features = ["full", "signal"] }

# Web framework
axum = { version = "0.7", features = ["macros"] }

# Tower middleware ecosystem
tower = { version = "0.4" }
tower-http = { version = "0.5", features = ["cors", "trace", "fs"] }

# Logging/Tracing
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter", "json"] }
tracing-appender = "0.2"

# OpenAPI generation
utoipa = { version = "4", features = ["axum_extras"] }
utoipa-swagger-ui = { version = "7", features = ["axum"] }

# Serialization
serde = { version = "1", features = ["derive"] }
serde_json = "1"

# Error handling
anyhow = "1"
thiserror = "1"

# Internal crates
tether-core = { path = "../tether-core" }
```

---

## Expected Directory Structure

```
tether-server/
├── Cargo.toml
└── src/
    ├── main.rs              # Entry point, router, graceful shutdown
    ├── state.rs             # AppState, SharedState definitions
    ├── config.rs            # Config loading/parsing
    ├── error.rs             # Error types and handlers
    └── api/
        ├── mod.rs           # API module re-exports
        ├── health.rs        # Health check handler
        ├── proximity.rs     # Bluetooth proximity handlers
        ├── passes.rs        # Pass management handlers
        ├── config.rs        # Configuration handlers
        ├── wifi.rs          # WiFi management handlers
        ├── bluetooth.rs     # Bluetooth scan handlers
        └── system.rs        # System operations handlers
```

---

## Middleware Order Diagram

```
Request →
    │
    ▼
┌─────────────────────────────┐
│       TraceLayer            │  ← Logs request/response (outermost)
│   (timing, status, path)    │
└─────────────────────────────┘
    │
    ▼
┌─────────────────────────────┐
│       CorsLayer             │  ← Handles preflight, adds headers (dev only)
│   (preflight, headers)      │
└─────────────────────────────┘
    │
    ▼
┌─────────────────────────────┐
│         Router              │  ← Route matching and handlers
│   /health, /api/*, static   │
└─────────────────────────────┘
    │
    ▼
Response ←
```

---

## Implementation Notes

### Static File Serving with SPA Fallback

The key pattern is:
```rust
ServeDir::new(&static_dir)
    .not_found_service(ServeFile::new(static_dir.join("index.html")))
```

This ensures:
1. Existing files (JS, CSS, images) are served directly
2. Unknown paths (SPA routes like `/settings`) fall back to `index.html`
3. The SPA's client-side router handles the actual route resolution

### Tracing Guard Persistence

The `WorkerGuard` returned by `tracing_appender::non_blocking` must be kept alive for the lifetime of the program. Dropping it stops log flushing. The code uses `OnceLock` to store guards in static variables:

```rust
static FILE_GUARD: std::sync::OnceLock<tracing_appender::non_blocking::WorkerGuard> =
    std::sync::OnceLock::new();
```

### CORS in Development Only

CORS is disabled in production because:
1. The web UI is served from the same origin (same port)
2. CORS is only needed when the Vite dev server runs on a different port

### Graceful Shutdown

The shutdown handler listens for:
- `SIGINT` (Ctrl+C) - manual termination
- `SIGTERM` - systemd stop signal

This allows in-flight requests to complete before exit.

---

## Sources

- [Serving a SPA and APIs - Axum Discussion #867](https://github.com/tokio-rs/axum/discussions/867)
- [tracing-appender - Rust Docs](https://docs.rs/tracing-appender/latest/tracing_appender/)
- [Axum Graceful Shutdown Example](https://github.com/tokio-rs/axum/blob/main/examples/graceful-shutdown/src/main.rs)
- [utoipa - GitHub](https://github.com/juhaku/utoipa)
- [tower-http trace - Rust Docs](https://docs.rs/tower-http/latest/tower_http/trace/index.html)
- [Tokio Graceful Shutdown Guide](https://tokio.rs/tokio/topics/shutdown)

---

### Critical Files for Implementation

- `/Users/jeffrey/code/tether/tether-server/src/main.rs` - Core entry point with router construction, middleware setup, tracing initialization, and graceful shutdown
- `/Users/jeffrey/code/tether/tether-server/src/state.rs` - SharedState type definition and AppState struct with helper methods
- `/Users/jeffrey/code/tether/tether-server/Cargo.toml` - Dependencies configuration for axum, tower-http, tracing ecosystem, and utoipa
- `/Users/jeffrey/code/tether/tether-core/src/lib.rs` - Core business logic crate that provides BluetoothManager and PassManager used by state
- `/Users/jeffrey/code/tether/tether-server/src/config.rs` - Configuration loading from TOML file, referenced by main.rs and state.rs
