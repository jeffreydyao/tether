Now I have all the context I need. Let me create the comprehensive implementation plan for `tether-core/src/error.rs`.

---

# Excruciating Implementation Details for `tether-core/src/error.rs`

## Overview

This file defines the foundational error types for the entire tether ecosystem. It will be used by:
- **Bluetooth module** (`bluetooth.rs`): Adapter discovery, device scanning, proximity detection
- **Config module** (`config.rs`): Configuration loading, parsing, validation
- **Passes module** (`passes.rs`): Pass management, persistence, history queries
- **HTTP server** (`tether-server`): API error responses via `axum`

## Dependencies Required in `tether-core/Cargo.toml`

```toml
[dependencies]
thiserror = "2.0"
```

---

## Complete Implementation: `tether-core/src/error.rs`

```rust
//! Error types for the tether core library.
//!
//! This module provides a unified error type [`TetherError`] that covers all failure
//! modes across the tether system, including Bluetooth operations, configuration
//! management, and pass persistence.
//!
//! # Design Principles
//!
//! - **Specific variants**: Each error variant captures exactly one failure mode
//! - **Actionable messages**: Error messages guide users toward resolution
//! - **Context preservation**: Wrapped errors maintain their original context
//! - **Type safety**: Strongly typed variants prevent error conflation
//!
//! # Example
//!
//! ```rust
//! use tether_core::error::{TetherError, Result};
//! use std::path::PathBuf;
//!
//! fn load_config(path: &PathBuf) -> Result<()> {
//!     if !path.exists() {
//!         return Err(TetherError::ConfigNotFound(path.clone()));
//!     }
//!     Ok(())
//! }
//! ```

use std::path::PathBuf;

/// The unified error type for all tether operations.
///
/// This enum covers all failure modes that can occur in the tether system.
/// Each variant is designed to be:
///
/// 1. **Self-descriptive**: The variant name indicates the failure mode
/// 2. **Contextual**: Variants include relevant data for debugging
/// 3. **Actionable**: Error messages suggest how to resolve the issue
///
/// # Categories
///
/// ## Bluetooth Errors
/// - [`BluetoothAdapterNotFound`][TetherError::BluetoothAdapterNotFound]
/// - [`BluetoothAdapterPoweredOff`][TetherError::BluetoothAdapterPoweredOff]
/// - [`BluetoothScanFailed`][TetherError::BluetoothScanFailed]
/// - [`DeviceNotFound`][TetherError::DeviceNotFound]
///
/// ## Pass Management Errors
/// - [`NoPassesRemaining`][TetherError::NoPassesRemaining]
/// - [`InvalidMonthFormat`][TetherError::InvalidMonthFormat]
///
/// ## Configuration Errors
/// - [`ConfigNotFound`][TetherError::ConfigNotFound]
/// - [`ConfigParseError`][TetherError::ConfigParseError]
/// - [`ConfigValidationError`][TetherError::ConfigValidationError]
///
/// ## Persistence & I/O Errors
/// - [`PersistenceError`][TetherError::PersistenceError]
/// - [`IoError`][TetherError::IoError]
#[derive(Debug, thiserror::Error)]
pub enum TetherError {
    // =========================================================================
    // BLUETOOTH ERRORS
    // =========================================================================
    
    /// No Bluetooth adapter was found on this system.
    ///
    /// This error occurs when:
    /// - The system has no Bluetooth hardware
    /// - The Bluetooth driver is not loaded
    /// - The Bluetooth adapter is not recognized by the OS
    ///
    /// # Resolution
    /// - Verify that the Raspberry Pi has Bluetooth hardware (Pi Zero 2 W has built-in BT)
    /// - Check that the Bluetooth kernel module is loaded: `lsmod | grep bluetooth`
    /// - Run `hciconfig` to verify adapter visibility
    #[error("No Bluetooth adapter found. Ensure Bluetooth hardware is present and drivers are loaded.")]
    BluetoothAdapterNotFound,

    /// The Bluetooth adapter exists but is powered off.
    ///
    /// This error occurs when:
    /// - Bluetooth was disabled via `bluetoothctl power off`
    /// - The system powered off Bluetooth for power saving
    /// - A software toggle disabled Bluetooth
    ///
    /// # Resolution
    /// - Run `bluetoothctl power on` to enable the adapter
    /// - Check `rfkill list` to ensure Bluetooth is not blocked
    #[error("Bluetooth adapter is powered off. Run 'bluetoothctl power on' to enable.")]
    BluetoothAdapterPoweredOff,

    /// Bluetooth device scanning failed.
    ///
    /// This error wraps platform-specific scan failures. The inner string
    /// contains the underlying error message from the Bluetooth stack.
    ///
    /// # Common Causes
    /// - Insufficient permissions (not running as root or missing capabilities)
    /// - Another application is performing an exclusive scan
    /// - The adapter entered an error state
    ///
    /// # Resolution
    /// - Ensure the process has CAP_NET_ADMIN capability or runs as root
    /// - Stop other Bluetooth applications that may be scanning
    /// - Restart the Bluetooth service: `sudo systemctl restart bluetooth`
    #[error("Bluetooth scan failed: {0}")]
    BluetoothScanFailed(String),

    /// The configured Bluetooth device was not found during scanning.
    ///
    /// The inner string contains the device identifier (MAC address or name)
    /// that could not be located.
    ///
    /// # Common Causes
    /// - The target device (phone) is out of range
    /// - The target device has Bluetooth disabled
    /// - The target device is not discoverable
    /// - The configured device identifier is incorrect
    ///
    /// # Resolution
    /// - Ensure the phone is within Bluetooth range (~10 meters typical)
    /// - Enable Bluetooth on the phone
    /// - Verify the device identifier in configuration matches the actual device
    #[error("Device not found: '{0}'. Ensure the device is powered on and within range.")]
    DeviceNotFound(String),

    // =========================================================================
    // PASS MANAGEMENT ERRORS
    // =========================================================================

    /// All passes for the current month have been used.
    ///
    /// This is an expected operational error when the user attempts to request
    /// a pass but has exhausted their monthly allocation.
    ///
    /// # Behavior
    /// - Passes reset automatically at midnight UTC on the 1st of each month
    /// - The configured pass count determines the monthly allocation
    /// - Changes to the pass count only take effect the following month
    ///
    /// # Resolution
    /// - Wait until the next month for passes to refresh
    /// - Consider increasing the monthly pass allocation in settings (takes effect next month)
    #[error("No passes remaining for this month. Passes will refresh on the 1st of next month.")]
    NoPassesRemaining,

    /// The provided month format is invalid.
    ///
    /// The inner string contains the invalid input that could not be parsed.
    /// Month format should conform to ISO 8601 `YYYY-MM` format (e.g., "2025-01").
    ///
    /// # Expected Format
    /// - Year: 4 digits (e.g., 2025)
    /// - Separator: hyphen (-)
    /// - Month: 2 digits, zero-padded (01-12)
    ///
    /// # Examples
    /// - Valid: "2025-01", "2024-12", "2025-06"
    /// - Invalid: "2025-1", "01-2025", "Jan 2025", "2025/01"
    #[error("Invalid month format: '{0}'. Expected ISO 8601 format 'YYYY-MM' (e.g., '2025-01').")]
    InvalidMonthFormat(String),

    // =========================================================================
    // CONFIGURATION ERRORS
    // =========================================================================

    /// The configuration file was not found at the expected path.
    ///
    /// The inner [`PathBuf`] contains the path where the configuration was expected.
    ///
    /// # Common Causes
    /// - First boot before initial configuration
    /// - Configuration file was deleted or moved
    /// - Incorrect path specified
    ///
    /// # Resolution
    /// - Complete the onboarding flow via the web UI
    /// - Check that the configuration directory exists
    /// - Verify file permissions allow reading
    #[error("Configuration file not found at: {}", _0.display())]
    ConfigNotFound(PathBuf),

    /// The configuration file exists but could not be parsed.
    ///
    /// The inner string contains the parse error details from the configuration
    /// format parser (TOML, JSON, etc.).
    ///
    /// # Common Causes
    /// - Syntax errors in the configuration file
    /// - Corrupted file contents
    /// - Encoding issues (file should be UTF-8)
    ///
    /// # Resolution
    /// - Check the configuration file for syntax errors
    /// - Validate the file against the expected schema
    /// - Re-run the onboarding flow to regenerate configuration
    #[error("Failed to parse configuration: {0}")]
    ConfigParseError(String),

    /// The configuration was parsed but contains invalid values.
    ///
    /// The inner string describes what validation constraint was violated.
    ///
    /// # Common Validations
    /// - Bluetooth MAC address format
    /// - Pass count is a positive integer
    /// - SSID is non-empty for Wi-Fi networks
    /// - Timezone is a valid IANA timezone name
    ///
    /// # Resolution
    /// - Review the validation error message
    /// - Correct the invalid value in configuration or via the web UI
    #[error("Configuration validation failed: {0}")]
    ConfigValidationError(String),

    // =========================================================================
    // PERSISTENCE & I/O ERRORS
    // =========================================================================

    /// An error occurred while persisting or reading pass data.
    ///
    /// The inner string contains details about the persistence operation that failed.
    /// This covers both reading historical pass data and writing new pass usage.
    ///
    /// # Common Causes
    /// - Disk full
    /// - File permission issues
    /// - Corrupted data file
    /// - Concurrent access conflicts
    ///
    /// # Resolution
    /// - Check available disk space
    /// - Verify file permissions on the data directory
    /// - If data is corrupted, consider resetting via the web UI
    #[error("Persistence error: {0}")]
    PersistenceError(String),

    /// A low-level I/O error occurred.
    ///
    /// This variant wraps [`std::io::Error`] for I/O operations that don't
    /// fit into more specific categories. The original error is preserved
    /// for detailed debugging.
    ///
    /// # Implementation Note
    /// This variant uses `#[from]` to enable automatic conversion via the `?` operator.
    /// The wrapped error is accessible via the `source()` method from the Error trait.
    #[error("I/O error: {0}")]
    IoError(#[from] std::io::Error),
}

// =============================================================================
// TYPE ALIASES
// =============================================================================

/// A specialized [`Result`] type for tether operations.
///
/// This type alias eliminates the need to specify the error type explicitly
/// when returning results from tether functions.
///
/// # Example
///
/// ```rust
/// use tether_core::error::Result;
///
/// fn check_proximity() -> Result<bool> {
///     // ... implementation
///     Ok(true)
/// }
/// ```
pub type Result<T> = std::result::Result<T, TetherError>;

// =============================================================================
// HELPER METHODS
// =============================================================================

impl TetherError {
    /// Returns `true` if this error is related to Bluetooth operations.
    ///
    /// This is useful for categorizing errors in logging or when presenting
    /// different UI feedback for different error categories.
    ///
    /// # Example
    ///
    /// ```rust
    /// use tether_core::error::TetherError;
    ///
    /// let err = TetherError::BluetoothAdapterNotFound;
    /// assert!(err.is_bluetooth_error());
    /// ```
    #[inline]
    pub fn is_bluetooth_error(&self) -> bool {
        matches!(
            self,
            TetherError::BluetoothAdapterNotFound
                | TetherError::BluetoothAdapterPoweredOff
                | TetherError::BluetoothScanFailed(_)
                | TetherError::DeviceNotFound(_)
        )
    }

    /// Returns `true` if this error is related to configuration.
    ///
    /// Configuration errors typically require user intervention via the web UI
    /// or direct file editing.
    ///
    /// # Example
    ///
    /// ```rust
    /// use tether_core::error::TetherError;
    /// use std::path::PathBuf;
    ///
    /// let err = TetherError::ConfigNotFound(PathBuf::from("/etc/tether/config.toml"));
    /// assert!(err.is_config_error());
    /// ```
    #[inline]
    pub fn is_config_error(&self) -> bool {
        matches!(
            self,
            TetherError::ConfigNotFound(_)
                | TetherError::ConfigParseError(_)
                | TetherError::ConfigValidationError(_)
        )
    }

    /// Returns `true` if this error is related to pass management.
    ///
    /// Pass errors may be expected operational states (e.g., no passes remaining)
    /// rather than system failures.
    ///
    /// # Example
    ///
    /// ```rust
    /// use tether_core::error::TetherError;
    ///
    /// let err = TetherError::NoPassesRemaining;
    /// assert!(err.is_pass_error());
    /// ```
    #[inline]
    pub fn is_pass_error(&self) -> bool {
        matches!(
            self,
            TetherError::NoPassesRemaining | TetherError::InvalidMonthFormat(_)
        )
    }

    /// Returns `true` if this error is related to I/O or persistence.
    ///
    /// These errors typically indicate system-level issues that may
    /// require administrative intervention.
    ///
    /// # Example
    ///
    /// ```rust
    /// use tether_core::error::TetherError;
    ///
    /// let err = TetherError::PersistenceError("disk full".to_string());
    /// assert!(err.is_io_error());
    /// ```
    #[inline]
    pub fn is_io_error(&self) -> bool {
        matches!(
            self,
            TetherError::PersistenceError(_) | TetherError::IoError(_)
        )
    }

    /// Returns `true` if this error represents an expected operational state.
    ///
    /// Some errors (like no passes remaining) are not system failures but
    /// expected operational conditions. This method helps distinguish
    /// between errors that require attention and those that are informational.
    ///
    /// Currently, only `NoPassesRemaining` is considered an expected state.
    ///
    /// # Example
    ///
    /// ```rust
    /// use tether_core::error::TetherError;
    ///
    /// // This is an expected state, not a system failure
    /// let err = TetherError::NoPassesRemaining;
    /// assert!(err.is_expected_state());
    ///
    /// // This is an actual error
    /// let err = TetherError::BluetoothAdapterNotFound;
    /// assert!(!err.is_expected_state());
    /// ```
    #[inline]
    pub fn is_expected_state(&self) -> bool {
        matches!(self, TetherError::NoPassesRemaining)
    }

    /// Returns `true` if this error is likely recoverable without user intervention.
    ///
    /// Some transient errors may resolve themselves (e.g., device temporarily
    /// out of range). This can inform retry logic.
    ///
    /// # Recoverable Errors
    /// - `DeviceNotFound`: Device may come back into range
    /// - `BluetoothScanFailed`: Transient scan issues may resolve
    ///
    /// # Non-Recoverable Errors (require user action)
    /// - `BluetoothAdapterNotFound`: Hardware issue
    /// - `ConfigNotFound`: Requires configuration
    /// - `NoPassesRemaining`: Must wait for month rollover
    ///
    /// # Example
    ///
    /// ```rust
    /// use tether_core::error::TetherError;
    ///
    /// let err = TetherError::DeviceNotFound("iPhone".to_string());
    /// if err.is_recoverable() {
    ///     // Maybe retry in a few seconds
    /// }
    /// ```
    #[inline]
    pub fn is_recoverable(&self) -> bool {
        matches!(
            self,
            TetherError::DeviceNotFound(_) | TetherError::BluetoothScanFailed(_)
        )
    }

    /// Returns an HTTP-appropriate status code for this error.
    ///
    /// This is useful when converting errors to HTTP responses in the axum server.
    /// The returned value corresponds to standard HTTP status codes.
    ///
    /// # Status Code Mapping
    ///
    /// | Error Category | HTTP Status |
    /// |----------------|-------------|
    /// | Config not found | 404 Not Found |
    /// | Device not found | 404 Not Found |
    /// | Invalid format errors | 400 Bad Request |
    /// | Config validation | 422 Unprocessable Entity |
    /// | No passes remaining | 403 Forbidden |
    /// | Bluetooth hardware errors | 503 Service Unavailable |
    /// | I/O and persistence errors | 500 Internal Server Error |
    ///
    /// # Example
    ///
    /// ```rust
    /// use tether_core::error::TetherError;
    ///
    /// let err = TetherError::NoPassesRemaining;
    /// assert_eq!(err.http_status_code(), 403);
    /// ```
    #[inline]
    pub fn http_status_code(&self) -> u16 {
        match self {
            // 400 Bad Request - malformed input
            TetherError::InvalidMonthFormat(_) => 400,

            // 403 Forbidden - understood but refused
            TetherError::NoPassesRemaining => 403,

            // 404 Not Found
            TetherError::ConfigNotFound(_) | TetherError::DeviceNotFound(_) => 404,

            // 422 Unprocessable Entity - semantic errors
            TetherError::ConfigParseError(_) | TetherError::ConfigValidationError(_) => 422,

            // 500 Internal Server Error - server-side issues
            TetherError::PersistenceError(_) | TetherError::IoError(_) => 500,

            // 503 Service Unavailable - Bluetooth hardware issues
            TetherError::BluetoothAdapterNotFound
            | TetherError::BluetoothAdapterPoweredOff
            | TetherError::BluetoothScanFailed(_) => 503,
        }
    }

    /// Returns a machine-readable error code for API responses.
    ///
    /// These codes are stable identifiers that clients can use to
    /// programmatically handle specific error conditions. They are
    /// designed to be:
    ///
    /// - Stable across versions
    /// - Self-documenting
    /// - Suitable for i18n lookup keys
    ///
    /// # Error Codes
    ///
    /// | Error | Code |
    /// |-------|------|
    /// | BluetoothAdapterNotFound | `BLUETOOTH_ADAPTER_NOT_FOUND` |
    /// | BluetoothAdapterPoweredOff | `BLUETOOTH_ADAPTER_POWERED_OFF` |
    /// | BluetoothScanFailed | `BLUETOOTH_SCAN_FAILED` |
    /// | DeviceNotFound | `DEVICE_NOT_FOUND` |
    /// | NoPassesRemaining | `NO_PASSES_REMAINING` |
    /// | InvalidMonthFormat | `INVALID_MONTH_FORMAT` |
    /// | ConfigNotFound | `CONFIG_NOT_FOUND` |
    /// | ConfigParseError | `CONFIG_PARSE_ERROR` |
    /// | ConfigValidationError | `CONFIG_VALIDATION_ERROR` |
    /// | PersistenceError | `PERSISTENCE_ERROR` |
    /// | IoError | `IO_ERROR` |
    ///
    /// # Example
    ///
    /// ```rust
    /// use tether_core::error::TetherError;
    ///
    /// let err = TetherError::NoPassesRemaining;
    /// assert_eq!(err.error_code(), "NO_PASSES_REMAINING");
    /// ```
    #[inline]
    pub fn error_code(&self) -> &'static str {
        match self {
            TetherError::BluetoothAdapterNotFound => "BLUETOOTH_ADAPTER_NOT_FOUND",
            TetherError::BluetoothAdapterPoweredOff => "BLUETOOTH_ADAPTER_POWERED_OFF",
            TetherError::BluetoothScanFailed(_) => "BLUETOOTH_SCAN_FAILED",
            TetherError::DeviceNotFound(_) => "DEVICE_NOT_FOUND",
            TetherError::NoPassesRemaining => "NO_PASSES_REMAINING",
            TetherError::InvalidMonthFormat(_) => "INVALID_MONTH_FORMAT",
            TetherError::ConfigNotFound(_) => "CONFIG_NOT_FOUND",
            TetherError::ConfigParseError(_) => "CONFIG_PARSE_ERROR",
            TetherError::ConfigValidationError(_) => "CONFIG_VALIDATION_ERROR",
            TetherError::PersistenceError(_) => "PERSISTENCE_ERROR",
            TetherError::IoError(_) => "IO_ERROR",
        }
    }
}

// =============================================================================
// ADDITIONAL FROM IMPLEMENTATIONS
// =============================================================================

// Note: The #[from] attribute on IoError already generates:
// impl From<std::io::Error> for TetherError

// For serde_json errors (if using JSON for config/persistence):
// Uncomment if serde_json is added as a dependency
/*
impl From<serde_json::Error> for TetherError {
    fn from(err: serde_json::Error) -> Self {
        TetherError::ConfigParseError(err.to_string())
    }
}
*/

// For toml errors (if using TOML for config):
// Uncomment if toml is added as a dependency
/*
impl From<toml::de::Error> for TetherError {
    fn from(err: toml::de::Error) -> Self {
        TetherError::ConfigParseError(err.to_string())
    }
}

impl From<toml::ser::Error> for TetherError {
    fn from(err: toml::ser::Error) -> Self {
        TetherError::PersistenceError(err.to_string())
    }
}
*/

// =============================================================================
// TESTS
// =============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::{Error as IoErr, ErrorKind};

    #[test]
    fn test_bluetooth_error_classification() {
        assert!(TetherError::BluetoothAdapterNotFound.is_bluetooth_error());
        assert!(TetherError::BluetoothAdapterPoweredOff.is_bluetooth_error());
        assert!(TetherError::BluetoothScanFailed("test".into()).is_bluetooth_error());
        assert!(TetherError::DeviceNotFound("iPhone".into()).is_bluetooth_error());

        // Non-bluetooth errors
        assert!(!TetherError::NoPassesRemaining.is_bluetooth_error());
        assert!(!TetherError::ConfigNotFound(PathBuf::new()).is_bluetooth_error());
    }

    #[test]
    fn test_config_error_classification() {
        assert!(TetherError::ConfigNotFound(PathBuf::from("/test")).is_config_error());
        assert!(TetherError::ConfigParseError("syntax error".into()).is_config_error());
        assert!(TetherError::ConfigValidationError("invalid value".into()).is_config_error());

        // Non-config errors
        assert!(!TetherError::BluetoothAdapterNotFound.is_config_error());
        assert!(!TetherError::NoPassesRemaining.is_config_error());
    }

    #[test]
    fn test_pass_error_classification() {
        assert!(TetherError::NoPassesRemaining.is_pass_error());
        assert!(TetherError::InvalidMonthFormat("bad-format".into()).is_pass_error());

        // Non-pass errors
        assert!(!TetherError::BluetoothAdapterNotFound.is_pass_error());
        assert!(!TetherError::ConfigNotFound(PathBuf::new()).is_pass_error());
    }

    #[test]
    fn test_io_error_classification() {
        assert!(TetherError::PersistenceError("disk full".into()).is_io_error());
        assert!(TetherError::IoError(IoErr::new(ErrorKind::NotFound, "test")).is_io_error());

        // Non-IO errors
        assert!(!TetherError::BluetoothAdapterNotFound.is_io_error());
        assert!(!TetherError::NoPassesRemaining.is_io_error());
    }

    #[test]
    fn test_expected_state() {
        assert!(TetherError::NoPassesRemaining.is_expected_state());

        // These are real errors, not expected states
        assert!(!TetherError::BluetoothAdapterNotFound.is_expected_state());
        assert!(!TetherError::ConfigNotFound(PathBuf::new()).is_expected_state());
        assert!(!TetherError::DeviceNotFound("iPhone".into()).is_expected_state());
    }

    #[test]
    fn test_recoverable_errors() {
        assert!(TetherError::DeviceNotFound("iPhone".into()).is_recoverable());
        assert!(TetherError::BluetoothScanFailed("timeout".into()).is_recoverable());

        // Non-recoverable errors
        assert!(!TetherError::BluetoothAdapterNotFound.is_recoverable());
        assert!(!TetherError::NoPassesRemaining.is_recoverable());
        assert!(!TetherError::ConfigNotFound(PathBuf::new()).is_recoverable());
    }

    #[test]
    fn test_http_status_codes() {
        // 400 Bad Request
        assert_eq!(TetherError::InvalidMonthFormat("bad".into()).http_status_code(), 400);

        // 403 Forbidden
        assert_eq!(TetherError::NoPassesRemaining.http_status_code(), 403);

        // 404 Not Found
        assert_eq!(TetherError::ConfigNotFound(PathBuf::new()).http_status_code(), 404);
        assert_eq!(TetherError::DeviceNotFound("iPhone".into()).http_status_code(), 404);

        // 422 Unprocessable Entity
        assert_eq!(TetherError::ConfigParseError("error".into()).http_status_code(), 422);
        assert_eq!(TetherError::ConfigValidationError("error".into()).http_status_code(), 422);

        // 500 Internal Server Error
        assert_eq!(TetherError::PersistenceError("error".into()).http_status_code(), 500);
        assert_eq!(
            TetherError::IoError(IoErr::new(ErrorKind::Other, "test")).http_status_code(),
            500
        );

        // 503 Service Unavailable
        assert_eq!(TetherError::BluetoothAdapterNotFound.http_status_code(), 503);
        assert_eq!(TetherError::BluetoothAdapterPoweredOff.http_status_code(), 503);
        assert_eq!(TetherError::BluetoothScanFailed("error".into()).http_status_code(), 503);
    }

    #[test]
    fn test_error_codes() {
        assert_eq!(TetherError::BluetoothAdapterNotFound.error_code(), "BLUETOOTH_ADAPTER_NOT_FOUND");
        assert_eq!(TetherError::BluetoothAdapterPoweredOff.error_code(), "BLUETOOTH_ADAPTER_POWERED_OFF");
        assert_eq!(TetherError::BluetoothScanFailed("x".into()).error_code(), "BLUETOOTH_SCAN_FAILED");
        assert_eq!(TetherError::DeviceNotFound("x".into()).error_code(), "DEVICE_NOT_FOUND");
        assert_eq!(TetherError::NoPassesRemaining.error_code(), "NO_PASSES_REMAINING");
        assert_eq!(TetherError::InvalidMonthFormat("x".into()).error_code(), "INVALID_MONTH_FORMAT");
        assert_eq!(TetherError::ConfigNotFound(PathBuf::new()).error_code(), "CONFIG_NOT_FOUND");
        assert_eq!(TetherError::ConfigParseError("x".into()).error_code(), "CONFIG_PARSE_ERROR");
        assert_eq!(TetherError::ConfigValidationError("x".into()).error_code(), "CONFIG_VALIDATION_ERROR");
        assert_eq!(TetherError::PersistenceError("x".into()).error_code(), "PERSISTENCE_ERROR");
        assert_eq!(TetherError::IoError(IoErr::new(ErrorKind::Other, "x")).error_code(), "IO_ERROR");
    }

    #[test]
    fn test_from_io_error() {
        let io_err = IoErr::new(ErrorKind::NotFound, "file not found");
        let tether_err: TetherError = io_err.into();

        assert!(matches!(tether_err, TetherError::IoError(_)));
        assert!(tether_err.is_io_error());

        // Verify the Display message includes the original error
        let display = format!("{}", tether_err);
        assert!(display.contains("I/O error"));
    }

    #[test]
    fn test_error_display_messages() {
        // Test that display messages are human-readable
        let err = TetherError::BluetoothAdapterNotFound;
        assert!(format!("{}", err).contains("No Bluetooth adapter found"));

        let err = TetherError::BluetoothAdapterPoweredOff;
        assert!(format!("{}", err).contains("powered off"));

        let err = TetherError::BluetoothScanFailed("permission denied".into());
        assert!(format!("{}", err).contains("permission denied"));

        let err = TetherError::DeviceNotFound("MyiPhone".into());
        assert!(format!("{}", err).contains("MyiPhone"));

        let err = TetherError::NoPassesRemaining;
        assert!(format!("{}", err).contains("No passes remaining"));

        let err = TetherError::InvalidMonthFormat("bad-date".into());
        assert!(format!("{}", err).contains("bad-date"));
        assert!(format!("{}", err).contains("YYYY-MM"));

        let err = TetherError::ConfigNotFound(PathBuf::from("/etc/tether/config.toml"));
        assert!(format!("{}", err).contains("/etc/tether/config.toml"));

        let err = TetherError::ConfigParseError("unexpected token".into());
        assert!(format!("{}", err).contains("unexpected token"));

        let err = TetherError::ConfigValidationError("invalid timezone".into());
        assert!(format!("{}", err).contains("invalid timezone"));

        let err = TetherError::PersistenceError("disk full".into());
        assert!(format!("{}", err).contains("disk full"));
    }

    #[test]
    fn test_error_is_send_and_sync() {
        // Ensure TetherError can be used across threads
        fn assert_send<T: Send>() {}
        fn assert_sync<T: Sync>() {}

        assert_send::<TetherError>();
        assert_sync::<TetherError>();
    }

    #[test]
    fn test_result_type_alias() {
        fn example_function() -> Result<i32> {
            Ok(42)
        }

        assert_eq!(example_function().unwrap(), 42);

        fn failing_function() -> Result<i32> {
            Err(TetherError::NoPassesRemaining)
        }

        assert!(failing_function().is_err());
    }
}
```

---

## Integration Notes for Other Modules

### Usage in `lib.rs`

```rust
// tether-core/src/lib.rs
pub mod error;

// Re-export for convenience
pub use error::{TetherError, Result};
```

### Usage in Bluetooth Module

```rust
// tether-core/src/bluetooth.rs
use crate::error::{TetherError, Result};

pub async fn get_adapter() -> Result<BluetoothAdapter> {
    // ... btleplug code ...
    adapter.ok_or(TetherError::BluetoothAdapterNotFound)
}

pub async fn check_proximity(device_id: &str) -> Result<bool> {
    // ...
    Err(TetherError::DeviceNotFound(device_id.to_string()))
}
```

### Usage in Config Module

```rust
// tether-core/src/config.rs
use crate::error::{TetherError, Result};
use std::path::Path;

pub fn load_config(path: &Path) -> Result<Config> {
    if !path.exists() {
        return Err(TetherError::ConfigNotFound(path.to_path_buf()));
    }
    
    let content = std::fs::read_to_string(path)?; // Uses From<io::Error>
    
    let config: Config = toml::from_str(&content)
        .map_err(|e| TetherError::ConfigParseError(e.to_string()))?;
    
    validate_config(&config)?;
    Ok(config)
}

fn validate_config(config: &Config) -> Result<()> {
    if config.passes_per_month == 0 {
        return Err(TetherError::ConfigValidationError(
            "passes_per_month must be greater than 0".to_string()
        ));
    }
    Ok(())
}
```

### Usage in Passes Module

```rust
// tether-core/src/passes.rs
use crate::error::{TetherError, Result};

pub fn use_pass(reason: &str) -> Result<PassUsage> {
    let remaining = get_remaining_passes()?;
    if remaining == 0 {
        return Err(TetherError::NoPassesRemaining);
    }
    // ... record pass usage
    Ok(PassUsage { /* ... */ })
}

pub fn get_pass_history(month: &str) -> Result<Vec<PassUsage>> {
    parse_month(month)?; // Returns InvalidMonthFormat if bad
    // ...
    Ok(vec![])
}

fn parse_month(month: &str) -> Result<(i32, u32)> {
    // Expected format: "YYYY-MM"
    let parts: Vec<&str> = month.split('-').collect();
    if parts.len() != 2 {
        return Err(TetherError::InvalidMonthFormat(month.to_string()));
    }
    // ... parse year and month
    Ok((year, month_num))
}
```

### Usage in HTTP Server (axum)

```rust
// tether-server/src/handlers.rs
use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use serde::Serialize;
use tether_core::error::TetherError;

#[derive(Serialize)]
struct ErrorResponse {
    error: String,
    code: &'static str,
}

impl IntoResponse for TetherError {
    fn into_response(self) -> Response {
        let status = StatusCode::from_u16(self.http_status_code())
            .unwrap_or(StatusCode::INTERNAL_SERVER_ERROR);
        
        let body = ErrorResponse {
            error: self.to_string(),
            code: self.error_code(),
        };
        
        (status, Json(body)).into_response()
    }
}
```

---

## Sources

- [thiserror - Rust documentation](https://docs.rs/thiserror)
- [Rust Error Handling Guide 2025](https://markaicode.com/rust-error-handling-2025-guide/)
- [btleplug Error enum](https://docs.rs/btleplug/latest/btleplug/enum.Error.html)
- [Error Handling for Large Rust Projects - GreptimeDB](https://greptime.com/blogs/2024-05-07-error-rust)

---

### Critical Files for Implementation

- `/Users/jeffrey/code/tether/tether-core/src/error.rs` - The file to create; contains the complete TetherError implementation above
- `/Users/jeffrey/code/tether/tether-core/src/lib.rs` - Must export error module with `pub mod error;` and re-exports
- `/Users/jeffrey/code/tether/tether-core/Cargo.toml` - Must include `thiserror = "2.0"` dependency
- `/Users/jeffrey/code/tether/tether-server/src/handlers.rs` - Will implement `IntoResponse` for axum integration (pattern shown above)
- `/Users/jeffrey/code/tether/claude-spec.md` - Reference for understanding the module structure and error scenarios across bluetooth, config, and passes
