Now I have comprehensive information. Let me compile the excruciating implementation details for the network watchdog script.

---

# Network Watchdog Implementation Details

## Overview

This document provides complete, copy-paste ready implementation details for the `tether-network-watchdog.sh` bash script and all related configuration. The watchdog manages WiFi connectivity and AP fallback using NetworkManager on Raspberry Pi.

---

## 1. Complete `tether-network-watchdog.sh` Script

```bash
#!/usr/bin/env bash
#
# tether-network-watchdog.sh
# 
# Network watchdog for Tether - manages WiFi connectivity and AP fallback.
# Monitors internet connectivity and falls back to AP mode when all networks fail.
#
# Exit codes:
#   0 - Clean shutdown
#   1 - General error
#   2 - NetworkManager not running
#   3 - WiFi hardware not available
#   4 - Configuration file error
#
# Signals:
#   SIGHUP  - Reload configuration and force connectivity check
#   SIGTERM - Graceful shutdown
#   SIGINT  - Graceful shutdown
#

set -euo pipefail

################################################################################
# CONSTANTS
################################################################################

readonly SCRIPT_NAME="tether-network-watchdog"
readonly SCRIPT_VERSION="1.0.0"

# Paths
readonly CONFIG_DIR="/etc/tether"
readonly CONFIG_FILE="${CONFIG_DIR}/config.toml"
readonly STATE_DIR="/var/lib/tether"
readonly STATE_FILE="${STATE_DIR}/watchdog.state"
readonly LOG_DIR="/var/log/tether"
readonly LOG_FILE="${LOG_DIR}/network-watchdog.log"
readonly PID_FILE="/run/tether-network-watchdog.pid"

# NetworkManager connection names
readonly AP_CONNECTION_NAME="TetherSetup"
readonly AP_SSID="TetherSetup"
readonly AP_INTERFACE="wlan0"

# AP Mode configuration
readonly AP_IP_ADDRESS="192.168.4.1"
readonly AP_IP_NETMASK="24"
readonly AP_CHANNEL="6"
readonly AP_BAND="bg"  # 2.4GHz

# Connectivity check configuration
readonly CONNECTIVITY_CHECK_URL="http://connectivitycheck.gstatic.com/generate_204"
readonly CONNECTIVITY_CHECK_TIMEOUT=10
readonly CONNECTIVITY_EXPECTED_CODE=204

# Timing (in seconds)
readonly CHECK_INTERVAL=30
readonly NETWORK_SWITCH_DELAY=5
readonly MAX_CONNECTION_ATTEMPTS=3
readonly CONNECTION_TIMEOUT=30

# nmcli exit codes
readonly NMCLI_SUCCESS=0
readonly NMCLI_UNKNOWN_ERROR=1
readonly NMCLI_INVALID_INPUT=2
readonly NMCLI_TIMEOUT=3
readonly NMCLI_ACTIVATION_FAILED=4
readonly NMCLI_DEACTIVATION_FAILED=5
readonly NMCLI_DISCONNECT_FAILED=6
readonly NMCLI_DELETE_FAILED=7
readonly NMCLI_NM_NOT_RUNNING=8
readonly NMCLI_NOT_FOUND=10

################################################################################
# GLOBAL STATE
################################################################################

# Current state
declare -g CURRENT_MODE="unknown"         # "wifi", "ap", "disconnected"
declare -g CURRENT_SSID=""
declare -g LAST_CONNECTIVITY_CHECK=0
declare -g SHUTDOWN_REQUESTED=false
declare -g RELOAD_REQUESTED=false

# Configuration (loaded from TOML)
declare -ga CONFIGURED_SSIDS=()
declare -ga CONFIGURED_PASSWORDS=()
declare -g IS_ONBOARDED="false"
declare -g PRIMARY_SSID=""

################################################################################
# LOGGING
################################################################################

# Log levels
readonly LOG_LEVEL_DEBUG=0
readonly LOG_LEVEL_INFO=1
readonly LOG_LEVEL_WARN=2
readonly LOG_LEVEL_ERROR=3

# Current log level (can be overridden by environment)
LOG_LEVEL="${LOG_LEVEL:-$LOG_LEVEL_INFO}"

_log() {
    local level="$1"
    local level_name="$2"
    shift 2
    local message="$*"
    local timestamp
    timestamp=$(date -u '+%Y-%m-%dT%H:%M:%SZ')
    
    if [[ "$level" -ge "$LOG_LEVEL" ]]; then
        # Log to file
        echo "${timestamp} [${level_name}] ${message}" >> "$LOG_FILE"
        
        # Also log to stderr if running interactively
        if [[ -t 2 ]]; then
            echo "${timestamp} [${level_name}] ${message}" >&2
        fi
        
        # Log to systemd journal if available
        if command -v logger &>/dev/null; then
            logger -t "$SCRIPT_NAME" -p "daemon.${level_name,,}" "$message"
        fi
    fi
}

log_debug() { _log "$LOG_LEVEL_DEBUG" "DEBUG" "$@"; }
log_info()  { _log "$LOG_LEVEL_INFO"  "INFO"  "$@"; }
log_warn()  { _log "$LOG_LEVEL_WARN"  "WARN"  "$@"; }
log_error() { _log "$LOG_LEVEL_ERROR" "ERROR" "$@"; }

################################################################################
# INITIALIZATION AND CLEANUP
################################################################################

init_directories() {
    # Create required directories with proper permissions
    local dirs=("$CONFIG_DIR" "$STATE_DIR" "$LOG_DIR")
    
    for dir in "${dirs[@]}"; do
        if [[ ! -d "$dir" ]]; then
            mkdir -p "$dir"
            chmod 755 "$dir"
            log_info "Created directory: $dir"
        fi
    done
    
    # Ensure log file exists and is writable
    if [[ ! -f "$LOG_FILE" ]]; then
        touch "$LOG_FILE"
        chmod 644 "$LOG_FILE"
    fi
}

write_pid_file() {
    echo $$ > "$PID_FILE"
    log_debug "Wrote PID $$ to $PID_FILE"
}

remove_pid_file() {
    if [[ -f "$PID_FILE" ]]; then
        rm -f "$PID_FILE"
        log_debug "Removed PID file"
    fi
}

cleanup() {
    log_info "Cleaning up..."
    remove_pid_file
    log_info "Watchdog shutdown complete"
}

################################################################################
# SIGNAL HANDLERS
################################################################################

handle_shutdown() {
    log_info "Received shutdown signal"
    SHUTDOWN_REQUESTED=true
}

handle_reload() {
    log_info "Received reload signal (SIGHUP)"
    RELOAD_REQUESTED=true
}

setup_signal_handlers() {
    trap handle_shutdown SIGTERM SIGINT
    trap handle_reload SIGHUP
    trap cleanup EXIT
}

################################################################################
# PREREQUISITES CHECK
################################################################################

check_root() {
    if [[ $EUID -ne 0 ]]; then
        log_error "This script must be run as root"
        exit 1
    fi
}

check_networkmanager_running() {
    # Check if NetworkManager service is active
    if ! systemctl is-active --quiet NetworkManager; then
        log_error "NetworkManager is not running"
        
        # Attempt to start it
        log_info "Attempting to start NetworkManager..."
        if systemctl start NetworkManager; then
            log_info "NetworkManager started successfully"
            sleep 2  # Give it time to initialize
        else
            log_error "Failed to start NetworkManager"
            return 1
        fi
    fi
    
    # Verify nmcli can communicate with NetworkManager
    if ! LC_ALL=C nmcli general status &>/dev/null; then
        log_error "Cannot communicate with NetworkManager via nmcli"
        return 1
    fi
    
    log_debug "NetworkManager is running and responsive"
    return 0
}

check_wifi_hardware() {
    # Check if WiFi device exists
    if ! nmcli device status | grep -q "^${AP_INTERFACE}"; then
        log_error "WiFi interface ${AP_INTERFACE} not found"
        return 1
    fi
    
    # Check device type
    local device_type
    device_type=$(LC_ALL=C nmcli -t -f DEVICE,TYPE device status | grep "^${AP_INTERFACE}:" | cut -d: -f2)
    
    if [[ "$device_type" != "wifi" ]]; then
        log_error "Device ${AP_INTERFACE} is not a WiFi device (type: $device_type)"
        return 1
    fi
    
    # Check if WiFi radio is enabled
    local wifi_enabled
    wifi_enabled=$(LC_ALL=C nmcli radio wifi)
    
    if [[ "$wifi_enabled" != "enabled" ]]; then
        log_warn "WiFi radio is disabled, attempting to enable..."
        if LC_ALL=C nmcli radio wifi on; then
            log_info "WiFi radio enabled"
            sleep 2
        else
            log_error "Failed to enable WiFi radio"
            return 1
        fi
    fi
    
    log_debug "WiFi hardware check passed"
    return 0
}

check_prerequisites() {
    log_info "Checking prerequisites..."
    
    check_root
    
    if ! check_networkmanager_running; then
        exit 2
    fi
    
    if ! check_wifi_hardware; then
        exit 3
    fi
    
    log_info "Prerequisites check passed"
}

################################################################################
# CONFIGURATION PARSING
################################################################################

# Simple TOML parser for our specific config format
# Handles:
#   onboarded = true/false
#   primary_ssid = "NetworkName"
#   [[wifi_networks]]
#   ssid = "NetworkName"
#   password = "password123"  # Optional

parse_config() {
    log_info "Parsing configuration from $CONFIG_FILE"
    
    # Reset configuration
    CONFIGURED_SSIDS=()
    CONFIGURED_PASSWORDS=()
    IS_ONBOARDED="false"
    PRIMARY_SSID=""
    
    if [[ ! -f "$CONFIG_FILE" ]]; then
        log_warn "Configuration file not found: $CONFIG_FILE"
        log_info "Assuming first boot - device not onboarded"
        return 0
    fi
    
    if [[ ! -r "$CONFIG_FILE" ]]; then
        log_error "Cannot read configuration file: $CONFIG_FILE"
        return 1
    fi
    
    local in_wifi_section=false
    local current_ssid=""
    local current_password=""
    local line_number=0
    
    while IFS= read -r line || [[ -n "$line" ]]; do
        ((line_number++))
        
        # Remove leading/trailing whitespace
        line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        
        # Skip empty lines and comments
        [[ -z "$line" ]] && continue
        [[ "$line" =~ ^# ]] && continue
        
        # Check for [[wifi_networks]] section
        if [[ "$line" == "[[wifi_networks]]" ]]; then
            # Save previous network if exists
            if [[ -n "$current_ssid" ]]; then
                CONFIGURED_SSIDS+=("$current_ssid")
                CONFIGURED_PASSWORDS+=("$current_password")
            fi
            in_wifi_section=true
            current_ssid=""
            current_password=""
            continue
        fi
        
        # Check for other section headers (exit wifi section)
        if [[ "$line" =~ ^\[.*\]$ && "$line" != "[[wifi_networks]]" ]]; then
            # Save previous network if exists
            if [[ -n "$current_ssid" ]]; then
                CONFIGURED_SSIDS+=("$current_ssid")
                CONFIGURED_PASSWORDS+=("$current_password")
                current_ssid=""
                current_password=""
            fi
            in_wifi_section=false
            continue
        fi
        
        # Parse key = value
        if [[ "$line" =~ ^([a-zA-Z_][a-zA-Z0-9_]*)\ *=\ *(.+)$ ]]; then
            local key="${BASH_REMATCH[1]}"
            local value="${BASH_REMATCH[2]}"
            
            # Remove quotes from value
            value=$(echo "$value" | sed 's/^"//;s/"$//' | sed "s/^'//;s/'$//")
            
            if $in_wifi_section; then
                case "$key" in
                    ssid)
                        current_ssid="$value"
                        ;;
                    password)
                        current_password="$value"
                        ;;
                esac
            else
                # Top-level configuration
                case "$key" in
                    onboarded)
                        IS_ONBOARDED="$value"
                        ;;
                    primary_ssid)
                        PRIMARY_SSID="$value"
                        ;;
                esac
            fi
        fi
    done < "$CONFIG_FILE"
    
    # Save last network if exists
    if [[ -n "$current_ssid" ]]; then
        CONFIGURED_SSIDS+=("$current_ssid")
        CONFIGURED_PASSWORDS+=("$current_password")
    fi
    
    # Log parsed configuration
    log_info "Configuration loaded:"
    log_info "  onboarded: $IS_ONBOARDED"
    log_info "  primary_ssid: ${PRIMARY_SSID:-<none>}"
    log_info "  configured networks: ${#CONFIGURED_SSIDS[@]}"
    
    for i in "${!CONFIGURED_SSIDS[@]}"; do
        local has_password="no"
        [[ -n "${CONFIGURED_PASSWORDS[$i]}" ]] && has_password="yes"
        log_debug "    [$i] ${CONFIGURED_SSIDS[$i]} (password: $has_password)"
    done
    
    return 0
}

################################################################################
# STATE MANAGEMENT
################################################################################

save_state() {
    local state_content
    state_content=$(cat <<EOF
# Tether Network Watchdog State
# Auto-generated - do not edit
timestamp=$(date -u '+%Y-%m-%dT%H:%M:%SZ')
mode=${CURRENT_MODE}
ssid=${CURRENT_SSID}
last_check=${LAST_CONNECTIVITY_CHECK}
EOF
)
    echo "$state_content" > "$STATE_FILE"
    chmod 644 "$STATE_FILE"
}

load_state() {
    if [[ -f "$STATE_FILE" ]]; then
        log_debug "Loading previous state from $STATE_FILE"
        # Simple key=value parsing
        while IFS='=' read -r key value; do
            [[ "$key" =~ ^# ]] && continue
            [[ -z "$key" ]] && continue
            case "$key" in
                mode) CURRENT_MODE="$value" ;;
                ssid) CURRENT_SSID="$value" ;;
            esac
        done < "$STATE_FILE"
        log_debug "Loaded state: mode=$CURRENT_MODE, ssid=$CURRENT_SSID"
    fi
}

################################################################################
# CONNECTIVITY CHECKING
################################################################################

check_internet_connectivity() {
    log_debug "Checking internet connectivity..."
    
    local http_code
    local curl_exit_code
    
    # Use curl to check connectivity
    # -s: silent, -o /dev/null: discard output, -w: write HTTP code
    # -m: max time, --connect-timeout: connection timeout
    http_code=$(curl -s -o /dev/null -w "%{http_code}" \
        -m "$CONNECTIVITY_CHECK_TIMEOUT" \
        --connect-timeout 5 \
        "$CONNECTIVITY_CHECK_URL" 2>/dev/null) || curl_exit_code=$?
    
    LAST_CONNECTIVITY_CHECK=$(date +%s)
    
    if [[ -n "${curl_exit_code:-}" ]]; then
        log_debug "curl failed with exit code: $curl_exit_code"
        case "$curl_exit_code" in
            6)  log_debug "Could not resolve host" ;;
            7)  log_debug "Failed to connect to host" ;;
            28) log_debug "Connection timed out" ;;
            *)  log_debug "curl error: $curl_exit_code" ;;
        esac
        return 1
    fi
    
    if [[ "$http_code" -eq "$CONNECTIVITY_EXPECTED_CODE" ]]; then
        log_debug "Internet connectivity confirmed (HTTP $http_code)"
        return 0
    else
        log_debug "Unexpected HTTP response: $http_code (expected $CONNECTIVITY_EXPECTED_CODE)"
        return 1
    fi
}

# Alternative connectivity check using NetworkManager's built-in check
check_nm_connectivity() {
    local connectivity
    connectivity=$(LC_ALL=C nmcli networking connectivity check 2>/dev/null)
    
    case "$connectivity" in
        full)
            log_debug "NetworkManager reports full connectivity"
            return 0
            ;;
        limited)
            log_debug "NetworkManager reports limited connectivity"
            return 1
            ;;
        portal)
            log_debug "NetworkManager reports captive portal"
            return 1
            ;;
        none)
            log_debug "NetworkManager reports no connectivity"
            return 1
            ;;
        *)
            log_debug "NetworkManager connectivity unknown: $connectivity"
            return 1
            ;;
    esac
}

################################################################################
# NETWORK SCANNING
################################################################################

scan_available_networks() {
    log_debug "Scanning for available WiFi networks..."
    
    # Force a rescan
    LC_ALL=C nmcli device wifi rescan ifname "$AP_INTERFACE" 2>/dev/null || true
    sleep 2
    
    # Get list of available networks
    LC_ALL=C nmcli -t -f SSID,SIGNAL,SECURITY device wifi list ifname "$AP_INTERFACE" 2>/dev/null
}

is_network_available() {
    local target_ssid="$1"
    
    # Scan and check if network is visible
    local available
    available=$(scan_available_networks)
    
    if echo "$available" | grep -q "^${target_ssid}:"; then
        log_debug "Network '$target_ssid' is available"
        return 0
    else
        log_debug "Network '$target_ssid' is not available"
        return 1
    fi
}

################################################################################
# CONNECTION MANAGEMENT
################################################################################

get_active_connection() {
    # Get the active WiFi connection name
    LC_ALL=C nmcli -t -f NAME,TYPE,DEVICE connection show --active 2>/dev/null | \
        grep ":802-11-wireless:${AP_INTERFACE}$" | \
        cut -d: -f1 | \
        head -n1
}

get_active_ssid() {
    # Get the SSID of the currently connected network
    LC_ALL=C nmcli -t -f ACTIVE,SSID device wifi list ifname "$AP_INTERFACE" 2>/dev/null | \
        grep "^yes:" | \
        cut -d: -f2 | \
        head -n1
}

connection_exists() {
    local conn_name="$1"
    LC_ALL=C nmcli -t -f NAME connection show 2>/dev/null | grep -q "^${conn_name}$"
}

get_connection_for_ssid() {
    local ssid="$1"
    # Find connection profile for this SSID
    LC_ALL=C nmcli -t -f NAME,802-11-wireless.ssid connection show 2>/dev/null | \
        grep ":${ssid}$" | \
        cut -d: -f1 | \
        head -n1
}

################################################################################
# WIFI STATION MODE
################################################################################

connect_to_wifi() {
    local ssid="$1"
    local password="${2:-}"
    local attempt=1
    
    log_info "Attempting to connect to WiFi: $ssid"
    
    # First, ensure AP mode is disabled
    disable_ap_mode_if_active
    
    while [[ $attempt -le $MAX_CONNECTION_ATTEMPTS ]]; do
        log_debug "Connection attempt $attempt of $MAX_CONNECTION_ATTEMPTS"
        
        # Check if connection profile exists
        local conn_name
        conn_name=$(get_connection_for_ssid "$ssid")
        
        local nmcli_result
        local exit_code
        
        if [[ -n "$conn_name" ]]; then
            # Use existing connection profile
            log_debug "Using existing connection profile: $conn_name"
            nmcli_result=$(LC_ALL=C nmcli --wait "$CONNECTION_TIMEOUT" connection up "$conn_name" 2>&1) && exit_code=0 || exit_code=$?
        else
            # Create new connection on the fly
            log_debug "Creating new connection for SSID: $ssid"
            if [[ -n "$password" ]]; then
                nmcli_result=$(LC_ALL=C nmcli --wait "$CONNECTION_TIMEOUT" device wifi connect "$ssid" password "$password" ifname "$AP_INTERFACE" 2>&1) && exit_code=0 || exit_code=$?
            else
                nmcli_result=$(LC_ALL=C nmcli --wait "$CONNECTION_TIMEOUT" device wifi connect "$ssid" ifname "$AP_INTERFACE" 2>&1) && exit_code=0 || exit_code=$?
            fi
        fi
        
        case $exit_code in
            $NMCLI_SUCCESS)
                log_info "Successfully connected to: $ssid"
                CURRENT_MODE="wifi"
                CURRENT_SSID="$ssid"
                save_state
                
                # Wait a moment and verify connectivity
                sleep 3
                if check_internet_connectivity; then
                    log_info "Internet connectivity verified on $ssid"
                    return 0
                else
                    log_warn "Connected to $ssid but no internet access"
                    # Don't return failure yet - might still be usable
                    return 0
                fi
                ;;
            $NMCLI_TIMEOUT)
                log_warn "Connection attempt timed out"
                ;;
            $NMCLI_ACTIVATION_FAILED)
                log_warn "Connection activation failed: $nmcli_result"
                ;;
            $NMCLI_NM_NOT_RUNNING)
                log_error "NetworkManager is not running"
                return 1
                ;;
            $NMCLI_NOT_FOUND)
                log_warn "Network or connection not found"
                return 1  # No point retrying
                ;;
            *)
                log_warn "Connection failed with code $exit_code: $nmcli_result"
                ;;
        esac
        
        ((attempt++))
        [[ $attempt -le $MAX_CONNECTION_ATTEMPTS ]] && sleep 2
    done
    
    log_error "Failed to connect to $ssid after $MAX_CONNECTION_ATTEMPTS attempts"
    return 1
}

disconnect_wifi() {
    log_debug "Disconnecting WiFi..."
    
    local active_conn
    active_conn=$(get_active_connection)
    
    if [[ -n "$active_conn" && "$active_conn" != "$AP_CONNECTION_NAME" ]]; then
        log_debug "Deactivating connection: $active_conn"
        LC_ALL=C nmcli connection down "$active_conn" 2>/dev/null || true
    fi
    
    CURRENT_MODE="disconnected"
    CURRENT_SSID=""
    save_state
}

################################################################################
# ACCESS POINT MODE
################################################################################

create_ap_connection_profile() {
    log_info "Creating AP connection profile: $AP_CONNECTION_NAME"
    
    # Delete existing if present (to ensure clean state)
    if connection_exists "$AP_CONNECTION_NAME"; then
        log_debug "Removing existing AP connection profile"
        LC_ALL=C nmcli connection delete "$AP_CONNECTION_NAME" 2>/dev/null || true
        sleep 1
    fi
    
    # Create AP connection profile
    # Step 1: Create basic connection
    if ! LC_ALL=C nmcli connection add \
        type wifi \
        ifname "$AP_INTERFACE" \
        con-name "$AP_CONNECTION_NAME" \
        autoconnect no \
        ssid "$AP_SSID" \
        mode ap \
        2>&1; then
        log_error "Failed to create AP connection profile"
        return 1
    fi
    
    # Step 2: Configure WiFi settings
    if ! LC_ALL=C nmcli connection modify "$AP_CONNECTION_NAME" \
        802-11-wireless.band "$AP_BAND" \
        802-11-wireless.channel "$AP_CHANNEL" \
        2>&1; then
        log_error "Failed to configure AP WiFi settings"
        return 1
    fi
    
    # Step 3: Configure IP settings (shared mode enables DHCP via dnsmasq)
    if ! LC_ALL=C nmcli connection modify "$AP_CONNECTION_NAME" \
        ipv4.method shared \
        ipv4.addresses "${AP_IP_ADDRESS}/${AP_IP_NETMASK}" \
        2>&1; then
        log_error "Failed to configure AP IP settings"
        return 1
    fi
    
    # Step 4: Disable IPv6 for simplicity
    if ! LC_ALL=C nmcli connection modify "$AP_CONNECTION_NAME" \
        ipv6.method disabled \
        2>&1; then
        log_warn "Failed to disable IPv6 on AP (non-fatal)"
    fi
    
    # NOTE: We intentionally do NOT set wifi-sec for open network
    # For WPA2, we would add:
    # nmcli connection modify "$AP_CONNECTION_NAME" \
    #     wifi-sec.key-mgmt wpa-psk \
    #     wifi-sec.psk "password123"
    
    log_info "AP connection profile created successfully"
    log_info "  SSID: $AP_SSID"
    log_info "  IP: ${AP_IP_ADDRESS}/${AP_IP_NETMASK}"
    log_info "  Security: Open (no password)"
    
    return 0
}

enable_ap_mode() {
    log_info "Enabling AP mode..."
    
    # Ensure AP connection profile exists
    if ! connection_exists "$AP_CONNECTION_NAME"; then
        if ! create_ap_connection_profile; then
            log_error "Failed to create AP connection profile"
            return 1
        fi
    fi
    
    # Disconnect any active WiFi connection first
    local active_conn
    active_conn=$(get_active_connection)
    if [[ -n "$active_conn" && "$active_conn" != "$AP_CONNECTION_NAME" ]]; then
        log_debug "Disconnecting from: $active_conn"
        LC_ALL=C nmcli connection down "$active_conn" 2>/dev/null || true
        sleep 2
    fi
    
    # Activate AP
    local nmcli_result
    local exit_code
    nmcli_result=$(LC_ALL=C nmcli --wait 30 connection up "$AP_CONNECTION_NAME" 2>&1) && exit_code=0 || exit_code=$?
    
    case $exit_code in
        $NMCLI_SUCCESS)
            log_info "AP mode enabled successfully"
            log_info "  SSID: $AP_SSID"
            log_info "  IP: $AP_IP_ADDRESS"
            log_info "  Connect to configure the device"
            CURRENT_MODE="ap"
            CURRENT_SSID="$AP_SSID"
            save_state
            return 0
            ;;
        $NMCLI_ACTIVATION_FAILED)
            log_error "Failed to activate AP mode: $nmcli_result"
            
            # Check for common issues
            if echo "$nmcli_result" | grep -qi "device.*busy"; then
                log_error "WiFi device is busy - may need to wait or restart NetworkManager"
            fi
            if echo "$nmcli_result" | grep -qi "not supported"; then
                log_error "AP mode may not be supported by this hardware"
            fi
            return 1
            ;;
        *)
            log_error "AP activation failed with code $exit_code: $nmcli_result"
            return 1
            ;;
    esac
}

disable_ap_mode() {
    log_info "Disabling AP mode..."
    
    if ! connection_exists "$AP_CONNECTION_NAME"; then
        log_debug "AP connection profile does not exist"
        return 0
    fi
    
    # Check if AP is currently active
    local active_conn
    active_conn=$(get_active_connection)
    
    if [[ "$active_conn" == "$AP_CONNECTION_NAME" ]]; then
        log_debug "Deactivating AP connection"
        local result
        result=$(LC_ALL=C nmcli connection down "$AP_CONNECTION_NAME" 2>&1) || true
        sleep 2
    fi
    
    if [[ "$CURRENT_MODE" == "ap" ]]; then
        CURRENT_MODE="disconnected"
        CURRENT_SSID=""
        save_state
    fi
    
    log_info "AP mode disabled"
    return 0
}

disable_ap_mode_if_active() {
    local active_conn
    active_conn=$(get_active_connection)
    
    if [[ "$active_conn" == "$AP_CONNECTION_NAME" ]]; then
        disable_ap_mode
    fi
}

is_ap_mode_active() {
    local active_conn
    active_conn=$(get_active_connection)
    [[ "$active_conn" == "$AP_CONNECTION_NAME" ]]
}

################################################################################
# NETWORK SELECTION AND FAILOVER
################################################################################

get_ordered_networks() {
    # Return networks in priority order:
    # 1. Primary SSID (if set)
    # 2. Other configured networks in order
    
    local -a ordered=()
    
    # Add primary first if set and exists in config
    if [[ -n "$PRIMARY_SSID" ]]; then
        for i in "${!CONFIGURED_SSIDS[@]}"; do
            if [[ "${CONFIGURED_SSIDS[$i]}" == "$PRIMARY_SSID" ]]; then
                ordered+=("$i")
                break
            fi
        done
    fi
    
    # Add remaining networks
    for i in "${!CONFIGURED_SSIDS[@]}"; do
        local already_added=false
        for j in "${ordered[@]:-}"; do
            if [[ "$j" == "$i" ]]; then
                already_added=true
                break
            fi
        done
        if ! $already_added; then
            ordered+=("$i")
        fi
    done
    
    echo "${ordered[*]:-}"
}

try_connect_to_configured_networks() {
    log_info "Attempting to connect to configured networks..."
    
    if [[ ${#CONFIGURED_SSIDS[@]} -eq 0 ]]; then
        log_warn "No WiFi networks configured"
        return 1
    fi
    
    local ordered
    ordered=$(get_ordered_networks)
    
    for idx in $ordered; do
        local ssid="${CONFIGURED_SSIDS[$idx]}"
        local password="${CONFIGURED_PASSWORDS[$idx]:-}"
        
        log_info "Trying network: $ssid"
        
        # Check if network is available (visible in scan)
        if ! is_network_available "$ssid"; then
            log_info "Network '$ssid' is not visible, skipping"
            continue
        fi
        
        # Attempt connection
        if connect_to_wifi "$ssid" "$password"; then
            # Verify internet connectivity
            sleep "$NETWORK_SWITCH_DELAY"
            if check_internet_connectivity; then
                log_info "Successfully connected to '$ssid' with internet access"
                return 0
            else
                log_warn "Connected to '$ssid' but no internet, trying next..."
                disconnect_wifi
            fi
        fi
    done
    
    log_error "Failed to connect to any configured network"
    return 1
}

################################################################################
# MAIN WATCHDOG LOGIC
################################################################################

handle_not_onboarded() {
    log_info "Device not onboarded - enabling AP mode for setup"
    
    if ! is_ap_mode_active; then
        if ! enable_ap_mode; then
            log_error "Failed to enable AP mode for onboarding"
            return 1
        fi
    fi
    
    log_info "Waiting for onboarding via web UI at http://${AP_IP_ADDRESS}"
    return 0
}

handle_onboarded() {
    log_debug "Checking network status..."
    
    # Get current connection state
    local active_ssid
    active_ssid=$(get_active_ssid)
    
    # If in AP mode, check if we should try to connect to WiFi
    if is_ap_mode_active; then
        log_info "Currently in AP mode, attempting to connect to configured WiFi..."
        
        if try_connect_to_configured_networks; then
            log_info "Successfully connected to WiFi, disabling AP mode"
            return 0
        else
            log_warn "Could not connect to any WiFi network, staying in AP mode"
            return 0
        fi
    fi
    
    # If connected to a WiFi network, verify connectivity
    if [[ -n "$active_ssid" ]]; then
        log_debug "Currently connected to: $active_ssid"
        
        if check_internet_connectivity; then
            log_debug "Internet connectivity OK on $active_ssid"
            CURRENT_MODE="wifi"
            CURRENT_SSID="$active_ssid"
            return 0
        else
            log_warn "No internet on current network: $active_ssid"
            log_info "Attempting to find a working network..."
            
            # Disconnect and try other networks
            disconnect_wifi
            
            if try_connect_to_configured_networks; then
                return 0
            fi
        fi
    else
        log_info "Not connected to any WiFi network"
        
        # Try to connect
        if try_connect_to_configured_networks; then
            return 0
        fi
    fi
    
    # All connection attempts failed - fall back to AP mode
    log_warn "All WiFi networks failed, falling back to AP mode"
    if enable_ap_mode; then
        log_info "AP mode enabled for reconfiguration"
    else
        log_error "Failed to enable AP mode"
    fi
    
    return 0
}

run_watchdog_cycle() {
    log_debug "Running watchdog cycle..."
    
    # Check if reload was requested
    if $RELOAD_REQUESTED; then
        log_info "Reloading configuration..."
        RELOAD_REQUESTED=false
        parse_config
    fi
    
    # Run appropriate handler based on onboarding status
    if [[ "$IS_ONBOARDED" != "true" ]]; then
        handle_not_onboarded
    else
        handle_onboarded
    fi
}

################################################################################
# MAIN ENTRY POINT
################################################################################

main() {
    log_info "=========================================="
    log_info "Tether Network Watchdog v${SCRIPT_VERSION}"
    log_info "=========================================="
    
    # Initialize
    init_directories
    setup_signal_handlers
    write_pid_file
    
    # Check prerequisites
    check_prerequisites
    
    # Load configuration
    if ! parse_config; then
        log_error "Failed to parse configuration"
        exit 4
    fi
    
    # Load previous state
    load_state
    
    # Ensure AP profile exists (will be needed eventually)
    if ! connection_exists "$AP_CONNECTION_NAME"; then
        log_info "Creating initial AP connection profile..."
        create_ap_connection_profile || log_warn "Failed to create AP profile (will retry)"
    fi
    
    # Initial run
    run_watchdog_cycle
    
    # Main loop
    log_info "Entering main watchdog loop (interval: ${CHECK_INTERVAL}s)"
    
    while ! $SHUTDOWN_REQUESTED; do
        sleep "$CHECK_INTERVAL" &
        wait $! || true  # Allow signals to interrupt sleep
        
        if $SHUTDOWN_REQUESTED; then
            break
        fi
        
        run_watchdog_cycle
    done
    
    log_info "Watchdog shutting down..."
}

# Run main if executed directly (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
```

---

## 2. NetworkManager Connection Profiles

### 2.1 Pre-Creating the AP Connection Profile

The AP connection profile should be created during image build (via sdm) or on first boot. There are two approaches:

**Option A: Using nmcli in sdm Phase 1 Script**

```bash
#!/bin/bash
# /usr/local/bin/tether-create-ap-profile.sh
# Run this during sdm image customization

# Create the AP connection profile
nmcli connection add \
    type wifi \
    ifname wlan0 \
    con-name "TetherSetup" \
    autoconnect no \
    ssid "TetherSetup" \
    mode ap

nmcli connection modify "TetherSetup" \
    802-11-wireless.band bg \
    802-11-wireless.channel 6 \
    ipv4.method shared \
    ipv4.addresses "192.168.4.1/24" \
    ipv6.method disabled

# Set low priority so it doesn't auto-activate
nmcli connection modify "TetherSetup" \
    connection.autoconnect no \
    connection.autoconnect-priority -999
```

**Option B: Pre-baked Connection File**

Create `/etc/NetworkManager/system-connections/TetherSetup.nmconnection`:

```ini
[connection]
id=TetherSetup
uuid=a1b2c3d4-e5f6-7890-abcd-ef1234567890
type=wifi
interface-name=wlan0
autoconnect=false
autoconnect-priority=-999

[wifi]
mode=ap
ssid=TetherSetup
band=bg
channel=6

[wifi-security]
key-mgmt=none

[ipv4]
method=shared
address1=192.168.4.1/24

[ipv6]
method=disabled

[proxy]
```

**File permissions (critical):**
```bash
chmod 600 /etc/NetworkManager/system-connections/TetherSetup.nmconnection
chown root:root /etc/NetworkManager/system-connections/TetherSetup.nmconnection
```

### 2.2 How Connections Are Added During Onboarding

The tether-server (Rust/axum) adds WiFi networks via the `/api/wifi/add` endpoint. Here is the implementation logic:

**Rust Implementation Pattern (in tether-server):**

```rust
// In tether-server/src/wifi.rs
use std::process::Command;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum WifiError {
    #[error("nmcli command failed: {0}")]
    NmcliError(String),
    #[error("NetworkManager not running")]
    NmNotRunning,
    #[error("Invalid SSID or password")]
    InvalidCredentials,
}

pub struct WifiManager;

impl WifiManager {
    /// Add a new WiFi connection profile
    pub fn add_network(ssid: &str, password: Option<&str>, priority: i32) -> Result<(), WifiError> {
        // Generate a connection name from SSID
        let conn_name = format!("tether-{}", ssid.replace(' ', "_"));
        
        // Build nmcli command
        let mut args = vec![
            "connection", "add",
            "type", "wifi",
            "ifname", "wlan0",
            "con-name", &conn_name,
            "ssid", ssid,
            "autoconnect", "yes",
        ];
        
        let output = Command::new("nmcli")
            .args(&args)
            .output()
            .map_err(|e| WifiError::NmcliError(e.to_string()))?;
        
        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            if stderr.contains("NetworkManager is not running") {
                return Err(WifiError::NmNotRunning);
            }
            return Err(WifiError::NmcliError(stderr.to_string()));
        }
        
        // Set password if provided
        if let Some(pwd) = password {
            let modify_result = Command::new("nmcli")
                .args([
                    "connection", "modify", &conn_name,
                    "wifi-sec.key-mgmt", "wpa-psk",
                    "wifi-sec.psk", pwd,
                ])
                .output()
                .map_err(|e| WifiError::NmcliError(e.to_string()))?;
            
            if !modify_result.status.success() {
                // Cleanup: delete the connection we just created
                let _ = Command::new("nmcli")
                    .args(["connection", "delete", &conn_name])
                    .output();
                return Err(WifiError::InvalidCredentials);
            }
        }
        
        // Set priority
        let priority_str = priority.to_string();
        let _ = Command::new("nmcli")
            .args([
                "connection", "modify", &conn_name,
                "connection.autoconnect-priority", &priority_str,
            ])
            .output();
        
        Ok(())
    }
    
    /// Connect to a specific network immediately
    pub fn connect_to(ssid: &str) -> Result<(), WifiError> {
        let conn_name = format!("tether-{}", ssid.replace(' ', "_"));
        
        let output = Command::new("nmcli")
            .args(["--wait", "30", "connection", "up", &conn_name])
            .output()
            .map_err(|e| WifiError::NmcliError(e.to_string()))?;
        
        if output.status.success() {
            Ok(())
        } else {
            Err(WifiError::NmcliError(
                String::from_utf8_lossy(&output.stderr).to_string()
            ))
        }
    }
    
    /// List available WiFi networks (scan results)
    pub fn scan_networks() -> Result<Vec<WifiNetwork>, WifiError> {
        // Force rescan
        let _ = Command::new("nmcli")
            .args(["device", "wifi", "rescan", "ifname", "wlan0"])
            .output();
        
        std::thread::sleep(std::time::Duration::from_secs(2));
        
        let output = Command::new("nmcli")
            .args(["-t", "-f", "SSID,SIGNAL,SECURITY", "device", "wifi", "list"])
            .output()
            .map_err(|e| WifiError::NmcliError(e.to_string()))?;
        
        let stdout = String::from_utf8_lossy(&output.stdout);
        let networks: Vec<WifiNetwork> = stdout
            .lines()
            .filter_map(|line| {
                let parts: Vec<&str> = line.split(':').collect();
                if parts.len() >= 3 && !parts[0].is_empty() {
                    Some(WifiNetwork {
                        ssid: parts[0].to_string(),
                        signal: parts[1].parse().unwrap_or(0),
                        security: parts[2].to_string(),
                    })
                } else {
                    None
                }
            })
            .collect();
        
        Ok(networks)
    }
}

#[derive(Debug, Clone, serde::Serialize)]
pub struct WifiNetwork {
    pub ssid: String,
    pub signal: i32,
    pub security: String,
}
```

### 2.3 Connection Priority Handling

NetworkManager uses `connection.autoconnect-priority` (range: -999 to 999, default: 0) to determine which connection to activate when multiple are available.

**Priority Strategy:**

| Connection Type | Priority Value | Rationale |
|----------------|----------------|-----------|
| Primary WiFi | 100 | Highest priority for user's preferred network |
| Secondary WiFi networks | 50 (decreasing) | Fallback options |
| AP Mode (TetherSetup) | -999 | Never auto-connect; only activated manually |

**Implementation in tether-server:**

```rust
// When setting primary network
pub fn set_primary_network(ssid: &str) -> Result<(), WifiError> {
    let conn_name = format!("tether-{}", ssid.replace(' ', "_"));
    
    // First, lower priority of all existing tether connections
    let connections = list_tether_connections()?;
    for conn in &connections {
        let _ = Command::new("nmcli")
            .args([
                "connection", "modify", conn,
                "connection.autoconnect-priority", "50",
            ])
            .output();
    }
    
    // Set new primary to high priority
    Command::new("nmcli")
        .args([
            "connection", "modify", &conn_name,
            "connection.autoconnect-priority", "100",
        ])
        .output()
        .map_err(|e| WifiError::NmcliError(e.to_string()))?;
    
    Ok(())
}

fn list_tether_connections() -> Result<Vec<String>, WifiError> {
    let output = Command::new("nmcli")
        .args(["-t", "-f", "NAME", "connection", "show"])
        .output()
        .map_err(|e| WifiError::NmcliError(e.to_string()))?;
    
    let stdout = String::from_utf8_lossy(&output.stdout);
    let connections: Vec<String> = stdout
        .lines()
        .filter(|name| name.starts_with("tether-"))
        .map(String::from)
        .collect();
    
    Ok(connections)
}
```

---

## 3. First-Boot Behavior

### 3.1 Complete First-Boot Sequence

The first-boot script runs before the watchdog and sets up the initial state:

```bash
#!/usr/bin/env bash
# /usr/local/bin/tether-first-boot.sh
# Run by systemd on first boot only

set -euo pipefail

readonly CONFIG_DIR="/etc/tether"
readonly CONFIG_FILE="${CONFIG_DIR}/config.toml"
readonly FIRST_BOOT_FLAG="/var/lib/tether/.first-boot-complete"
readonly LOG_FILE="/var/log/tether/first-boot.log"

log() {
    local timestamp
    timestamp=$(date -u '+%Y-%m-%dT%H:%M:%SZ')
    echo "${timestamp} $*" | tee -a "$LOG_FILE"
}

# Check if already completed
if [[ -f "$FIRST_BOOT_FLAG" ]]; then
    log "First boot already completed, skipping"
    exit 0
fi

log "Starting Tether first-boot setup..."

# Create directories
mkdir -p "$CONFIG_DIR"
mkdir -p "/var/lib/tether"
mkdir -p "/var/log/tether"

# Create initial configuration (not onboarded)
if [[ ! -f "$CONFIG_FILE" ]]; then
    log "Creating initial configuration..."
    cat > "$CONFIG_FILE" << 'EOF'
# Tether Configuration
# Generated on first boot

# Device onboarding status
onboarded = false

# Primary WiFi network SSID (set during onboarding)
# primary_ssid = ""

# Monthly pass configuration
passes_per_month = 3

# Bluetooth device to track (set during onboarding)
# bluetooth_device_address = ""
# bluetooth_rssi_threshold = -70

# Timezone (set during onboarding, auto-detected from network)
# timezone = "UTC"
EOF
    chmod 644 "$CONFIG_FILE"
fi

# Ensure AP connection profile exists
log "Ensuring AP connection profile exists..."
if ! nmcli connection show "TetherSetup" &>/dev/null; then
    log "Creating TetherSetup AP profile..."
    
    nmcli connection add \
        type wifi \
        ifname wlan0 \
        con-name "TetherSetup" \
        autoconnect no \
        ssid "TetherSetup" \
        mode ap
    
    nmcli connection modify "TetherSetup" \
        802-11-wireless.band bg \
        802-11-wireless.channel 6 \
        ipv4.method shared \
        ipv4.addresses "192.168.4.1/24" \
        ipv6.method disabled \
        connection.autoconnect-priority -999
    
    log "TetherSetup AP profile created"
else
    log "TetherSetup AP profile already exists"
fi

# Mark first boot complete
touch "$FIRST_BOOT_FLAG"
log "First boot setup complete"

# The watchdog service will handle enabling AP mode
```

### 3.2 First-Boot Systemd Service

```ini
# /etc/systemd/system/tether-first-boot.service

[Unit]
Description=Tether First Boot Setup
After=NetworkManager.service
Before=tether-network-watchdog.service
ConditionPathExists=!/var/lib/tether/.first-boot-complete

[Service]
Type=oneshot
ExecStart=/usr/local/bin/tether-first-boot.sh
RemainAfterExit=yes
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
```

### 3.3 AP Mode Configuration Details

| Setting | Value | Notes |
|---------|-------|-------|
| SSID | `TetherSetup` | Descriptive name visible to users |
| Security | None (open) | Simplifies first-time setup |
| IP Address | `192.168.4.1/24` | Device IP when in AP mode |
| DHCP Range | `192.168.4.10 - 192.168.4.254` | Managed by dnsmasq via `ipv4.method shared` |
| Channel | 6 | 2.4GHz, widely compatible |
| Band | bg | 2.4GHz for maximum compatibility |

**About DHCP with `ipv4.method shared`:**

When NetworkManager sets `ipv4.method shared`, it automatically:
1. Enables IP forwarding (`/proc/sys/net/ipv4/ip_forward`)
2. Starts an internal dnsmasq instance for DHCP
3. Sets up iptables/nftables NAT rules (if there's an upstream connection)

The DHCP range defaults to `.10` through `.254` of the configured subnet. To customize:

```bash
# Create dnsmasq configuration for NetworkManager
cat > /etc/NetworkManager/dnsmasq-shared.d/tether.conf << 'EOF'
# Custom DHCP range for TetherSetup AP
dhcp-range=192.168.4.50,192.168.4.150,24h
dhcp-option=option:router,192.168.4.1
dhcp-option=option:dns-server,192.168.4.1
EOF
```

---

## 4. Error Handling

### 4.1 NetworkManager Not Running

```bash
check_networkmanager_running() {
    # Primary check: systemd service status
    if ! systemctl is-active --quiet NetworkManager; then
        log_error "NetworkManager service is not active"
        
        # Check if service exists
        if ! systemctl list-unit-files | grep -q NetworkManager.service; then
            log_error "NetworkManager.service not found - is NetworkManager installed?"
            return 1
        fi
        
        # Check why it might be inactive
        local status
        status=$(systemctl is-enabled NetworkManager 2>/dev/null || echo "unknown")
        log_debug "NetworkManager enabled status: $status"
        
        # Attempt to start
        log_info "Attempting to start NetworkManager..."
        if systemctl start NetworkManager; then
            log_info "NetworkManager started successfully"
            sleep 3  # Wait for initialization
            
            # Verify it's now responding
            if nmcli general status &>/dev/null; then
                return 0
            else
                log_error "NetworkManager started but not responding"
                return 1
            fi
        else
            log_error "Failed to start NetworkManager"
            journalctl -u NetworkManager -n 20 --no-pager | while read -r line; do
                log_error "  NM Journal: $line"
            done
            return 1
        fi
    fi
    
    # Secondary check: nmcli responsiveness
    local nm_status
    if ! nm_status=$(LC_ALL=C nmcli general status 2>&1); then
        log_error "nmcli cannot communicate with NetworkManager: $nm_status"
        
        # Check D-Bus
        if ! dbus-send --system --dest=org.freedesktop.DBus \
            --type=method_call --print-reply \
            /org/freedesktop/DBus org.freedesktop.DBus.ListNames 2>/dev/null | \
            grep -q "org.freedesktop.NetworkManager"; then
            log_error "NetworkManager not registered on D-Bus"
        fi
        
        return 1
    fi
    
    return 0
}
```

### 4.2 WiFi Hardware Issues

```bash
check_wifi_hardware() {
    local errors=0
    
    # Check 1: Device exists
    if ! ip link show "$AP_INTERFACE" &>/dev/null; then
        log_error "WiFi interface $AP_INTERFACE does not exist"
        
        # List available interfaces
        log_debug "Available network interfaces:"
        ip link show | grep -E "^[0-9]+" | while read -r line; do
            log_debug "  $line"
        done
        
        # Check if driver loaded
        if ! lsmod | grep -qE "(brcmfmac|bcm2835)"; then
            log_error "WiFi driver may not be loaded"
            log_debug "Attempting to load brcmfmac..."
            modprobe brcmfmac 2>/dev/null || true
            sleep 2
        fi
        
        ((errors++))
    fi
    
    # Check 2: Device is recognized by NetworkManager
    local nm_device_status
    nm_device_status=$(LC_ALL=C nmcli -t -f DEVICE,TYPE,STATE device status 2>/dev/null | \
        grep "^${AP_INTERFACE}:" || true)
    
    if [[ -z "$nm_device_status" ]]; then
        log_error "WiFi interface not managed by NetworkManager"
        
        # Check if unmanaged
        if nmcli device show "$AP_INTERFACE" 2>/dev/null | grep -q "unmanaged"; then
            log_error "Device is set to unmanaged - check /etc/NetworkManager/conf.d/"
        fi
        
        ((errors++))
    else
        local device_state
        device_state=$(echo "$nm_device_status" | cut -d: -f3)
        log_debug "WiFi device state: $device_state"
        
        case "$device_state" in
            unavailable)
                log_error "WiFi device is unavailable (possibly RF-kill or hardware switch)"
                
                # Check RF-kill
                if command -v rfkill &>/dev/null; then
                    log_debug "RF-kill status:"
                    rfkill list wifi | while read -r line; do
                        log_debug "  $line"
                    done
                    
                    # Attempt to unblock
                    if rfkill list wifi | grep -q "Soft blocked: yes"; then
                        log_info "Attempting to unblock WiFi..."
                        rfkill unblock wifi
                        sleep 2
                    fi
                fi
                ((errors++))
                ;;
            disconnected|activated|connecting)
                log_debug "WiFi device is available"
                ;;
            *)
                log_warn "Unexpected WiFi device state: $device_state"
                ;;
        esac
    fi
    
    # Check 3: WiFi radio enabled
    local wifi_radio
    wifi_radio=$(LC_ALL=C nmcli radio wifi)
    
    if [[ "$wifi_radio" != "enabled" ]]; then
        log_warn "WiFi radio is $wifi_radio, attempting to enable..."
        
        if nmcli radio wifi on; then
            log_info "WiFi radio enabled"
            sleep 2
        else
            log_error "Failed to enable WiFi radio"
            ((errors++))
        fi
    fi
    
    # Check 4: AP mode support (important for this use case)
    # This is harder to detect, but we can try
    if command -v iw &>/dev/null; then
        local phy
        phy=$(iw dev "$AP_INTERFACE" info 2>/dev/null | grep wiphy | awk '{print $2}')
        if [[ -n "$phy" ]]; then
            if ! iw phy "phy${phy}" info 2>/dev/null | grep -q "* AP"; then
                log_warn "AP mode may not be supported by this hardware"
            else
                log_debug "AP mode is supported"
            fi
        fi
    fi
    
    if [[ $errors -gt 0 ]]; then
        log_error "WiFi hardware check failed with $errors errors"
        return 1
    fi
    
    return 0
}
```

### 4.3 Configuration File Missing or Invalid

```bash
parse_config() {
    log_info "Loading configuration from $CONFIG_FILE"
    
    # Reset to defaults
    CONFIGURED_SSIDS=()
    CONFIGURED_PASSWORDS=()
    IS_ONBOARDED="false"
    PRIMARY_SSID=""
    
    # Check file exists
    if [[ ! -f "$CONFIG_FILE" ]]; then
        log_warn "Configuration file not found: $CONFIG_FILE"
        log_info "Creating default configuration..."
        
        mkdir -p "$(dirname "$CONFIG_FILE")"
        cat > "$CONFIG_FILE" << 'EOF'
# Tether Configuration
# Auto-generated due to missing config file

onboarded = false
passes_per_month = 3
EOF
        chmod 644 "$CONFIG_FILE"
        log_info "Default configuration created"
        return 0
    fi
    
    # Check file readable
    if [[ ! -r "$CONFIG_FILE" ]]; then
        log_error "Cannot read configuration file: $CONFIG_FILE"
        log_error "Check file permissions (should be readable by root)"
        ls -la "$CONFIG_FILE" 2>/dev/null | while read -r line; do
            log_error "  $line"
        done
        return 1
    fi
    
    # Check file not empty
    if [[ ! -s "$CONFIG_FILE" ]]; then
        log_warn "Configuration file is empty: $CONFIG_FILE"
        log_info "Assuming not onboarded"
        return 0
    fi
    
    # Validate TOML syntax (basic check)
    local line_number=0
    local parse_errors=0
    
    while IFS= read -r line || [[ -n "$line" ]]; do
        ((line_number++))
        
        # Skip empty lines and comments
        local trimmed
        trimmed=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        [[ -z "$trimmed" ]] && continue
        [[ "$trimmed" =~ ^# ]] && continue
        
        # Check for valid TOML patterns
        if [[ "$trimmed" =~ ^\[.*\]$ ]]; then
            # Section header - valid
            continue
        elif [[ "$trimmed" =~ ^[a-zA-Z_][a-zA-Z0-9_]*[[:space:]]*= ]]; then
            # Key = value - valid
            continue
        else
            log_warn "Potentially invalid TOML at line $line_number: $trimmed"
            ((parse_errors++))
        fi
    done < "$CONFIG_FILE"
    
    if [[ $parse_errors -gt 5 ]]; then
        log_error "Configuration file has too many syntax issues"
        return 1
    fi
    
    # Actual parsing (same as before)
    local in_wifi_section=false
    local current_ssid=""
    local current_password=""
    
    while IFS= read -r line || [[ -n "$line" ]]; do
        line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        
        [[ -z "$line" ]] && continue
        [[ "$line" =~ ^# ]] && continue
        
        if [[ "$line" == "[[wifi_networks]]" ]]; then
            if [[ -n "$current_ssid" ]]; then
                CONFIGURED_SSIDS+=("$current_ssid")
                CONFIGURED_PASSWORDS+=("$current_password")
            fi
            in_wifi_section=true
            current_ssid=""
            current_password=""
            continue
        fi
        
        if [[ "$line" =~ ^\[.*\]$ && "$line" != "[[wifi_networks]]" ]]; then
            if [[ -n "$current_ssid" ]]; then
                CONFIGURED_SSIDS+=("$current_ssid")
                CONFIGURED_PASSWORDS+=("$current_password")
                current_ssid=""
                current_password=""
            fi
            in_wifi_section=false
            continue
        fi
        
        if [[ "$line" =~ ^([a-zA-Z_][a-zA-Z0-9_]*)\ *=\ *(.+)$ ]]; then
            local key="${BASH_REMATCH[1]}"
            local value="${BASH_REMATCH[2]}"
            value=$(echo "$value" | sed 's/^"//;s/"$//' | sed "s/^'//;s/'$//")
            
            if $in_wifi_section; then
                case "$key" in
                    ssid) current_ssid="$value" ;;
                    password) current_password="$value" ;;
                esac
            else
                case "$key" in
                    onboarded) IS_ONBOARDED="$value" ;;
                    primary_ssid) PRIMARY_SSID="$value" ;;
                esac
            fi
        fi
    done < "$CONFIG_FILE"
    
    # Save last network if exists
    if [[ -n "$current_ssid" ]]; then
        CONFIGURED_SSIDS+=("$current_ssid")
        CONFIGURED_PASSWORDS+=("$current_password")
    fi
    
    log_info "Configuration loaded successfully"
    log_info "  onboarded: $IS_ONBOARDED"
    log_info "  primary_ssid: ${PRIMARY_SSID:-<none>}"
    log_info "  wifi_networks: ${#CONFIGURED_SSIDS[@]}"
    
    return 0
}
```

---

## 5. Integration with tether-server

### 5.1 How Server Adds WiFi Networks

**API Endpoint:**

```rust
// In tether-server/src/routes/wifi.rs

use axum::{
    extract::State,
    http::StatusCode,
    Json,
};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

#[derive(Debug, Deserialize, ToSchema)]
pub struct AddWifiRequest {
    /// The SSID of the WiFi network to add
    #[schema(example = "HomeNetwork")]
    pub ssid: String,
    
    /// The password for the network (optional for open networks)
    #[schema(example = "mysecurepassword")]
    pub password: Option<String>,
    
    /// Whether this should be the primary network
    #[schema(default = false)]
    pub set_as_primary: Option<bool>,
}

#[derive(Debug, Serialize, ToSchema)]
pub struct AddWifiResponse {
    /// Whether the network was added successfully
    pub success: bool,
    /// The connection profile name created
    pub connection_name: String,
    /// Any warning or info message
    pub message: Option<String>,
}

/// Add a new WiFi network configuration
#[utoipa::path(
    post,
    path = "/api/wifi/add",
    request_body = AddWifiRequest,
    responses(
        (status = 200, description = "Network added successfully", body = AddWifiResponse),
        (status = 400, description = "Invalid request"),
        (status = 500, description = "Failed to add network")
    ),
    tag = "wifi"
)]
pub async fn add_wifi_network(
    State(app_state): State<AppState>,
    Json(req): Json<AddWifiRequest>,
) -> Result<Json<AddWifiResponse>, (StatusCode, String)> {
    // Validate SSID
    if req.ssid.is_empty() || req.ssid.len() > 32 {
        return Err((StatusCode::BAD_REQUEST, "Invalid SSID".to_string()));
    }
    
    // Determine priority
    let priority = if req.set_as_primary.unwrap_or(false) { 100 } else { 50 };
    
    // Add to NetworkManager
    let conn_name = format!("tether-{}", req.ssid.replace(' ', "_"));
    
    match add_nm_connection(&req.ssid, req.password.as_deref(), priority) {
        Ok(_) => {
            // Update config file
            if let Err(e) = update_config_file(&req.ssid, req.password.as_deref(), req.set_as_primary.unwrap_or(false)).await {
                tracing::warn!("Failed to update config file: {}", e);
            }
            
            // Signal watchdog to reconnect if this is primary
            if req.set_as_primary.unwrap_or(false) {
                signal_watchdog_reload();
            }
            
            Ok(Json(AddWifiResponse {
                success: true,
                connection_name: conn_name,
                message: Some("Network added. Connect to it from the Settings page.".to_string()),
            }))
        }
        Err(e) => {
            Err((StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
        }
    }
}

fn add_nm_connection(ssid: &str, password: Option<&str>, priority: i32) -> Result<(), WifiError> {
    let conn_name = format!("tether-{}", ssid.replace(' ', "_"));
    
    // Delete existing connection with same name (if any)
    let _ = std::process::Command::new("nmcli")
        .args(["connection", "delete", &conn_name])
        .output();
    
    // Create new connection
    let mut add_cmd = std::process::Command::new("nmcli");
    add_cmd.args([
        "connection", "add",
        "type", "wifi",
        "ifname", "wlan0",
        "con-name", &conn_name,
        "ssid", ssid,
        "autoconnect", "yes",
    ]);
    
    let output = add_cmd.output()?;
    if !output.status.success() {
        return Err(WifiError::NmcliError(
            String::from_utf8_lossy(&output.stderr).to_string()
        ));
    }
    
    // Set security if password provided
    if let Some(pwd) = password {
        let sec_output = std::process::Command::new("nmcli")
            .args([
                "connection", "modify", &conn_name,
                "wifi-sec.key-mgmt", "wpa-psk",
                "wifi-sec.psk", pwd,
            ])
            .output()?;
        
        if !sec_output.status.success() {
            // Cleanup
            let _ = std::process::Command::new("nmcli")
                .args(["connection", "delete", &conn_name])
                .output();
            return Err(WifiError::InvalidCredentials);
        }
    }
    
    // Set priority
    let priority_str = priority.to_string();
    let _ = std::process::Command::new("nmcli")
        .args([
            "connection", "modify", &conn_name,
            "connection.autoconnect-priority", &priority_str,
        ])
        .output();
    
    Ok(())
}
```

### 5.2 How Networks Are Persisted

Networks are persisted in two places:

1. **NetworkManager connection profiles** (`/etc/NetworkManager/system-connections/*.nmconnection`)
   - This is the authoritative source for connection details
   - Managed entirely by NetworkManager

2. **Tether config file** (`/etc/tether/config.toml`)
   - Records which networks are configured for Tether
   - Stores priority order and primary network designation
   - Used by the watchdog for failover logic

**Config File Update Function:**

```rust
// In tether-server/src/config.rs

use tokio::fs;
use std::path::Path;

const CONFIG_PATH: &str = "/etc/tether/config.toml";

pub async fn update_config_file(
    ssid: &str,
    password: Option<&str>,
    is_primary: bool,
) -> Result<(), ConfigError> {
    let config_path = Path::new(CONFIG_PATH);
    
    // Read existing config
    let mut content = if config_path.exists() {
        fs::read_to_string(config_path).await?
    } else {
        String::from("onboarded = false\n")
    };
    
    // Check if this SSID already exists
    let ssid_pattern = format!("ssid = \"{}\"", ssid);
    if content.contains(&ssid_pattern) {
        // Update existing entry (simplified - real impl would parse TOML properly)
        tracing::debug!("Network {} already in config", ssid);
    } else {
        // Append new network
        content.push_str(&format!("\n[[wifi_networks]]\n"));
        content.push_str(&format!("ssid = \"{}\"\n", ssid));
        if let Some(pwd) = password {
            content.push_str(&format!("password = \"{}\"\n", pwd));
        }
    }
    
    // Update primary if requested
    if is_primary {
        // Remove existing primary_ssid line if present
        let lines: Vec<&str> = content.lines()
            .filter(|line| !line.starts_with("primary_ssid"))
            .collect();
        content = lines.join("\n");
        
        // Add at the beginning after onboarded
        if let Some(pos) = content.find("onboarded") {
            if let Some(newline_pos) = content[pos..].find('\n') {
                let insert_pos = pos + newline_pos + 1;
                content.insert_str(insert_pos, &format!("primary_ssid = \"{}\"\n", ssid));
            }
        }
    }
    
    // Write back
    fs::write(config_path, &content).await?;
    
    Ok(())
}
```

### 5.3 Triggering Watchdog to Reconnect

The tether-server can trigger the watchdog to immediately check connectivity and potentially switch networks via two mechanisms:

**Mechanism 1: SIGHUP Signal**

```rust
// In tether-server/src/watchdog.rs

use std::fs;
use nix::sys::signal::{kill, Signal};
use nix::unistd::Pid;

const WATCHDOG_PID_FILE: &str = "/run/tether-network-watchdog.pid";

/// Signal the watchdog to reload configuration and check connectivity
pub fn signal_watchdog_reload() {
    match fs::read_to_string(WATCHDOG_PID_FILE) {
        Ok(pid_str) => {
            if let Ok(pid) = pid_str.trim().parse::<i32>() {
                match kill(Pid::from_raw(pid), Signal::SIGHUP) {
                    Ok(_) => {
                        tracing::info!("Sent SIGHUP to watchdog (PID {})", pid);
                    }
                    Err(e) => {
                        tracing::warn!("Failed to signal watchdog: {}", e);
                    }
                }
            }
        }
        Err(e) => {
            tracing::warn!("Could not read watchdog PID file: {}", e);
        }
    }
}
```

**Mechanism 2: Direct Connection Activation (Immediate)**

```rust
// For immediate connection without waiting for watchdog cycle
pub async fn connect_to_network_now(ssid: &str) -> Result<(), WifiError> {
    let conn_name = format!("tether-{}", ssid.replace(' ', "_"));
    
    // First, bring down current connection
    let _ = std::process::Command::new("nmcli")
        .args(["device", "disconnect", "wlan0"])
        .output();
    
    tokio::time::sleep(std::time::Duration::from_secs(2)).await;
    
    // Activate the new connection
    let output = std::process::Command::new("nmcli")
        .args(["--wait", "30", "connection", "up", &conn_name])
        .output()?;
    
    if output.status.success() {
        // Also signal watchdog to update its state
        signal_watchdog_reload();
        Ok(())
    } else {
        Err(WifiError::NmcliError(
            String::from_utf8_lossy(&output.stderr).to_string()
        ))
    }
}
```

**API Endpoint for Triggering Reconnection:**

```rust
/// Trigger the network watchdog to reconnect
#[utoipa::path(
    post,
    path = "/api/wifi/reconnect",
    responses(
        (status = 200, description = "Reconnect triggered"),
        (status = 500, description = "Failed to trigger reconnect")
    ),
    tag = "wifi"
)]
pub async fn trigger_reconnect() -> Result<(), (StatusCode, String)> {
    signal_watchdog_reload();
    Ok(())
}

/// Connect to a specific network immediately
#[utoipa::path(
    post,
    path = "/api/wifi/connect",
    request_body = ConnectRequest,
    responses(
        (status = 200, description = "Connection initiated"),
        (status = 400, description = "Invalid SSID"),
        (status = 500, description = "Connection failed")
    ),
    tag = "wifi"
)]
pub async fn connect_to_wifi(
    Json(req): Json<ConnectRequest>,
) -> Result<Json<ConnectResponse>, (StatusCode, String)> {
    match connect_to_network_now(&req.ssid).await {
        Ok(_) => Ok(Json(ConnectResponse {
            success: true,
            message: format!("Connecting to {}", req.ssid),
        })),
        Err(e) => Err((StatusCode::INTERNAL_SERVER_ERROR, e.to_string())),
    }
}
```

---

## 6. Systemd Service File for Watchdog

```ini
# /etc/systemd/system/tether-network-watchdog.service

[Unit]
Description=Tether Network Watchdog
Documentation=https://github.com/yourusername/tether
After=network.target NetworkManager.service
Wants=NetworkManager.service
Before=tether-server.service

[Service]
Type=simple
ExecStart=/usr/local/bin/tether-network-watchdog.sh
Restart=always
RestartSec=10
StandardOutput=journal
StandardError=journal
SyslogIdentifier=tether-watchdog

# Security hardening
NoNewPrivileges=false
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/var/log/tether /var/lib/tether /etc/tether /run
PrivateTmp=true

# Allow network operations
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_RAW
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_RAW

# Environment
Environment=LOG_LEVEL=1

[Install]
WantedBy=multi-user.target
```

---

## 7. NetworkManager Dispatcher Script (Optional Enhancement)

For faster response to network events, add a dispatcher script:

```bash
#!/usr/bin/env bash
# /etc/NetworkManager/dispatcher.d/99-tether-notify
# Notify tether-server when network state changes

readonly INTERFACE="$1"
readonly ACTION="$2"
readonly TETHER_SERVER_URL="http://127.0.0.1:3000"

# Only care about wlan0
[[ "$INTERFACE" != "wlan0" ]] && exit 0

case "$ACTION" in
    up)
        # Network connected - notify server
        curl -s -X POST "${TETHER_SERVER_URL}/api/internal/network-event" \
            -H "Content-Type: application/json" \
            -d "{\"event\": \"connected\", \"interface\": \"$INTERFACE\", \"connection\": \"$CONNECTION_ID\"}" \
            2>/dev/null || true
        ;;
    down)
        # Network disconnected - notify server
        curl -s -X POST "${TETHER_SERVER_URL}/api/internal/network-event" \
            -H "Content-Type: application/json" \
            -d "{\"event\": \"disconnected\", \"interface\": \"$INTERFACE\"}" \
            2>/dev/null || true
        ;;
    connectivity-change)
        # Connectivity state changed
        curl -s -X POST "${TETHER_SERVER_URL}/api/internal/network-event" \
            -H "Content-Type: application/json" \
            -d "{\"event\": \"connectivity-change\", \"state\": \"$CONNECTIVITY_STATE\"}" \
            2>/dev/null || true
        ;;
esac

exit 0
```

**Permissions:**
```bash
chmod 755 /etc/NetworkManager/dispatcher.d/99-tether-notify
chown root:root /etc/NetworkManager/dispatcher.d/99-tether-notify
```

---

## 8. Complete nmcli Command Reference

### Connection Management

| Command | Description | Exit Codes |
|---------|-------------|------------|
| `nmcli connection show` | List all connections | 0=success |
| `nmcli connection show --active` | List active connections | 0=success |
| `nmcli connection up "name"` | Activate connection | 0=success, 4=failed |
| `nmcli connection down "name"` | Deactivate connection | 0=success, 5=failed |
| `nmcli connection add type wifi ...` | Create connection | 0=success |
| `nmcli connection modify "name" key val` | Modify connection | 0=success |
| `nmcli connection delete "name"` | Delete connection | 0=success, 7=failed |
| `nmcli --wait N connection up "name"` | Activate with timeout | 3=timeout |

### Device Management

| Command | Description |
|---------|-------------|
| `nmcli device status` | Show all devices |
| `nmcli device wifi list` | List visible WiFi networks |
| `nmcli device wifi rescan` | Force WiFi scan |
| `nmcli device wifi connect "ssid"` | Connect to WiFi |
| `nmcli device disconnect wlan0` | Disconnect device |

### Radio Control

| Command | Description |
|---------|-------------|
| `nmcli radio wifi` | Show WiFi radio state |
| `nmcli radio wifi on` | Enable WiFi radio |
| `nmcli radio wifi off` | Disable WiFi radio |

### Connectivity

| Command | Description |
|---------|-------------|
| `nmcli networking connectivity` | Show connectivity state |
| `nmcli networking connectivity check` | Force connectivity check |

---

### Critical Files for Implementation

- `/Users/jeffrey/code/tether/scripts/tether-network-watchdog.sh` - The complete watchdog script (to be created)
- `/Users/jeffrey/code/tether/scripts/tether-first-boot.sh` - First-boot initialization script (to be created)  
- `/Users/jeffrey/code/tether/tether-server/src/wifi.rs` - WiFi management module in Rust server (to be created)
- `/Users/jeffrey/code/tether/systemd/tether-network-watchdog.service` - Systemd service definition (to be created)
- `/Users/jeffrey/code/tether/claude-spec.md` - Project specification with network requirements context

**Sources:**

- [Create Wi-Fi Hotspot on Linux using nmcli - GitHub Gist](https://gist.github.com/narate/d3f001c97e1c981a59f94cd76f041140)
- [nmcli for WiFi on Raspberry Pi OS 12 'Bookworm' - Jeff Geerling](https://www.jeffgeerling.com/blog/2023/nmcli-wifi-on-raspberry-pi-os-12-bookworm)
- [NetworkManager connection priority - Alauda.ro](https://www.alauda.ro/2025/08/networkmanager-connection-priority/)
- [Changing Wi-Fi Network Connection Priority Order in Linux - Baeldung](https://www.baeldung.com/linux/wifi-connection-priority-order)
- [NetworkManager-dispatcher Reference Manual](https://networkmanager.dev/docs/api/latest/NetworkManager-dispatcher.html)
- [nmcli NetworkManager Reference Manual](https://networkmanager.dev/docs/api/latest/nmcli.html)
- [Captive Portal Detection URLs - Scientific Computing](https://www.scivision.dev/android-captive-hotspot-connected-no-internet/)
- [bash-toml - Pure Bash TOML Parser](https://github.com/bash-bastion/bash-toml)
- [SIGHUP for Configuration Reload - LinuxVox](https://linuxvox.com/blog/sighup-for-reloading-configuration/)
