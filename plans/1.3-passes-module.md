Now I have complete context. This is a new Rust project for a Raspberry Pi-based phone accountability system. Let me provide the complete, detailed implementation plan for `passes.rs`.

---

# Implementation Plan: `tether-core/src/passes.rs`

## Overview

This module manages monthly accountability passes with JSON persistence. It handles automatic monthly resets, tracks usage history by month, and supports deferred configuration changes.

## File Location

```
/Users/jeffrey/code/tether/tether-core/src/passes.rs
```

## Dependencies (for Cargo.toml)

The parent crate (`tether-core`) must include these dependencies:

```toml
[dependencies]
chrono = { version = "0.4", features = ["serde"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
thiserror = "1.0"
```

---

## Complete Implementation

```rust
//! Pass management for monthly accountability passes.
//!
//! This module provides functionality for tracking and managing monthly passes
//! that users can "use" when they need to keep their phone with them at night.
//! Passes automatically reset at the beginning of each month.
//!
//! # Thread Safety
//!
//! `PassManager` is designed to be wrapped in an `std::sync::RwLock` or
//! `tokio::sync::RwLock` for concurrent access. All mutating operations
//! (`use_pass`, `maybe_reset_month`) modify internal state and require
//! exclusive access.
//!
//! # Persistence
//!
//! Data is stored in JSON format at the configured path. The file is
//! atomically updated on each mutation to prevent corruption.
//!
//! # Example
//!
//! ```no_run
//! use tether_core::passes::PassManager;
//! use std::path::PathBuf;
//!
//! let path = PathBuf::from("/var/lib/tether/passes.json");
//! let mut manager = PassManager::load_or_create(&path, 3)?;
//!
//! // Check remaining passes
//! println!("Remaining: {}", manager.remaining());
//!
//! // Use a pass
//! manager.use_pass("Medical appointment tonight".to_string())?;
//!
//! // View history
//! let history = manager.history("2025-01");
//! for entry in history {
//!     println!("{}: {}", entry.used_at_utc, entry.reason);
//! }
//! # Ok::<(), tether_core::passes::PassError>(())
//! ```

use chrono::{DateTime, Datelike, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs;
use std::io;
use std::path::{Path, PathBuf};

// ============================================================================
// ERROR TYPES
// ============================================================================

/// Errors that can occur during pass operations.
#[derive(Debug, thiserror::Error)]
pub enum PassError {
    /// No passes remaining for the current month.
    #[error("no passes remaining for {month} (0 of {max} available)")]
    NoPassesRemaining {
        /// The current month in YYYY-MM format.
        month: String,
        /// The maximum passes allowed per month.
        max: u32,
    },

    /// Failed to read the passes data file.
    #[error("failed to read passes file at {path}: {source}")]
    ReadError {
        /// The path that failed to read.
        path: PathBuf,
        /// The underlying IO error.
        #[source]
        source: io::Error,
    },

    /// Failed to write the passes data file.
    #[error("failed to write passes file at {path}: {source}")]
    WriteError {
        /// The path that failed to write.
        path: PathBuf,
        /// The underlying IO error.
        #[source]
        source: io::Error,
    },

    /// Failed to parse the passes data file as JSON.
    #[error("failed to parse passes file at {path}: {source}")]
    ParseError {
        /// The path that failed to parse.
        path: PathBuf,
        /// The underlying JSON error.
        #[source]
        source: serde_json::Error,
    },

    /// Failed to serialize passes data to JSON.
    #[error("failed to serialize passes data: {0}")]
    SerializeError(#[from] serde_json::Error),

    /// Failed to create parent directory for passes file.
    #[error("failed to create parent directory for {path}: {source}")]
    CreateDirError {
        /// The path whose parent directory failed to create.
        path: PathBuf,
        /// The underlying IO error.
        #[source]
        source: io::Error,
    },

    /// The reason provided for using a pass was empty.
    #[error("reason cannot be empty when using a pass")]
    EmptyReason,

    /// The reason provided exceeds the maximum allowed length.
    #[error("reason exceeds maximum length of {max} characters (got {actual})")]
    ReasonTooLong {
        /// Maximum allowed length.
        max: usize,
        /// Actual length provided.
        actual: usize,
    },
}

/// Result type alias for pass operations.
pub type PassResult<T> = Result<T, PassError>;

// ============================================================================
// DATA STRUCTURES
// ============================================================================

/// Maximum allowed length for a pass reason.
pub const MAX_REASON_LENGTH: usize = 500;

/// Represents a single pass usage entry.
///
/// Each entry records when a pass was used and the reason provided by the user.
/// The timestamp is always in UTC to avoid timezone ambiguity.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct PassEntry {
    /// The UTC timestamp when the pass was used, in RFC 3339 format.
    ///
    /// Example: "2025-01-15T03:45:00Z"
    ///
    /// The `_utc` suffix explicitly indicates the timezone to prevent confusion.
    pub used_at_utc: DateTime<Utc>,

    /// The reason provided by the user for using this pass.
    ///
    /// This is a free-form string with a maximum length of 500 characters.
    /// Examples:
    /// - "Medical appointment in the morning"
    /// - "On-call for work emergency"
    /// - "Traveling, need alarm on phone"
    pub reason: String,
}

impl PassEntry {
    /// Creates a new pass entry with the current UTC timestamp.
    ///
    /// # Arguments
    ///
    /// * `reason` - The reason for using this pass.
    ///
    /// # Returns
    ///
    /// A new `PassEntry` with `used_at_utc` set to the current time.
    fn new(reason: String) -> Self {
        Self {
            used_at_utc: Utc::now(),
            reason,
        }
    }

    /// Creates a pass entry with a specific timestamp (for testing).
    #[cfg(test)]
    fn with_timestamp(used_at_utc: DateTime<Utc>, reason: String) -> Self {
        Self {
            used_at_utc,
            reason,
        }
    }
}

/// The persisted data structure for pass management.
///
/// This struct is serialized to and from JSON for persistence.
/// It contains all information needed to track passes across months.
///
/// # JSON Format
///
/// ```json
/// {
///   "current_month": "2025-01",
///   "remaining": 2,
///   "per_month": 3,
///   "pending_per_month": null,
///   "history": {
///     "2024-12": [
///       {
///         "used_at_utc": "2024-12-25T08:30:00Z",
///         "reason": "Christmas morning"
///       }
///     ],
///     "2025-01": [
///       {
///         "used_at_utc": "2025-01-02T04:15:00Z",
///         "reason": "Sick, needed phone for alarm"
///       }
///     ]
///   }
/// }
/// ```
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct PassData {
    /// The current month in "YYYY-MM" format (e.g., "2025-01").
    ///
    /// This is used to detect month changes and trigger pass resets.
    pub current_month: String,

    /// The number of passes remaining for the current month.
    ///
    /// This value decrements when a pass is used and resets to `per_month`
    /// (or `pending_per_month` if set) at the start of each month.
    pub remaining: u32,

    /// The number of passes granted per month.
    ///
    /// This is the active configuration. When changed mid-month, the change
    /// is stored in `pending_per_month` and applied at the next month reset.
    pub per_month: u32,

    /// Pending per-month value to apply at the next month reset.
    ///
    /// When the user changes the passes-per-month configuration mid-month,
    /// the new value is stored here and only takes effect at the start of
    /// the next month. This prevents gaming the system by increasing passes
    /// mid-month.
    ///
    /// Set to `None` if no change is pending.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pending_per_month: Option<u32>,

    /// Historical pass usage organized by month.
    ///
    /// Keys are in "YYYY-MM" format (e.g., "2024-12", "2025-01").
    /// Values are vectors of `PassEntry` in chronological order.
    ///
    /// This allows efficient lookup of pass history for any given month.
    /// Old months are preserved indefinitely for audit purposes.
    #[serde(default)]
    pub history: HashMap<String, Vec<PassEntry>>,
}

impl PassData {
    /// Creates new pass data for a fresh start.
    ///
    /// # Arguments
    ///
    /// * `per_month` - The number of passes to grant per month.
    ///
    /// # Returns
    ///
    /// A new `PassData` with:
    /// - `current_month` set to the current UTC month
    /// - `remaining` set to `per_month`
    /// - Empty history
    fn new(per_month: u32) -> Self {
        Self {
            current_month: current_month_string(),
            remaining: per_month,
            per_month,
            pending_per_month: None,
            history: HashMap::new(),
        }
    }
}

impl Default for PassData {
    /// Creates default pass data with 0 passes per month.
    ///
    /// This is primarily used for deserialization fallbacks.
    /// In practice, you should use `PassData::new(per_month)`.
    fn default() -> Self {
        Self::new(0)
    }
}

// ============================================================================
// PASS MANAGER
// ============================================================================

/// Manages monthly accountability passes with JSON persistence.
///
/// `PassManager` provides the core business logic for:
/// - Loading and saving pass data to a JSON file
/// - Automatically resetting passes at the start of each month
/// - Tracking pass usage with reasons
/// - Querying pass history by month
///
/// # Thread Safety
///
/// `PassManager` is **not** internally thread-safe. It is designed to be
/// wrapped in an `RwLock` for concurrent access:
///
/// ```no_run
/// use std::sync::RwLock;
/// use tether_core::passes::PassManager;
/// use std::path::PathBuf;
///
/// let manager = PassManager::load_or_create(
///     &PathBuf::from("/var/lib/tether/passes.json"),
///     3
/// )?;
/// let shared = RwLock::new(manager);
///
/// // Reading (multiple readers allowed)
/// {
///     let guard = shared.read().unwrap();
///     println!("Remaining: {}", guard.remaining());
/// }
///
/// // Writing (exclusive access)
/// {
///     let mut guard = shared.write().unwrap();
///     guard.use_pass("Emergency".to_string())?;
/// }
/// # Ok::<(), tether_core::passes::PassError>(())
/// ```
///
/// # Persistence Model
///
/// All mutations (`use_pass`, `maybe_reset_month`) automatically persist
/// changes to the JSON file. The write is atomic (write to temp file,
/// then rename) to prevent corruption on crash.
///
/// # Month Change Behavior
///
/// On any operation, `PassManager` checks if the month has changed.
/// If so, it:
/// 1. Applies any `pending_per_month` configuration
/// 2. Resets `remaining` to the (possibly updated) `per_month` value
/// 3. Updates `current_month` to the new month
/// 4. Persists the changes
#[derive(Debug)]
pub struct PassManager {
    /// The path to the JSON file for persistence.
    path: PathBuf,

    /// The current pass data.
    data: PassData,
}

impl PassManager {
    /// Loads pass data from disk or creates a new file if none exists.
    ///
    /// This is the primary constructor for `PassManager`. It handles:
    /// - Loading existing data from the JSON file
    /// - Creating a new file with default data if none exists
    /// - Automatically resetting passes if the month has changed
    /// - Creating parent directories if they don't exist
    ///
    /// # Arguments
    ///
    /// * `path` - Path to the JSON file for persistence.
    /// * `per_month` - The number of passes to grant per month. This is used
    ///   when creating a new file. For existing files, this parameter is
    ///   ignored (the stored `per_month` value takes precedence).
    ///
    /// # Returns
    ///
    /// A `PassManager` ready for use.
    ///
    /// # Errors
    ///
    /// - `PassError::ReadError` - Failed to read the file (other than not found)
    /// - `PassError::ParseError` - File exists but contains invalid JSON
    /// - `PassError::CreateDirError` - Failed to create parent directories
    /// - `PassError::WriteError` - Failed to write initial data
    ///
    /// # Example
    ///
    /// ```no_run
    /// use tether_core::passes::PassManager;
    /// use std::path::PathBuf;
    ///
    /// let path = PathBuf::from("/var/lib/tether/passes.json");
    /// let manager = PassManager::load_or_create(&path, 3)?;
    /// # Ok::<(), tether_core::passes::PassError>(())
    /// ```
    pub fn load_or_create(path: &Path, per_month: u32) -> PassResult<Self> {
        let path = path.to_path_buf();

        let data = if path.exists() {
            // Load existing data
            let contents = fs::read_to_string(&path).map_err(|source| PassError::ReadError {
                path: path.clone(),
                source,
            })?;

            serde_json::from_str::<PassData>(&contents).map_err(|source| PassError::ParseError {
                path: path.clone(),
                source,
            })?
        } else {
            // Create new data
            let data = PassData::new(per_month);

            // Ensure parent directory exists
            if let Some(parent) = path.parent() {
                if !parent.exists() {
                    fs::create_dir_all(parent).map_err(|source| PassError::CreateDirError {
                        path: path.clone(),
                        source,
                    })?;
                }
            }

            data
        };

        let mut manager = Self { path, data };

        // Check for month change and reset if needed
        // Pass None for pending_per_month since we're just loading
        manager.maybe_reset_month(None)?;

        // Ensure data is persisted (especially for new files)
        manager.save()?;

        Ok(manager)
    }

    /// Checks if the month has changed and resets passes if necessary.
    ///
    /// This method is called internally on `load_or_create` and `use_pass`.
    /// It can also be called explicitly if you want to force a check.
    ///
    /// # Month Reset Logic
    ///
    /// When the current UTC month differs from `data.current_month`:
    ///
    /// 1. If `pending_per_month` is set:
    ///    - Update `per_month` to the pending value
    ///    - Clear `pending_per_month`
    /// 2. Reset `remaining` to `per_month`
    /// 3. Update `current_month` to the new month
    /// 4. Persist changes to disk
    ///
    /// # Arguments
    ///
    /// * `new_pending_per_month` - Optional new pending value to set. If
    ///   `Some(value)`, this becomes the new `pending_per_month`. If `None`,
    ///   the existing `pending_per_month` is preserved (unless consumed by
    ///   a month reset).
    ///
    /// # Returns
    ///
    /// `true` if the month was reset, `false` otherwise.
    ///
    /// # Errors
    ///
    /// - `PassError::WriteError` - Failed to persist changes
    ///
    /// # Edge Cases
    ///
    /// - **Skipped months**: If the system was off for multiple months, only
    ///   the final month is recorded. Passes reset to `per_month` regardless
    ///   of how many months were skipped.
    ///
    /// - **Time zone changes**: Uses UTC exclusively to avoid issues with
    ///   daylight saving time or user timezone changes.
    ///
    /// - **Clock skew**: If the system clock goes backwards, no reset occurs
    ///   until the clock reaches a new month.
    pub fn maybe_reset_month(&mut self, new_pending_per_month: Option<u32>) -> PassResult<bool> {
        let current = current_month_string();
        let mut changed = false;

        // Set new pending value if provided
        if let Some(pending) = new_pending_per_month {
            // Only set pending if it differs from current per_month
            if pending != self.data.per_month {
                self.data.pending_per_month = Some(pending);
                changed = true;
            } else {
                // If setting to current value, clear any pending
                if self.data.pending_per_month.is_some() {
                    self.data.pending_per_month = None;
                    changed = true;
                }
            }
        }

        // Check if month has changed
        if current != self.data.current_month {
            // Apply pending per_month if set
            if let Some(pending) = self.data.pending_per_month.take() {
                self.data.per_month = pending;
            }

            // Reset remaining passes
            self.data.remaining = self.data.per_month;

            // Update current month
            self.data.current_month = current;

            changed = true;
        }

        if changed {
            self.save()?;
        }

        Ok(changed)
    }

    /// Returns the number of passes remaining for the current month.
    ///
    /// This value decrements when `use_pass` is called and resets to
    /// `per_month` at the start of each month.
    ///
    /// # Note
    ///
    /// This method does not check for month changes. For accurate results
    /// after periods of inactivity, call `maybe_reset_month(None)` first
    /// or rely on `use_pass` to trigger the check.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use tether_core::passes::PassManager;
    /// # use std::path::PathBuf;
    /// # let manager = PassManager::load_or_create(&PathBuf::from("test.json"), 3)?;
    /// let remaining = manager.remaining();
    /// if remaining == 0 {
    ///     println!("No passes remaining this month!");
    /// } else {
    ///     println!("{} passes remaining", remaining);
    /// }
    /// # Ok::<(), tether_core::passes::PassError>(())
    /// ```
    #[inline]
    pub fn remaining(&self) -> u32 {
        self.data.remaining
    }

    /// Returns the number of passes granted per month.
    ///
    /// This is the active `per_month` value. If there's a pending change,
    /// it won't be reflected until the next month.
    #[inline]
    pub fn per_month(&self) -> u32 {
        self.data.per_month
    }

    /// Returns the pending per-month value, if any.
    ///
    /// This is the value that will take effect at the start of the next month.
    /// Returns `None` if no change is pending.
    #[inline]
    pub fn pending_per_month(&self) -> Option<u32> {
        self.data.pending_per_month
    }

    /// Returns the current month string in "YYYY-MM" format.
    ///
    /// This reflects the month that pass tracking is currently using,
    /// which may differ from `current_month_string()` if a month change
    /// hasn't been processed yet.
    #[inline]
    pub fn current_month(&self) -> &str {
        &self.data.current_month
    }

    /// Uses one pass and records the reason.
    ///
    /// This method:
    /// 1. Checks for month changes and resets if necessary
    /// 2. Validates the reason is not empty and within length limits
    /// 3. Decrements the remaining pass count
    /// 4. Records the usage in history with a UTC timestamp
    /// 5. Persists changes to disk
    ///
    /// # Arguments
    ///
    /// * `reason` - The reason for using this pass. Must be non-empty and
    ///   at most 500 characters. Leading/trailing whitespace is trimmed.
    ///
    /// # Returns
    ///
    /// The `PassEntry` that was recorded, containing the timestamp and reason.
    ///
    /// # Errors
    ///
    /// - `PassError::NoPassesRemaining` - No passes left for this month
    /// - `PassError::EmptyReason` - The reason was empty or whitespace-only
    /// - `PassError::ReasonTooLong` - The reason exceeds 500 characters
    /// - `PassError::WriteError` - Failed to persist changes
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use tether_core::passes::PassManager;
    /// # use std::path::PathBuf;
    /// # let mut manager = PassManager::load_or_create(&PathBuf::from("test.json"), 3)?;
    /// match manager.use_pass("Medical appointment".to_string()) {
    ///     Ok(entry) => {
    ///         println!("Pass used at {}", entry.used_at_utc);
    ///         println!("{} passes remaining", manager.remaining());
    ///     }
    ///     Err(tether_core::passes::PassError::NoPassesRemaining { month, max }) => {
    ///         println!("No passes left! Used all {} for {}", max, month);
    ///     }
    ///     Err(e) => println!("Error: {}", e),
    /// }
    /// # Ok::<(), tether_core::passes::PassError>(())
    /// ```
    pub fn use_pass(&mut self, reason: String) -> PassResult<PassEntry> {
        // Check for month reset first
        self.maybe_reset_month(None)?;

        // Validate reason
        let reason = reason.trim().to_string();
        if reason.is_empty() {
            return Err(PassError::EmptyReason);
        }
        if reason.len() > MAX_REASON_LENGTH {
            return Err(PassError::ReasonTooLong {
                max: MAX_REASON_LENGTH,
                actual: reason.len(),
            });
        }

        // Check if passes are available
        if self.data.remaining == 0 {
            return Err(PassError::NoPassesRemaining {
                month: self.data.current_month.clone(),
                max: self.data.per_month,
            });
        }

        // Use a pass
        self.data.remaining -= 1;

        // Record in history
        let entry = PassEntry::new(reason);
        self.data
            .history
            .entry(self.data.current_month.clone())
            .or_default()
            .push(entry.clone());

        // Persist
        self.save()?;

        Ok(entry)
    }

    /// Returns the pass usage history for a specific month.
    ///
    /// # Arguments
    ///
    /// * `month` - The month to query in "YYYY-MM" format (e.g., "2025-01").
    ///
    /// # Returns
    ///
    /// A vector of `PassEntry` for the specified month, in chronological order.
    /// Returns an empty vector if no passes were used that month or if the
    /// month string is not found in history.
    ///
    /// # Note
    ///
    /// This method does not validate the month format. Invalid month strings
    /// will simply return an empty vector.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use tether_core::passes::PassManager;
    /// # use std::path::PathBuf;
    /// # let manager = PassManager::load_or_create(&PathBuf::from("test.json"), 3)?;
    /// // Get current month's history
    /// let current = tether_core::passes::current_month_string();
    /// let entries = manager.history(&current);
    /// for entry in entries {
    ///     println!("{}: {}", entry.used_at_utc, entry.reason);
    /// }
    ///
    /// // Get last month's history
    /// let last_month = manager.history("2024-12");
    /// # Ok::<(), tether_core::passes::PassError>(())
    /// ```
    pub fn history(&self, month: &str) -> Vec<PassEntry> {
        self.data
            .history
            .get(month)
            .cloned()
            .unwrap_or_default()
    }

    /// Returns all pass usage history across all months.
    ///
    /// # Returns
    ///
    /// A clone of the internal history HashMap. Keys are month strings in
    /// "YYYY-MM" format, values are vectors of `PassEntry`.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use tether_core::passes::PassManager;
    /// # use std::path::PathBuf;
    /// # let manager = PassManager::load_or_create(&PathBuf::from("test.json"), 3)?;
    /// let all_history = manager.all_history();
    /// for (month, entries) in &all_history {
    ///     println!("{}:", month);
    ///     for entry in entries {
    ///         println!("  - {}: {}", entry.used_at_utc, entry.reason);
    ///     }
    /// }
    /// # Ok::<(), tether_core::passes::PassError>(())
    /// ```
    pub fn all_history(&self) -> HashMap<String, Vec<PassEntry>> {
        self.data.history.clone()
    }

    /// Updates the per-month pass configuration.
    ///
    /// If called mid-month, the new value is stored as `pending_per_month`
    /// and takes effect at the start of the next month. This prevents
    /// gaming the system by increasing passes mid-month.
    ///
    /// If called at the start of a new month (or if no passes have been
    /// used yet this month and remaining equals per_month), the change
    /// takes effect immediately.
    ///
    /// # Arguments
    ///
    /// * `new_per_month` - The new number of passes per month.
    ///
    /// # Returns
    ///
    /// `true` if the change was applied immediately, `false` if it was
    /// deferred to next month.
    ///
    /// # Errors
    ///
    /// - `PassError::WriteError` - Failed to persist changes
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use tether_core::passes::PassManager;
    /// # use std::path::PathBuf;
    /// # let mut manager = PassManager::load_or_create(&PathBuf::from("test.json"), 3)?;
    /// // Change from 3 to 5 passes per month
    /// let immediate = manager.set_per_month(5)?;
    /// if immediate {
    ///     println!("Change applied immediately");
    /// } else {
    ///     println!("Change will apply next month");
    ///     assert_eq!(manager.pending_per_month(), Some(5));
    /// }
    /// # Ok::<(), tether_core::passes::PassError>(())
    /// ```
    pub fn set_per_month(&mut self, new_per_month: u32) -> PassResult<bool> {
        // First check for month reset
        self.maybe_reset_month(None)?;

        // If same as current, no change needed
        if new_per_month == self.data.per_month {
            // Clear any pending if exists
            if self.data.pending_per_month.is_some() {
                self.data.pending_per_month = None;
                self.save()?;
            }
            return Ok(true);
        }

        // Check if we can apply immediately:
        // - No passes have been used yet this month
        // - (remaining == per_month means no passes used)
        let can_apply_immediately = self.data.remaining == self.data.per_month;

        if can_apply_immediately {
            self.data.per_month = new_per_month;
            self.data.remaining = new_per_month;
            self.data.pending_per_month = None;
            self.save()?;
            Ok(true)
        } else {
            // Defer to next month
            self.data.pending_per_month = Some(new_per_month);
            self.save()?;
            Ok(false)
        }
    }

    /// Persists the current data to disk.
    ///
    /// This method uses atomic write (write to temp file, then rename) to
    /// prevent data corruption if the process crashes mid-write.
    ///
    /// # Errors
    ///
    /// - `PassError::SerializeError` - Failed to serialize data to JSON
    /// - `PassError::WriteError` - Failed to write to disk
    fn save(&self) -> PassResult<()> {
        let json = serde_json::to_string_pretty(&self.data)?;

        // Atomic write: write to temp file, then rename
        let temp_path = self.path.with_extension("json.tmp");

        fs::write(&temp_path, &json).map_err(|source| PassError::WriteError {
            path: temp_path.clone(),
            source,
        })?;

        fs::rename(&temp_path, &self.path).map_err(|source| PassError::WriteError {
            path: self.path.clone(),
            source,
        })?;

        Ok(())
    }

    /// Returns a reference to the underlying PassData (for testing/debugging).
    #[cfg(test)]
    pub fn data(&self) -> &PassData {
        &self.data
    }
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/// Returns the current month as a string in "YYYY-MM" format.
///
/// This function uses UTC time to ensure consistency across timezones.
/// The format matches ISO 8601 month representation.
///
/// # Examples
///
/// ```
/// use tether_core::passes::current_month_string;
///
/// // Returns something like "2025-01" depending on current date
/// let month = current_month_string();
/// assert!(month.len() == 7);
/// assert!(month.chars().nth(4) == Some('-'));
/// ```
pub fn current_month_string() -> String {
    let now = Utc::now();
    format!("{:04}-{:02}", now.year(), now.month())
}

/// Validates a month string format.
///
/// # Arguments
///
/// * `month` - The month string to validate.
///
/// # Returns
///
/// `true` if the string matches "YYYY-MM" format with valid values.
///
/// # Examples
///
/// ```
/// use tether_core::passes::is_valid_month_string;
///
/// assert!(is_valid_month_string("2025-01"));
/// assert!(is_valid_month_string("2024-12"));
/// assert!(!is_valid_month_string("2025-13")); // Invalid month
/// assert!(!is_valid_month_string("2025-1"));  // Missing leading zero
/// assert!(!is_valid_month_string("25-01"));   // Year too short
/// ```
pub fn is_valid_month_string(month: &str) -> bool {
    if month.len() != 7 {
        return false;
    }

    let parts: Vec<&str> = month.split('-').collect();
    if parts.len() != 2 {
        return false;
    }

    let year: Result<i32, _> = parts[0].parse();
    let month_num: Result<u32, _> = parts[1].parse();

    match (year, month_num) {
        (Ok(y), Ok(m)) => y >= 1970 && y <= 9999 && m >= 1 && m <= 12,
        _ => false,
    }
}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::tempdir;

    /// Helper to create a manager with a temp file
    fn create_temp_manager(per_month: u32) -> (PassManager, PathBuf) {
        let dir = tempdir().unwrap();
        let path = dir.path().join("passes.json");
        // Keep dir alive by leaking it (for testing only)
        let path_clone = path.clone();
        std::mem::forget(dir);
        let manager = PassManager::load_or_create(&path_clone, per_month).unwrap();
        (manager, path_clone)
    }

    #[test]
    fn test_current_month_string_format() {
        let month = current_month_string();
        assert_eq!(month.len(), 7);
        assert!(month.chars().nth(4) == Some('-'));
        assert!(is_valid_month_string(&month));
    }

    #[test]
    fn test_is_valid_month_string() {
        assert!(is_valid_month_string("2025-01"));
        assert!(is_valid_month_string("2024-12"));
        assert!(is_valid_month_string("1970-01"));
        assert!(is_valid_month_string("9999-12"));

        assert!(!is_valid_month_string("2025-13")); // Invalid month
        assert!(!is_valid_month_string("2025-00")); // Invalid month
        assert!(!is_valid_month_string("2025-1"));  // Missing leading zero
        assert!(!is_valid_month_string("25-01"));   // Year too short
        assert!(!is_valid_month_string(""));
        assert!(!is_valid_month_string("2025/01")); // Wrong separator
        assert!(!is_valid_month_string("abcd-01")); // Non-numeric year
    }

    #[test]
    fn test_new_manager_creates_file() {
        let (manager, path) = create_temp_manager(3);
        assert!(path.exists());
        assert_eq!(manager.remaining(), 3);
        assert_eq!(manager.per_month(), 3);
        assert_eq!(manager.pending_per_month(), None);
    }

    #[test]
    fn test_load_existing_file() {
        let dir = tempdir().unwrap();
        let path = dir.path().join("passes.json");

        // Create initial manager
        {
            let mut manager = PassManager::load_or_create(&path, 5).unwrap();
            manager.use_pass("Test reason".to_string()).unwrap();
            assert_eq!(manager.remaining(), 4);
        }

        // Load again
        let manager = PassManager::load_or_create(&path, 10).unwrap(); // per_month ignored for existing
        assert_eq!(manager.remaining(), 4);
        assert_eq!(manager.per_month(), 5); // Original value preserved
    }

    #[test]
    fn test_use_pass_decrements_remaining() {
        let (mut manager, _path) = create_temp_manager(3);
        assert_eq!(manager.remaining(), 3);

        manager.use_pass("First".to_string()).unwrap();
        assert_eq!(manager.remaining(), 2);

        manager.use_pass("Second".to_string()).unwrap();
        assert_eq!(manager.remaining(), 1);

        manager.use_pass("Third".to_string()).unwrap();
        assert_eq!(manager.remaining(), 0);
    }

    #[test]
    fn test_use_pass_records_history() {
        let (mut manager, _path) = create_temp_manager(3);

        let entry = manager.use_pass("Test reason".to_string()).unwrap();
        assert_eq!(entry.reason, "Test reason");

        let history = manager.history(&current_month_string());
        assert_eq!(history.len(), 1);
        assert_eq!(history[0].reason, "Test reason");
    }

    #[test]
    fn test_use_pass_no_passes_remaining() {
        let (mut manager, _path) = create_temp_manager(1);

        manager.use_pass("Only pass".to_string()).unwrap();

        let result = manager.use_pass("Should fail".to_string());
        assert!(matches!(result, Err(PassError::NoPassesRemaining { .. })));
    }

    #[test]
    fn test_use_pass_empty_reason() {
        let (mut manager, _path) = create_temp_manager(3);

        let result = manager.use_pass("".to_string());
        assert!(matches!(result, Err(PassError::EmptyReason)));

        let result = manager.use_pass("   ".to_string());
        assert!(matches!(result, Err(PassError::EmptyReason)));
    }

    #[test]
    fn test_use_pass_reason_too_long() {
        let (mut manager, _path) = create_temp_manager(3);

        let long_reason = "x".repeat(MAX_REASON_LENGTH + 1);
        let result = manager.use_pass(long_reason);
        assert!(matches!(result, Err(PassError::ReasonTooLong { .. })));

        // Exactly max length should work
        let max_reason = "x".repeat(MAX_REASON_LENGTH);
        let result = manager.use_pass(max_reason);
        assert!(result.is_ok());
    }

    #[test]
    fn test_use_pass_trims_whitespace() {
        let (mut manager, _path) = create_temp_manager(3);

        let entry = manager.use_pass("  trimmed reason  ".to_string()).unwrap();
        assert_eq!(entry.reason, "trimmed reason");
    }

    #[test]
    fn test_history_empty_month() {
        let (manager, _path) = create_temp_manager(3);

        let history = manager.history("2020-01");
        assert!(history.is_empty());
    }

    #[test]
    fn test_all_history() {
        let (mut manager, _path) = create_temp_manager(3);

        manager.use_pass("Test".to_string()).unwrap();

        let all = manager.all_history();
        assert!(all.contains_key(&current_month_string()));
    }

    #[test]
    fn test_set_per_month_immediate_when_no_passes_used() {
        let (mut manager, _path) = create_temp_manager(3);
        assert_eq!(manager.remaining(), 3);

        let immediate = manager.set_per_month(5).unwrap();
        assert!(immediate);
        assert_eq!(manager.per_month(), 5);
        assert_eq!(manager.remaining(), 5);
        assert_eq!(manager.pending_per_month(), None);
    }

    #[test]
    fn test_set_per_month_deferred_when_passes_used() {
        let (mut manager, _path) = create_temp_manager(3);

        manager.use_pass("Use one".to_string()).unwrap();
        assert_eq!(manager.remaining(), 2);

        let immediate = manager.set_per_month(5).unwrap();
        assert!(!immediate);
        assert_eq!(manager.per_month(), 3); // Unchanged
        assert_eq!(manager.remaining(), 2); // Unchanged
        assert_eq!(manager.pending_per_month(), Some(5));
    }

    #[test]
    fn test_set_per_month_same_value() {
        let (mut manager, _path) = create_temp_manager(3);

        manager.use_pass("Use one".to_string()).unwrap();

        // Set pending
        manager.set_per_month(5).unwrap();
        assert_eq!(manager.pending_per_month(), Some(5));

        // Set back to current - should clear pending
        let immediate = manager.set_per_month(3).unwrap();
        assert!(immediate);
        assert_eq!(manager.pending_per_month(), None);
    }

    #[test]
    fn test_pass_data_serialization() {
        let mut data = PassData::new(3);
        data.history.insert(
            "2025-01".to_string(),
            vec![PassEntry {
                used_at_utc: Utc::now(),
                reason: "Test".to_string(),
            }],
        );

        let json = serde_json::to_string_pretty(&data).unwrap();
        let parsed: PassData = serde_json::from_str(&json).unwrap();

        assert_eq!(parsed.current_month, data.current_month);
        assert_eq!(parsed.remaining, data.remaining);
        assert_eq!(parsed.per_month, data.per_month);
        assert_eq!(parsed.history.len(), 1);
    }

    #[test]
    fn test_persistence_across_loads() {
        let dir = tempdir().unwrap();
        let path = dir.path().join("passes.json");

        // Create and modify
        {
            let mut manager = PassManager::load_or_create(&path, 3).unwrap();
            manager.use_pass("First".to_string()).unwrap();
            manager.use_pass("Second".to_string()).unwrap();
        }

        // Reload and verify
        {
            let manager = PassManager::load_or_create(&path, 3).unwrap();
            assert_eq!(manager.remaining(), 1);
            let history = manager.history(&current_month_string());
            assert_eq!(history.len(), 2);
            assert_eq!(history[0].reason, "First");
            assert_eq!(history[1].reason, "Second");
        }
    }

    #[test]
    fn test_creates_parent_directories() {
        let dir = tempdir().unwrap();
        let path = dir.path().join("subdir").join("nested").join("passes.json");

        let manager = PassManager::load_or_create(&path, 3).unwrap();
        assert!(path.exists());
        assert_eq!(manager.remaining(), 3);
    }

    #[test]
    fn test_pass_entry_new() {
        let entry = PassEntry::new("Test".to_string());
        assert_eq!(entry.reason, "Test");
        // Timestamp should be very recent
        let age = Utc::now() - entry.used_at_utc;
        assert!(age.num_seconds() < 1);
    }

    #[test]
    fn test_zero_passes_per_month() {
        let (mut manager, _path) = create_temp_manager(0);
        assert_eq!(manager.remaining(), 0);

        let result = manager.use_pass("Should fail".to_string());
        assert!(matches!(result, Err(PassError::NoPassesRemaining { .. })));
    }
}
```

---

## Key Design Decisions and Edge Cases

### 1. Month Reset Logic

The `maybe_reset_month` method handles these scenarios:

- **Normal month change**: Reset remaining to `per_month`, apply any `pending_per_month`
- **Skipped months** (system offline): Resets to current month, passes reset as normal
- **Clock skew backwards**: No reset occurs until clock reaches new month (prevents double-reset)
- **UTC everywhere**: Avoids DST and timezone change issues

### 2. Pending Per-Month Changes

When `set_per_month` is called:

- **No passes used this month**: Apply immediately (remaining == per_month)
- **Passes already used**: Defer to next month via `pending_per_month`
- **Setting to current value**: Clear any pending change

### 3. Thread Safety Pattern

The module is designed for external `RwLock` wrapping:

```rust
// In your application state (e.g., axum)
use std::sync::RwLock;
use tether_core::passes::PassManager;

pub struct AppState {
    pub passes: RwLock<PassManager>,
}

// Reading
let remaining = state.passes.read().unwrap().remaining();

// Writing
state.passes.write().unwrap().use_pass("reason".into())?;
```

### 4. Atomic Persistence

The `save` method writes to a `.tmp` file then renames, preventing corruption on crash:

```rust
// Write to temp file
fs::write(&temp_path, &json)?;
// Atomic rename
fs::rename(&temp_path, &self.path)?;
```

### 5. Error Handling

All error types are:
- Rich with context (path, source error)
- Use `thiserror` for ergonomic implementation
- Propagate underlying IO/JSON errors properly

### 6. Validation

- Empty reasons rejected
- Reasons trimmed of whitespace
- Max 500 character limit on reasons
- Month strings validated with `is_valid_month_string`

---

## Usage in HTTP Handlers (Example)

```rust
// In your axum handlers
use axum::{extract::State, Json};
use std::sync::Arc;

pub async fn get_remaining(
    State(state): State<Arc<AppState>>,
) -> Json<u32> {
    let manager = state.passes.read().unwrap();
    Json(manager.remaining())
}

pub async fn use_pass(
    State(state): State<Arc<AppState>>,
    Json(request): Json<UsePassRequest>,
) -> Result<Json<PassEntry>, AppError> {
    let mut manager = state.passes.write().unwrap();
    let entry = manager.use_pass(request.reason)?;
    Ok(Json(entry))
}
```

---

### Critical Files for Implementation

- `/Users/jeffrey/code/tether/tether-core/src/passes.rs` - The complete implementation provided above
- `/Users/jeffrey/code/tether/tether-core/Cargo.toml` - Must add chrono, serde, serde_json, thiserror dependencies
- `/Users/jeffrey/code/tether/tether-core/src/lib.rs` - Must expose `pub mod passes;`
- `/Users/jeffrey/code/tether/claude-spec.md` - Reference for understanding the full project requirements and how passes integrate with the HTTP API
