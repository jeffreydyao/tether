# Cross-Compiling Rust for Raspberry Pi Zero 2 W: Excruciating Implementation Details

## Overview

This document provides exhaustive implementation details for cross-compiling `tether-server` for `armv7-unknown-linux-gnueabihf` (32-bit ARM) using [cross-rs](https://github.com/cross-rs/cross).

**Why 32-bit?** The Pi Zero 2 W has only 512MB RAM. While the Cortex-A53 supports 64-bit, 32-bit armhf is more memory-efficient and matches the Raspberry Pi OS Lite armhf image we're using.

The primary challenge is that the `bluer` crate depends on `dbus` (from dbus-rs), which requires `libdbus-1-dev` headers for building.

## Key Discovery: bluer Dependencies

Based on examination of [bluer's Cargo.toml](https://github.com/bluez/bluer/blob/master/bluer/Cargo.toml), bluer depends on:
- `dbus = { version = "0.9", features = ["futures"], optional = true }`
- `dbus-tokio` (version 0.7, optional)
- `dbus-crossroads` (version 0.5, optional)

These are part of the [dbus-rs](https://github.com/diwic/dbus-rs) ecosystem, which binds to the libdbus C library.

---

## 1. Cross.toml Configuration

There are two approaches: using pre-build commands with the default image, or using a custom Docker image.

### Approach A: Using Pre-build Commands (Simpler)

Location: `/Users/jeffrey/code/tether/Cross.toml`

```toml
[build]
# Use the default-target to avoid specifying --target every time
default-target = "armv7-unknown-linux-gnueabihf"

[build.env]
# Pass through environment variables needed for the build
passthrough = [
    "RUST_BACKTRACE",
    "RUST_LOG",
    "CARGO_TERM_COLOR",
]

[target.armv7-unknown-linux-gnueabihf]
# CRITICAL: Install ARM32 development libraries before building
# CROSS_DEB_ARCH automatically evaluates to "armhf" for this target
pre-build = [
    # Add armhf architecture support
    "dpkg --add-architecture $CROSS_DEB_ARCH",

    # Update package lists
    "apt-get update",

    # Install D-Bus development headers for armhf
    # This is REQUIRED for the bluer crate which depends on dbus-rs
    "apt-get install --assume-yes libdbus-1-dev:$CROSS_DEB_ARCH",

    # Install pkg-config for armhf to help find the libraries
    "apt-get install --assume-yes pkg-config",
]

# Environment variables for the build container
[target.armv7-unknown-linux-gnueabihf.env]
passthrough = [
    "PKG_CONFIG_ALLOW_CROSS=1",
    "PKG_CONFIG_PATH=/usr/lib/arm-linux-gnueabihf/pkgconfig",
]
```

### Approach B: Using Custom Dockerfile (More Robust)

If pre-build commands fail (common with complex library dependencies), use a custom Dockerfile.

Location: `/Users/jeffrey/code/tether/Cross.toml`

```toml
[build]
default-target = "armv7-unknown-linux-gnueabihf"

[build.env]
passthrough = [
    "RUST_BACKTRACE",
    "RUST_LOG",
]

[target.armv7-unknown-linux-gnueabihf]
# Use custom Dockerfile instead of pre-build
dockerfile = "./docker/Dockerfile.armv7"

[target.armv7-unknown-linux-gnueabihf.env]
passthrough = [
    "PKG_CONFIG_ALLOW_CROSS=1",
]
```

---

## 2. .cargo/config.toml Configuration

Location: `/Users/jeffrey/code/tether/.cargo/config.toml`

```toml
# Linker configuration for cross-compilation
# NOTE: When using cross-rs, the linker is already configured in the Docker image.
# This file is primarily needed for native cross-compilation WITHOUT cross-rs.

[target.armv7-unknown-linux-gnueabihf]
# The cross-rs Docker image already sets this, but explicit is good
linker = "arm-linux-gnueabihf-gcc"

# Library search paths for dbus
# These may need adjustment based on where cross installs the armhf libs
rustflags = [
    "-L", "/usr/arm-linux-gnueabihf/lib",
    "-L", "/usr/lib/arm-linux-gnueabihf",
]

# Runner for testing (uses QEMU in cross-rs)
runner = "qemu-arm"

# Build profile for release builds
[profile.release]
# Size optimization - choose 's' for balanced, 'z' for smallest
opt-level = "z"

# Link Time Optimization - 'fat' for best optimization, 'thin' for faster builds
lto = "fat"

# Single codegen unit for maximum optimization
codegen-units = 1

# Abort on panic instead of unwinding (smaller binary)
panic = "abort"

# Strip symbols from binary
strip = true

# Additional release profile for even smaller binaries
[profile.release-pi]
inherits = "release"
opt-level = "z"
lto = "fat"
codegen-units = 1
panic = "abort"
strip = true
# Debug info disabled for production
debug = false
```

---

## 3. Build Script: scripts/build-pi.sh

Location: `/Users/jeffrey/code/tether/scripts/build-pi.sh`

```bash
#!/usr/bin/env bash
#
# build-pi.sh - Cross-compile tether-server for Raspberry Pi Zero 2 W
#
# Target: armv7-unknown-linux-gnueabihf (32-bit ARM)
# Uses: cross-rs (https://github.com/cross-rs/cross)
#

set -euo pipefail

# Configuration
TARGET="armv7-unknown-linux-gnueabihf"
BINARY_NAME="tether-server"
PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
OUTPUT_DIR="${PROJECT_ROOT}/target/pi"
RELEASE_DIR="${PROJECT_ROOT}/target/${TARGET}/release"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if cross is installed
check_cross() {
    if ! command -v cross &> /dev/null; then
        log_warn "cross is not installed. Installing..."

        # Install cross from the git repository (recommended for latest features)
        cargo install cross --git https://github.com/cross-rs/cross

        if [ $? -ne 0 ]; then
            log_error "Failed to install cross"
            log_info "Alternative: cargo install cross"
            exit 1
        fi

        log_info "cross installed successfully"
    else
        log_info "cross is already installed: $(cross --version)"
    fi
}

# Check if Docker is running
check_docker() {
    if ! docker info &> /dev/null; then
        log_error "Docker is not running. Please start Docker first."
        log_info "On macOS: open -a Docker"
        log_info "On Linux: sudo systemctl start docker"
        exit 1
    fi
    log_info "Docker is running"
}

# Build the project
build() {
    log_info "Building ${BINARY_NAME} for ${TARGET}..."

    cd "${PROJECT_ROOT}"

    # Set environment variables for cross-compilation
    export PKG_CONFIG_ALLOW_CROSS=1
    export CARGO_TERM_COLOR=always

    # Build with cross
    # Using --release for optimized binary
    # Using -p to specify the package if in a workspace
    cross build \
        --release \
        --target "${TARGET}" \
        -p tether-server \
        2>&1 | tee "${PROJECT_ROOT}/build.log"

    if [ ${PIPESTATUS[0]} -ne 0 ]; then
        log_error "Build failed! Check build.log for details"
        exit 1
    fi

    log_info "Build completed successfully"
}

# Copy and strip the binary
package() {
    log_info "Packaging binary..."

    # Create output directory
    mkdir -p "${OUTPUT_DIR}"

    # Source binary path
    BINARY_PATH="${RELEASE_DIR}/${BINARY_NAME}"

    if [ ! -f "${BINARY_PATH}" ]; then
        log_error "Binary not found at ${BINARY_PATH}"
        exit 1
    fi

    # Copy binary to output directory
    cp "${BINARY_PATH}" "${OUTPUT_DIR}/${BINARY_NAME}"

    # Get original size
    ORIGINAL_SIZE=$(ls -lh "${OUTPUT_DIR}/${BINARY_NAME}" | awk '{print $5}')
    log_info "Original binary size: ${ORIGINAL_SIZE}"

    # Strip the binary using the cross-compilation strip tool
    # Note: If you have arm-linux-gnueabihf-strip installed locally, use it
    # Otherwise, we can strip inside Docker
    if command -v arm-linux-gnueabihf-strip &> /dev/null; then
        log_info "Stripping binary with arm-linux-gnueabihf-strip..."
        arm-linux-gnueabihf-strip "${OUTPUT_DIR}/${BINARY_NAME}"
    else
        log_info "Stripping binary inside Docker container..."
        docker run --rm \
            -v "${OUTPUT_DIR}:/work" \
            ghcr.io/cross-rs/armv7-unknown-linux-gnueabihf:main \
            arm-linux-gnueabihf-strip /work/${BINARY_NAME}
    fi

    # Get stripped size
    STRIPPED_SIZE=$(ls -lh "${OUTPUT_DIR}/${BINARY_NAME}" | awk '{print $5}')
    log_info "Stripped binary size: ${STRIPPED_SIZE}"

    log_info "Binary ready at: ${OUTPUT_DIR}/${BINARY_NAME}"
}

# Verify the binary
verify() {
    log_info "Verifying binary..."

    BINARY_PATH="${OUTPUT_DIR}/${BINARY_NAME}"

    # Check file type
    FILE_TYPE=$(file "${BINARY_PATH}")
    log_info "File type: ${FILE_TYPE}"

    # Verify it's an ARM32 ELF binary
    if echo "${FILE_TYPE}" | grep -q "ELF 32-bit LSB.*ARM"; then
        log_info "Binary is correct architecture (ARM32/armhf)"
    else
        log_error "Binary may not be the correct architecture!"
        log_error "Expected: ELF 32-bit LSB executable, ARM, EABI5"
        exit 1
    fi

    # Check linked libraries (requires qemu for full check)
    if command -v qemu-arm &> /dev/null; then
        log_info "Checking dynamic libraries..."
        qemu-arm -L /usr/arm-linux-gnueabihf "${BINARY_PATH}" --version 2>/dev/null || true
    fi
}

# Print summary
summary() {
    echo ""
    echo "=========================================="
    echo "  Build Summary"
    echo "=========================================="
    echo "  Target:     ${TARGET}"
    echo "  Binary:     ${OUTPUT_DIR}/${BINARY_NAME}"
    echo "  Size:       $(ls -lh "${OUTPUT_DIR}/${BINARY_NAME}" | awk '{print $5}')"
    echo ""
    echo "  To deploy to Raspberry Pi:"
    echo "    scp ${OUTPUT_DIR}/${BINARY_NAME} pi@<pi-ip>:/home/pi/"
    echo ""
    echo "=========================================="
}

# Main execution
main() {
    log_info "Starting cross-compilation for Raspberry Pi Zero 2 W (32-bit armhf)"

    check_docker
    check_cross
    build
    package
    verify
    summary

    log_info "Done!"
}

main "$@"
```

---

## 4. Custom Docker Image for Cross-Compilation

If the default cross-rs image with pre-build commands does not work, create a custom Docker image.

### Dockerfile Location

Location: `/Users/jeffrey/code/tether/docker/Dockerfile.armv7`

```dockerfile
# Custom Docker image for cross-compiling tether-server to ARM32 (armhf)
# Based on the official cross-rs image for armv7-unknown-linux-gnueabihf
#
# This image includes all required dependencies for the bluer crate

# Use ARG to allow cross to inject the base image
ARG CROSS_BASE_IMAGE=ghcr.io/cross-rs/armv7-unknown-linux-gnueabihf:main
FROM ${CROSS_BASE_IMAGE}

# Prevent interactive prompts during package installation
ENV DEBIAN_FRONTEND=noninteractive

# Add armhf architecture support
RUN dpkg --add-architecture armhf

# Update package lists
# Note: We may need to add Ubuntu ports repository for armhf packages
RUN apt-get update || true

# Install required development libraries for armhf
#
# libdbus-1-dev:armhf - Required by dbus-rs (bluer dependency)
# pkg-config - Required to locate libraries during build
# libsystemd-dev:armhf - Sometimes required by libdbus
#
RUN apt-get install --assume-yes --no-install-recommends \
    libdbus-1-dev:armhf \
    pkg-config \
    && rm -rf /var/lib/apt/lists/*

# Set environment variables for pkg-config to find armhf libraries
ENV PKG_CONFIG_ALLOW_CROSS=1
ENV PKG_CONFIG_PATH=/usr/lib/arm-linux-gnueabihf/pkgconfig
ENV PKG_CONFIG_LIBDIR=/usr/lib/arm-linux-gnueabihf/pkgconfig

# Additional library paths for the linker
ENV RUSTFLAGS="-L /usr/arm-linux-gnueabihf/lib -L /usr/lib/arm-linux-gnueabihf"

# Verify the libraries are installed correctly
RUN ls -la /usr/lib/arm-linux-gnueabihf/libdbus* || echo "Warning: libdbus not found in expected location"
RUN ls -la /usr/lib/arm-linux-gnueabihf/pkgconfig/dbus*.pc || echo "Warning: dbus pkgconfig not found"
```

### Alternative: Extended Dockerfile with Troubleshooting

Location: `/Users/jeffrey/code/tether/docker/Dockerfile.armv7-extended`

```dockerfile
# Extended Dockerfile with additional debugging and fallback options
ARG CROSS_BASE_IMAGE=ghcr.io/cross-rs/armv7-unknown-linux-gnueabihf:main
FROM ${CROSS_BASE_IMAGE}

ENV DEBIAN_FRONTEND=noninteractive

# Add armhf architecture
RUN dpkg --add-architecture armhf

# Sometimes the default Ubuntu mirrors don't have armhf packages
# Add Ubuntu ports repository as fallback
RUN echo "deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports focal main restricted universe multiverse" >> /etc/apt/sources.list.d/armhf.list \
    && echo "deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports focal-updates main restricted universe multiverse" >> /etc/apt/sources.list.d/armhf.list \
    && echo "deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports focal-security main restricted universe multiverse" >> /etc/apt/sources.list.d/armhf.list \
    || true

# Update with error tolerance
RUN apt-get update 2>/dev/null || apt-get update --allow-releaseinfo-change || true

# Install core dependencies
RUN apt-get install --assume-yes --no-install-recommends \
    pkg-config \
    || true

# Install armhf D-Bus development library
# Try multiple package name variations
RUN apt-get install --assume-yes --no-install-recommends libdbus-1-dev:armhf \
    || apt-get install --assume-yes --no-install-recommends libdbus-1-dev \
    || echo "Warning: Could not install libdbus-1-dev for armhf"

# Install libsystemd if needed (libdbus often links to it)
RUN apt-get install --assume-yes --no-install-recommends libsystemd-dev:armhf \
    || true

# Clean up
RUN rm -rf /var/lib/apt/lists/*

# Environment setup
ENV PKG_CONFIG_ALLOW_CROSS=1
ENV PKG_CONFIG_PATH=/usr/lib/arm-linux-gnueabihf/pkgconfig:/usr/share/pkgconfig
ENV PKG_CONFIG_LIBDIR=/usr/lib/arm-linux-gnueabihf/pkgconfig

# Linker flags to find armhf libraries
ENV RUSTFLAGS="-L /usr/arm-linux-gnueabihf/lib -L /usr/lib/arm-linux-gnueabihf"

# Debug: Show what was installed
RUN echo "=== Installed armhf libraries ===" \
    && find /usr -name "libdbus*" -type f 2>/dev/null || true \
    && echo "=== PKG_CONFIG files ===" \
    && find /usr -name "dbus*.pc" 2>/dev/null || true
```

### Building the Custom Image Manually

```bash
# Build the custom Docker image
cd /Users/jeffrey/code/tether
docker build -t tether-cross-armv7:latest -f docker/Dockerfile.armv7 .

# Then update Cross.toml to use it:
# [target.armv7-unknown-linux-gnueabihf]
# image = "tether-cross-armv7:latest"
```

---

## 5. Troubleshooting Guide

### Common Error 1: pkg-config Cannot Find libdbus

**Error Message:**
```
error: failed to run custom build command for `libdbus-sys v0.2.5`
...
pkg-config has not been configured to support cross-compilation.
```

**Solution:**
```bash
# Set these environment variables BEFORE running cross
export PKG_CONFIG_ALLOW_CROSS=1
export PKG_CONFIG_PATH=/usr/lib/arm-linux-gnueabihf/pkgconfig

# Or add to Cross.toml:
[target.armv7-unknown-linux-gnueabihf.env]
passthrough = ["PKG_CONFIG_ALLOW_CROSS=1"]
```

### Common Error 2: Cannot Find libdbus-1.so

**Error Message:**
```
error: linking with `arm-linux-gnueabihf-gcc` failed
...
cannot find -ldbus-1
```

**Solution:**
Ensure armhf libdbus is installed in the Docker image:
```dockerfile
RUN dpkg --add-architecture armhf && \
    apt-get update && \
    apt-get install --assume-yes libdbus-1-dev:armhf
```

Add library paths to RUSTFLAGS:
```toml
# In .cargo/config.toml
[target.armv7-unknown-linux-gnueabihf]
rustflags = [
    "-L", "/usr/lib/arm-linux-gnueabihf",
    "-L", "/usr/arm-linux-gnueabihf/lib",
]
```

### Common Error 3: Wrong Architecture Library Linked

**Error Message:**
```
/usr/bin/ld: /usr/lib/x86_64-linux-gnu/libdbus-1.so: error adding symbols: file in wrong format
```

**Solution:**
The build is finding the host (x86_64) library instead of the target (armhf) library. Explicitly set library paths:

```toml
# In Cross.toml
[target.armv7-unknown-linux-gnueabihf]
pre-build = [
    "rm -f /usr/lib/x86_64-linux-gnu/libdbus*.so*",  # Remove x86 libs (drastic)
]
```

Or better, set PKG_CONFIG_LIBDIR to only search armhf paths:
```bash
export PKG_CONFIG_LIBDIR=/usr/lib/arm-linux-gnueabihf/pkgconfig
```

### Common Error 4: libsystemd Dependency Missing

**Error Message:**
```
/usr/lib/arm-linux-gnueabihf/libdbus-1.so: undefined reference to `sd_bus_*`
```

**Solution:**
libdbus on modern systems depends on libsystemd. Install it:
```dockerfile
RUN apt-get install --assume-yes libsystemd-dev:armhf
```

### Common Error 5: Docker Image Pull Failures

**Error Message:**
```
Unable to access ghcr.io/cross-rs images
```

**Solution:**
```bash
# Try pulling manually first
docker pull ghcr.io/cross-rs/armv7-unknown-linux-gnueabihf:main

# If that fails, try the edge tag
docker pull ghcr.io/cross-rs/armv7-unknown-linux-gnueabihf:edge

# Or use a specific version
docker pull ghcr.io/cross-rs/armv7-unknown-linux-gnueabihf:0.2.5
```

### Common Error 6: Binary Runs But Crashes on Pi

**Debugging Steps:**
```bash
# On the Raspberry Pi, check for missing libraries
ldd /path/to/tether-server

# If libdbus-1.so.3 is missing:
sudo apt-get install libdbus-1-3

# Check if the binary is the correct architecture
file /path/to/tether-server
# Should show: ELF 32-bit LSB executable, ARM, EABI5

# Run with debug output
RUST_BACKTRACE=1 ./tether-server
```

### Verifying the Binary Works

```bash
# On your build machine, verify the binary architecture
file target/pi/tether-server
# Expected: ELF 32-bit LSB executable, ARM, EABI5, version 1 (SYSV), dynamically linked, ...

# Check what libraries it needs
# This requires qemu-user and armhf libs, or do it on the Pi
arm-linux-gnueabihf-readelf -d target/pi/tether-server | grep NEEDED

# Or use objdump
arm-linux-gnueabihf-objdump -p target/pi/tether-server | grep NEEDED
```

---

## 6. Binary Size Optimization

### Cargo.toml Release Profile

Location: Add to `/Users/jeffrey/code/tether/Cargo.toml`

```toml
# Workspace-level profile (if using workspace)
[profile.release]
# Optimize for size: 's' for balanced, 'z' for smallest
# Note: 'z' may sometimes produce larger binaries than 's' paradoxically
opt-level = "z"

# Link Time Optimization
# - true or "fat": Best optimization, slowest compile
# - "thin": Good optimization, faster compile
# - false: No LTO
lto = "fat"

# Single codegen unit = better optimization but slower compile
codegen-units = 1

# Abort on panic instead of unwinding
# Saves ~10% binary size but no stack traces
panic = "abort"

# Strip all symbols
strip = true

# Disable debug info in release
debug = false

# Custom profile for Raspberry Pi with maximum size reduction
[profile.release-pi]
inherits = "release"
opt-level = "z"
lto = "fat"
codegen-units = 1
panic = "abort"
strip = true
debug = false

# Optional: Reduce precision of floating point (if acceptable)
# overflow-checks = false
```

### Additional Size Reduction Techniques

#### Technique 1: Remove Unused Dependencies

```bash
# Install cargo-udeps to find unused dependencies
cargo install cargo-udeps

# Run analysis
cargo +nightly udeps
```

#### Technique 2: Use cargo-bloat to Analyze Size

```bash
# Install cargo-bloat
cargo install cargo-bloat

# Analyze what's taking space
cargo bloat --release --target armv7-unknown-linux-gnueabihf

# Show crate breakdown
cargo bloat --release --target armv7-unknown-linux-gnueabihf --crates
```

#### Technique 3: UPX Compression (Optional)

After stripping, you can further compress with UPX:

```bash
# Install UPX (on macOS)
brew install upx

# Compress the binary (on the Pi or with ARM UPX)
upx --best target/pi/tether-server

# Note: UPX for ARM32 may need to be run on the Pi itself
# Or use Docker:
docker run --rm -v $(pwd)/target/pi:/work \
    ubuntu:22.04 bash -c "apt-get update && apt-get install -y upx && upx --best /work/tether-server"
```

#### Technique 4: Feature Flags

Disable unused features in dependencies:

```toml
[dependencies]
# Example: Only enable needed features
tokio = { version = "1", default-features = false, features = ["rt", "net", "macros"] }
```

### Expected Binary Sizes

Based on typical Rust + axum + Bluetooth projects:

| Stage | Approximate Size |
|-------|-----------------|
| Debug build | 50-100 MB |
| Release build (default) | 15-30 MB |
| Release with LTO | 8-15 MB |
| Release + LTO + strip | 5-10 MB |
| Release + LTO + strip + UPX | 2-5 MB |

---

## 7. Downloading/Cross-Compiling dumbpipe

### Option A: Check for Pre-built Binaries

Based on research, dumbpipe releases are available at [https://github.com/n0-computer/dumbpipe/releases](https://github.com/n0-computer/dumbpipe/releases).

Check if ARM32 binaries are available:
```bash
# Download latest release and check assets
curl -s https://api.github.com/repos/n0-computer/dumbpipe/releases/latest | \
    jq -r '.assets[].name' | grep -i "armv7\|armhf\|arm-linux"
```

### Option B: Cross-Compile dumbpipe

If no ARM32 binary is available, cross-compile it:

Location: `/Users/jeffrey/code/tether/scripts/build-dumbpipe.sh`

```bash
#!/usr/bin/env bash
#
# build-dumbpipe.sh - Cross-compile dumbpipe for Raspberry Pi
#

set -euo pipefail

TARGET="armv7-unknown-linux-gnueabihf"
OUTPUT_DIR="$(pwd)/target/pi"
DUMBPIPE_VERSION="0.33.0"  # Update to latest

echo "Building dumbpipe for ${TARGET}..."

# Create temp directory
TEMP_DIR=$(mktemp -d)
trap "rm -rf ${TEMP_DIR}" EXIT

cd "${TEMP_DIR}"

# Clone dumbpipe
git clone --depth 1 --branch "v${DUMBPIPE_VERSION}" \
    https://github.com/n0-computer/dumbpipe.git
cd dumbpipe

# Build with cross
cross build --release --target "${TARGET}"

# Copy binary
mkdir -p "${OUTPUT_DIR}"
cp "target/${TARGET}/release/dumbpipe" "${OUTPUT_DIR}/"

# Strip binary
if command -v arm-linux-gnueabihf-strip &> /dev/null; then
    arm-linux-gnueabihf-strip "${OUTPUT_DIR}/dumbpipe"
else
    docker run --rm -v "${OUTPUT_DIR}:/work" \
        ghcr.io/cross-rs/armv7-unknown-linux-gnueabihf:main \
        arm-linux-gnueabihf-strip /work/dumbpipe
fi

echo "dumbpipe built successfully: ${OUTPUT_DIR}/dumbpipe"
echo "Size: $(ls -lh "${OUTPUT_DIR}/dumbpipe" | awk '{print $5}')"
```

### Option C: Install on Pi Directly

If the Pi has internet and cargo:
```bash
# On the Raspberry Pi
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
cargo install dumbpipe
```

---

## 8. Alternative Approach: Using dbus Vendored Feature

The simplest way to avoid cross-compilation issues with libdbus is to use the `vendored` feature of dbus-rs, which statically links libdbus.

**However**, this only works if `bluer` exposes this feature. Check bluer's Cargo.toml for a `vendored` feature.

If not available, you can try forking bluer or using a patch in Cargo.toml:

```toml
[patch.crates-io]
dbus = { git = "https://github.com/diwic/dbus-rs", features = ["vendored"] }
```

Or override in your Cargo.toml:
```toml
[dependencies]
bluer = { version = "0.17", features = ["bluetoothd"] }

# Override dbus dependency with vendored feature
[dependencies.dbus]
version = "0.9"
features = ["vendored"]
```

With vendored feature, cross-compilation becomes simpler:
```toml
# Cross.toml - Simplified when using vendored
[target.armv7-unknown-linux-gnueabihf]
# No pre-build needed for libdbus!
pre-build = []
```

---

## 9. Complete Build Workflow

### Step-by-Step Instructions

```bash
# 1. Ensure Docker is running
docker info

# 2. Install cross (if not already installed)
cargo install cross --git https://github.com/cross-rs/cross

# 3. Create Cross.toml (see section 1)
# 4. Create .cargo/config.toml (see section 2)
# 5. Optionally create custom Dockerfile (see section 4)

# 6. Add release profile to Cargo.toml (see section 6)

# 7. Build for Raspberry Pi
cross build --release --target armv7-unknown-linux-gnueabihf

# 8. Strip the binary
mkdir -p target/pi
cp target/armv7-unknown-linux-gnueabihf/release/tether-server target/pi/
arm-linux-gnueabihf-strip target/pi/tether-server

# 9. Verify the binary
file target/pi/tether-server
# Should output: ELF 32-bit LSB executable, ARM, EABI5

# 10. Deploy to Pi
scp target/pi/tether-server pi@raspberrypi.local:/home/pi/
scp target/pi/dumbpipe pi@raspberrypi.local:/home/pi/  # if cross-compiled

# 11. On the Pi, make executable and test
ssh pi@raspberrypi.local
chmod +x tether-server dumbpipe
./tether-server --version
```

---

## 10. Makefile Integration

Location: `/Users/jeffrey/code/tether/Makefile`

```makefile
# Makefile for tether project

TARGET := armv7-unknown-linux-gnueabihf
BINARY := tether-server
OUTPUT_DIR := target/pi

.PHONY: all build-pi strip clean deploy

all: build-pi

# Build for Raspberry Pi
build-pi:
	cross build --release --target $(TARGET) -p tether-server
	mkdir -p $(OUTPUT_DIR)
	cp target/$(TARGET)/release/$(BINARY) $(OUTPUT_DIR)/

# Strip the binary
strip: build-pi
	@if command -v arm-linux-gnueabihf-strip >/dev/null 2>&1; then \
		arm-linux-gnueabihf-strip $(OUTPUT_DIR)/$(BINARY); \
	else \
		docker run --rm -v $(PWD)/$(OUTPUT_DIR):/work \
			ghcr.io/cross-rs/armv7-unknown-linux-gnueabihf:main \
			arm-linux-gnueabihf-strip /work/$(BINARY); \
	fi
	@echo "Binary size: $$(ls -lh $(OUTPUT_DIR)/$(BINARY) | awk '{print $$5}')"

# Clean build artifacts
clean:
	cargo clean
	rm -rf $(OUTPUT_DIR)

# Deploy to Pi (set PI_HOST environment variable)
deploy: strip
	@if [ -z "$(PI_HOST)" ]; then \
		echo "Set PI_HOST environment variable (e.g., PI_HOST=pi@192.168.1.100)"; \
		exit 1; \
	fi
	scp $(OUTPUT_DIR)/$(BINARY) $(PI_HOST):/home/pi/
	@echo "Deployed to $(PI_HOST)"
```

---

## Sources

- [cross-rs/cross GitHub Repository](https://github.com/cross-rs/cross)
- [cross-rs Configuration Wiki](https://github.com/cross-rs/cross/wiki/Configuration)
- [cross-rs Custom Images Documentation](https://github.com/cross-rs/cross/blob/main/docs/custom_images.md)
- [dbus-rs Cross Compilation Guide](https://github.com/diwic/dbus-rs/blob/master/libdbus-sys/cross_compile.md)
- [BlueR GitHub Repository](https://github.com/bluez/bluer)
- [min-sized-rust Guide](https://github.com/johnthagen/min-sized-rust)
- [Rust Performance Book - Build Configuration](https://nnethercote.github.io/perf-book/build-configuration.html)
- [n0-computer/dumbpipe GitHub Repository](https://github.com/n0-computer/dumbpipe)

---

### Critical Files for Implementation

1. `/Users/jeffrey/code/tether/Cross.toml` - Core cross-compilation configuration with pre-build commands for armhf library installation
2. `/Users/jeffrey/code/tether/.cargo/config.toml` - Linker configuration and release profile optimization settings
3. `/Users/jeffrey/code/tether/scripts/build-pi.sh` - Main build script orchestrating cross, Docker, stripping, and verification
4. `/Users/jeffrey/code/tether/docker/Dockerfile.armv7` - Custom Docker image with armhf libdbus-1-dev if pre-build approach fails
5. `/Users/jeffrey/code/tether/Cargo.toml` - Add release-pi profile with LTO, strip, and size optimization settings
