Now I have comprehensive information about utoipa. Let me compile the complete implementation details.

---

# Excruciating Implementation Details: OpenAPI Generation with utoipa for tether

This document provides copy-paste ready code and complete implementation details for generating an OpenAPI 3.0 specification from Rust types using `utoipa` and `utoipa-axum`. The generated spec will be consumed by:

1. **Web UI**: `@hey-api/openapi-ts` generates TypeScript client
2. **MCP Server**: `rmcp-openapi` generates MCP tools from the spec

---

## 1. Cargo Dependencies

Add these to your `Cargo.toml`:

```toml
[dependencies]
# Core web framework
axum = "0.8"
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"

# OpenAPI generation
utoipa = { version = "5", features = ["axum_extras", "chrono", "uuid"] }
utoipa-axum = "0.2"

# For date/time handling in schemas
chrono = { version = "0.4", features = ["serde"] }

[dev-dependencies]
# For the spec generation binary
utoipa = { version = "5", features = ["axum_extras", "chrono", "uuid"] }
```

---

## 2. Complete `routes/openapi.rs` Implementation

```rust
//! OpenAPI specification generation for tether API.
//!
//! This module generates an OpenAPI 3.0 specification that is consumed by:
//! - Web UI (via @hey-api/openapi-ts for TypeScript client generation)
//! - MCP Server (via rmcp-openapi for AI tool generation)
//!
//! IMPORTANT: Descriptions are written to be understood by AI agents via MCP.
//! Each endpoint description should explain:
//! - What the endpoint does
//! - When to use it
//! - What the response means
//! - Any side effects or important behaviors

use axum::{extract::State, http::StatusCode, Json};
use serde::{Deserialize, Serialize};
use utoipa::{
    openapi::security::{ApiKey, ApiKeyValue, SecurityScheme},
    IntoParams, Modify, OpenApi, ToSchema,
};
use utoipa_axum::{router::OpenApiRouter, routes};

// ============================================================================
// SCHEMA DEFINITIONS
// ============================================================================

/// Represents the proximity status of a Bluetooth device to the Raspberry Pi.
/// This is the core functionality of tether - determining if your phone is
/// where it should be at night.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(
    example = json!({
        "device_name": "iPhone",
        "device_address": "AA:BB:CC:DD:EE:FF",
        "is_nearby": true,
        "signal_strength_dbm": -45,
        "threshold_dbm": -70,
        "last_seen_utc": "2024-01-15T22:30:00Z"
    })
)]
pub struct ProximityStatus {
    /// Human-readable name of the Bluetooth device being tracked.
    /// This is the name that appears in Bluetooth settings.
    #[schema(example = "iPhone")]
    pub device_name: String,

    /// MAC address of the Bluetooth device in colon-separated hexadecimal format.
    /// Example: "AA:BB:CC:DD:EE:FF"
    #[schema(example = "AA:BB:CC:DD:EE:FF")]
    pub device_address: String,

    /// Whether the device is considered "nearby" based on signal strength threshold.
    /// TRUE means the phone is close to the Raspberry Pi (good - phone is put away).
    /// FALSE means the phone is NOT close to the Raspberry Pi (bad - phone might be in bedroom).
    #[schema(example = true)]
    pub is_nearby: bool,

    /// Current Bluetooth signal strength in decibels relative to one milliwatt (dBm).
    /// Typical values range from -30 dBm (very close) to -90 dBm (far away).
    /// A value of null means the device was not detected at all.
    #[schema(example = -45, nullable)]
    pub signal_strength_dbm: Option<i32>,

    /// The configured threshold in dBm. Signal strength must be greater than or equal
    /// to this value for the device to be considered "nearby".
    /// Higher values (closer to 0) require the device to be physically closer.
    #[schema(example = -70)]
    pub threshold_dbm: i32,

    /// ISO 8601 timestamp (UTC) of when the device was last detected.
    /// If the device has never been seen, this will be null.
    #[schema(example = "2024-01-15T22:30:00Z", nullable)]
    pub last_seen_utc: Option<String>,
}

/// Response wrapper for proximity check endpoint.
/// Contains the proximity status and additional metadata.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(
    example = json!({
        "status": {
            "device_name": "iPhone",
            "device_address": "AA:BB:CC:DD:EE:FF",
            "is_nearby": true,
            "signal_strength_dbm": -45,
            "threshold_dbm": -70,
            "last_seen_utc": "2024-01-15T22:30:00Z"
        },
        "checked_at_utc": "2024-01-15T22:30:05Z"
    })
)]
pub struct ProximityResponse {
    /// The current proximity status of the tracked device.
    pub status: ProximityStatus,

    /// ISO 8601 timestamp (UTC) of when this check was performed.
    /// tether performs lazy checks - proximity is only evaluated when requested.
    #[schema(example = "2024-01-15T22:30:05Z")]
    pub checked_at_utc: String,
}

/// Represents a single emergency pass that allows the user to keep their phone
/// nearby for a night. Passes are limited per month to maintain accountability.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(
    example = json!({
        "id": "pass_2024_01_15_001",
        "used_at_utc": "2024-01-15T23:00:00Z",
        "reason": "On-call for work emergency",
        "month": "2024-01"
    })
)]
pub struct Pass {
    /// Unique identifier for this pass.
    #[schema(example = "pass_2024_01_15_001")]
    pub id: String,

    /// ISO 8601 timestamp (UTC) of when this pass was used.
    #[schema(example = "2024-01-15T23:00:00Z")]
    pub used_at_utc: String,

    /// User-provided reason for using this pass.
    /// This is required to encourage mindful usage of emergency passes.
    #[schema(example = "On-call for work emergency", min_length = 1, max_length = 500)]
    pub reason: String,

    /// The month this pass belongs to in YYYY-MM format.
    /// Passes are allocated and tracked per calendar month.
    #[schema(example = "2024-01")]
    pub month: String,
}

/// Summary of pass availability for the current month.
/// This helps users understand their remaining emergency passes.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(
    example = json!({
        "month": "2024-01",
        "total_passes": 3,
        "used_passes": 1,
        "remaining_passes": 2,
        "next_refresh_utc": "2024-02-01T00:00:00Z"
    })
)]
pub struct PassSummary {
    /// The month these statistics apply to in YYYY-MM format.
    #[schema(example = "2024-01")]
    pub month: String,

    /// Total number of passes allocated for this month.
    /// This is configured in settings but changes only take effect next month.
    #[schema(example = 3, minimum = 0, maximum = 31)]
    pub total_passes: u32,

    /// Number of passes already used this month.
    #[schema(example = 1, minimum = 0)]
    pub used_passes: u32,

    /// Number of passes still available this month.
    /// When this reaches 0, no more passes can be used until next month.
    #[schema(example = 2, minimum = 0)]
    pub remaining_passes: u32,

    /// ISO 8601 timestamp (UTC) of when passes will refresh.
    /// This is always midnight UTC on the first day of the next month.
    #[schema(example = "2024-02-01T00:00:00Z")]
    pub next_refresh_utc: String,
}

/// Request body for using an emergency pass.
/// A reason is required to encourage mindful usage.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(
    example = json!({
        "reason": "Family emergency - need to be reachable overnight"
    })
)]
pub struct UsePassRequest {
    /// A brief explanation of why you need your phone nearby tonight.
    /// This helps you reflect on whether it's truly necessary.
    /// Must be between 1 and 500 characters.
    #[schema(example = "Family emergency - need to be reachable overnight", min_length = 1, max_length = 500)]
    pub reason: String,
}

/// Response when successfully using a pass.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(
    example = json!({
        "pass": {
            "id": "pass_2024_01_15_001",
            "used_at_utc": "2024-01-15T23:00:00Z",
            "reason": "Family emergency - need to be reachable overnight",
            "month": "2024-01"
        },
        "remaining_passes": 2,
        "message": "Pass used successfully. You have 2 passes remaining this month."
    })
)]
pub struct UsePassResponse {
    /// The pass that was just used.
    pub pass: Pass,

    /// Number of passes remaining after using this one.
    #[schema(example = 2, minimum = 0)]
    pub remaining_passes: u32,

    /// Human-readable confirmation message.
    #[schema(example = "Pass used successfully. You have 2 passes remaining this month.")]
    pub message: String,
}

/// History of passes for a specific month.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(
    example = json!({
        "month": "2024-01",
        "passes": [
            {
                "id": "pass_2024_01_15_001",
                "used_at_utc": "2024-01-15T23:00:00Z",
                "reason": "On-call for work",
                "month": "2024-01"
            }
        ],
        "summary": {
            "month": "2024-01",
            "total_passes": 3,
            "used_passes": 1,
            "remaining_passes": 2,
            "next_refresh_utc": "2024-02-01T00:00:00Z"
        }
    })
)]
pub struct PassHistory {
    /// The month this history is for in YYYY-MM format.
    #[schema(example = "2024-01")]
    pub month: String,

    /// List of all passes used in this month, ordered by usage time.
    pub passes: Vec<Pass>,

    /// Summary statistics for this month.
    pub summary: PassSummary,
}

/// Query parameters for fetching pass history.
#[derive(Debug, Clone, Deserialize, IntoParams)]
#[into_params(parameter_in = Query)]
pub struct PassHistoryQuery {
    /// The month to fetch history for in YYYY-MM format.
    /// If not provided, defaults to the current month.
    /// Example: "2024-01" for January 2024.
    #[param(example = "2024-01", pattern = r"^\d{4}-(0[1-9]|1[0-2])$")]
    pub month: Option<String>,
}

/// Error response returned when an operation fails.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(
    example = json!({
        "error": "no_passes_remaining",
        "message": "You have no emergency passes remaining this month. Passes refresh on 2024-02-01.",
        "details": {
            "remaining_passes": 0,
            "next_refresh_utc": "2024-02-01T00:00:00Z"
        }
    })
)]
pub struct ApiError {
    /// Machine-readable error code.
    /// Possible values:
    /// - "no_passes_remaining": All passes for the month are used
    /// - "device_not_found": Bluetooth device not detected
    /// - "invalid_request": Request validation failed
    /// - "internal_error": Unexpected server error
    #[schema(example = "no_passes_remaining")]
    pub error: String,

    /// Human-readable error message explaining what went wrong.
    #[schema(example = "You have no emergency passes remaining this month.")]
    pub message: String,

    /// Additional context-specific details about the error.
    /// The structure varies depending on the error type.
    #[schema(nullable)]
    pub details: Option<serde_json::Value>,
}

/// The dumbpipe ticket for secure remote access to this Raspberry Pi.
/// This ticket allows the MCP server to connect via iroh P2P network.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(
    example = json!({
        "ticket": "blobabcdef1234567890...",
        "created_at_utc": "2024-01-15T10:00:00Z",
        "description": "Use this ticket to connect remotely via dumbpipe."
    })
)]
pub struct DumbpipeTicket {
    /// The base64-encoded dumbpipe ticket string.
    /// This should be stored securely and used as an environment variable
    /// for the MCP server.
    #[schema(example = "blobabcdef1234567890...")]
    pub ticket: String,

    /// ISO 8601 timestamp (UTC) of when this ticket was generated.
    #[schema(example = "2024-01-15T10:00:00Z")]
    pub created_at_utc: String,

    /// Human-readable instructions for using this ticket.
    #[schema(example = "Use this ticket to connect remotely via dumbpipe.")]
    pub description: String,
}

/// Bluetooth device information for configuration.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(
    example = json!({
        "address": "AA:BB:CC:DD:EE:FF",
        "name": "iPhone",
        "signal_strength_dbm": -45,
        "last_seen_utc": "2024-01-15T22:30:00Z"
    })
)]
pub struct BluetoothDevice {
    /// MAC address of the Bluetooth device.
    #[schema(example = "AA:BB:CC:DD:EE:FF")]
    pub address: String,

    /// Human-readable device name (may be null if not available).
    #[schema(example = "iPhone", nullable)]
    pub name: Option<String>,

    /// Current signal strength in dBm (if device is currently visible).
    #[schema(example = -45, nullable)]
    pub signal_strength_dbm: Option<i32>,

    /// When this device was last seen by the Raspberry Pi.
    #[schema(example = "2024-01-15T22:30:00Z", nullable)]
    pub last_seen_utc: Option<String>,
}

/// Current tether configuration.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(
    example = json!({
        "target_device": {
            "address": "AA:BB:CC:DD:EE:FF",
            "name": "iPhone",
            "signal_strength_dbm": null,
            "last_seen_utc": null
        },
        "signal_threshold_dbm": -70,
        "passes_per_month": 3,
        "timezone": "America/Los_Angeles",
        "onboarding_complete": true
    })
)]
pub struct TetherConfig {
    /// The Bluetooth device being tracked for proximity.
    pub target_device: BluetoothDevice,

    /// Signal strength threshold in dBm for considering device "nearby".
    /// Higher values (closer to 0) require device to be physically closer.
    #[schema(example = -70, minimum = -100, maximum = 0)]
    pub signal_threshold_dbm: i32,

    /// Number of emergency passes allocated per month.
    /// NOTE: Changes only take effect at the start of the next month.
    #[schema(example = 3, minimum = 0, maximum = 31)]
    pub passes_per_month: u32,

    /// IANA timezone identifier (e.g., "America/Los_Angeles").
    /// Used for determining month boundaries for pass refresh.
    #[schema(example = "America/Los_Angeles")]
    pub timezone: String,

    /// Whether the initial onboarding process has been completed.
    #[schema(example = true)]
    pub onboarding_complete: bool,
}

/// Request to update tether configuration.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(
    example = json!({
        "target_device_address": "AA:BB:CC:DD:EE:FF",
        "signal_threshold_dbm": -70,
        "passes_per_month": 3,
        "timezone": "America/Los_Angeles"
    })
)]
pub struct UpdateConfigRequest {
    /// MAC address of the Bluetooth device to track.
    /// Optional - only include if you want to change the device.
    #[schema(example = "AA:BB:CC:DD:EE:FF", nullable)]
    pub target_device_address: Option<String>,

    /// New signal strength threshold.
    /// Optional - only include if you want to change the threshold.
    #[schema(example = -70, minimum = -100, maximum = 0, nullable)]
    pub signal_threshold_dbm: Option<i32>,

    /// New number of passes per month.
    /// IMPORTANT: Changes take effect at the start of NEXT month.
    #[schema(example = 3, minimum = 0, maximum = 31, nullable)]
    pub passes_per_month: Option<u32>,

    /// New IANA timezone identifier.
    /// Optional - only include if you want to change the timezone.
    #[schema(example = "America/Los_Angeles", nullable)]
    pub timezone: Option<String>,
}

/// Wi-Fi network configuration.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(
    example = json!({
        "ssid": "HomeNetwork",
        "is_primary": true,
        "is_connected": true,
        "signal_strength_percent": 85
    })
)]
pub struct WifiNetwork {
    /// The network SSID (name).
    #[schema(example = "HomeNetwork")]
    pub ssid: String,

    /// Whether this is the primary network the Pi connects to first.
    #[schema(example = true)]
    pub is_primary: bool,

    /// Whether the Pi is currently connected to this network.
    #[schema(example = true)]
    pub is_connected: bool,

    /// Signal strength as a percentage (0-100) if connected.
    #[schema(example = 85, minimum = 0, maximum = 100, nullable)]
    pub signal_strength_percent: Option<u8>,
}

/// Request to add a new Wi-Fi network.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(
    example = json!({
        "ssid": "HomeNetwork",
        "password": "securepassword123",
        "set_as_primary": true
    })
)]
pub struct AddWifiRequest {
    /// Network SSID (name).
    #[schema(example = "HomeNetwork", min_length = 1, max_length = 32)]
    pub ssid: String,

    /// Network password (WPA2).
    #[schema(example = "securepassword123", min_length = 8, max_length = 63)]
    pub password: String,

    /// Whether to set this as the primary network.
    /// If true, the Pi will attempt to connect to this network first.
    #[schema(example = true)]
    pub set_as_primary: bool,
}

/// Simple success response with a message.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(
    example = json!({
        "success": true,
        "message": "Operation completed successfully."
    })
)]
pub struct SuccessResponse {
    /// Whether the operation succeeded.
    #[schema(example = true)]
    pub success: bool,

    /// Human-readable success message.
    #[schema(example = "Operation completed successfully.")]
    pub message: String,
}

// ============================================================================
// HANDLER IMPLEMENTATIONS
// ============================================================================

/// Check if the tracked Bluetooth device is nearby.
///
/// This is tether's core functionality. It performs a lazy Bluetooth scan
/// to check if your phone is within range of the Raspberry Pi. The check
/// only happens when you call this endpoint - tether does not continuously
/// monitor to save battery and resources.
///
/// Use this endpoint to:
/// - Verify your phone is in its designated location at night
/// - Build automations that check phone proximity
/// - Debug Bluetooth signal strength issues
///
/// Returns the device's current proximity status including signal strength
/// and whether it meets the configured threshold.
#[utoipa::path(
    get,
    path = "/api/proximity",
    tag = "Proximity",
    operation_id = "check_proximity",
    summary = "Check if your phone is nearby",
    description = "Performs a Bluetooth scan to check if the tracked device (your phone) is within range of the Raspberry Pi. This is a lazy operation - the check only happens when this endpoint is called. Returns the device's signal strength and whether it meets the configured 'nearby' threshold. A device is considered 'nearby' when its signal strength is greater than or equal to the configured threshold. Use this to verify your phone is in its designated charging spot.",
    responses(
        (status = 200, description = "Proximity check completed successfully. The 'is_nearby' field indicates whether your phone is in range.", body = ProximityResponse),
        (status = 503, description = "Bluetooth is unavailable or device not found. This may be temporary - try again.", body = ApiError)
    )
)]
pub async fn check_proximity() -> Result<Json<ProximityResponse>, (StatusCode, Json<ApiError>)> {
    // Implementation would go here
    todo!()
}

/// Get pass summary for the current month.
///
/// Returns how many emergency passes you have remaining this month.
/// Emergency passes allow you to keep your phone nearby for a night
/// without tether flagging it as a violation.
///
/// Passes refresh automatically at midnight UTC on the first day of each month.
/// The number of passes per month is configurable in settings, but changes
/// only take effect at the start of the next month.
#[utoipa::path(
    get,
    path = "/api/passes",
    tag = "Passes",
    operation_id = "get_passes_remaining",
    summary = "Get remaining emergency passes for this month",
    description = "Returns a summary of emergency pass usage for the current month. Emergency passes allow you to keep your phone nearby for legitimate reasons (being on-call, family emergencies, etc.) without it counting as a violation of your phone-free bedtime goal. The response includes: total passes allocated for the month, how many have been used, how many remain, and when they will refresh. Passes refresh at midnight UTC on the first day of each month.",
    responses(
        (status = 200, description = "Pass summary retrieved successfully", body = PassSummary)
    )
)]
pub async fn get_passes_remaining() -> Json<PassSummary> {
    // Implementation would go here
    todo!()
}

/// Get pass history for a specific month.
///
/// Returns detailed history of all passes used in a given month,
/// including the reason provided for each pass. This helps you
/// track patterns and reflect on your emergency pass usage.
///
/// If no month is specified, returns history for the current month.
#[utoipa::path(
    get,
    path = "/api/passes/history",
    tag = "Passes",
    operation_id = "get_pass_history",
    summary = "Get pass usage history",
    description = "Returns detailed history of emergency pass usage for a specific month. Each pass entry includes the timestamp and the reason that was provided when the pass was used. This helps you reflect on your pass usage patterns over time. If no month parameter is provided, returns history for the current month. Use YYYY-MM format for the month parameter (e.g., '2024-01' for January 2024).",
    params(PassHistoryQuery),
    responses(
        (status = 200, description = "Pass history retrieved successfully", body = PassHistory),
        (status = 400, description = "Invalid month format. Use YYYY-MM format.", body = ApiError)
    )
)]
pub async fn get_pass_history(
    query: axum::extract::Query<PassHistoryQuery>,
) -> Result<Json<PassHistory>, (StatusCode, Json<ApiError>)> {
    // Implementation would go here
    todo!()
}

/// Use an emergency pass.
///
/// Consumes one of your monthly emergency passes. You must provide
/// a reason explaining why you need your phone nearby tonight.
/// This is intentional friction to encourage mindful usage.
///
/// Returns an error if you have no passes remaining this month.
/// Passes refresh automatically at midnight UTC on the first of each month.
#[utoipa::path(
    post,
    path = "/api/passes/use",
    tag = "Passes",
    operation_id = "use_pass",
    summary = "Use an emergency pass",
    description = "Consumes one of your monthly emergency passes, allowing you to keep your phone nearby tonight without it counting as a violation. You MUST provide a reason explaining why you need the pass - this is intentional friction to encourage mindful usage and help you reflect on whether it's truly necessary. Returns an error if you have no passes remaining this month. Passes refresh automatically at midnight UTC on the first day of each month. Common valid reasons include: being on-call for work, family emergencies, travel situations, or medical needs.",
    request_body(
        content = UsePassRequest,
        description = "The reason for using this emergency pass. Must be between 1 and 500 characters."
    ),
    responses(
        (status = 200, description = "Pass used successfully. You can keep your phone nearby tonight.", body = UsePassResponse),
        (status = 400, description = "Invalid request - reason is required and must be 1-500 characters", body = ApiError),
        (status = 409, description = "No passes remaining this month. Wait for the monthly refresh or adjust your settings.", body = ApiError)
    )
)]
pub async fn use_pass(
    Json(request): Json<UsePassRequest>,
) -> Result<Json<UsePassResponse>, (StatusCode, Json<ApiError>)> {
    // Implementation would go here
    todo!()
}

/// Get the dumbpipe ticket for remote access.
///
/// Returns the ticket that allows remote services (like the MCP server)
/// to connect to this Raspberry Pi through the iroh P2P network.
///
/// Keep this ticket secure - anyone with it can connect to your tether instance.
#[utoipa::path(
    get,
    path = "/api/ticket",
    tag = "System",
    operation_id = "get_dumbpipe_ticket",
    summary = "Get the dumbpipe connection ticket",
    description = "Returns the dumbpipe ticket required for remote access to this tether instance. The ticket enables secure P2P connections through the iroh network, allowing the MCP server to communicate with the Raspberry Pi from anywhere. SECURITY NOTE: Keep this ticket secure and treat it like a password. Anyone with this ticket can connect to your tether instance. The ticket should be set as the DUMBPIPE_TICKET environment variable for the MCP server.",
    responses(
        (status = 200, description = "Ticket retrieved successfully", body = DumbpipeTicket),
        (status = 503, description = "dumbpipe is not running or ticket not yet generated", body = ApiError)
    )
)]
pub async fn get_dumbpipe_ticket() -> Result<Json<DumbpipeTicket>, (StatusCode, Json<ApiError>)> {
    // Implementation would go here
    todo!()
}

/// Get current tether configuration.
#[utoipa::path(
    get,
    path = "/api/config",
    tag = "Configuration",
    operation_id = "get_config",
    summary = "Get current configuration",
    description = "Returns the current tether configuration including: the Bluetooth device being tracked, signal strength threshold, passes per month, timezone, and onboarding status. This is useful for displaying current settings in the UI or for debugging configuration issues.",
    responses(
        (status = 200, description = "Configuration retrieved successfully", body = TetherConfig)
    )
)]
pub async fn get_config() -> Json<TetherConfig> {
    // Implementation would go here
    todo!()
}

/// Update tether configuration.
///
/// Allows updating various settings. Note that some changes have delayed effects:
/// - passes_per_month: Takes effect at the start of NEXT month
/// - target_device_address: Takes effect immediately
/// - signal_threshold_dbm: Takes effect immediately
/// - timezone: Takes effect immediately
#[utoipa::path(
    patch,
    path = "/api/config",
    tag = "Configuration",
    operation_id = "update_config",
    summary = "Update configuration settings",
    description = "Updates tether configuration settings. You can update any combination of settings in a single request - only include the fields you want to change. IMPORTANT TIMING NOTES: (1) Changes to 'passes_per_month' only take effect at the start of the NEXT month to prevent gaming the system mid-month. (2) Changes to 'target_device_address', 'signal_threshold_dbm', and 'timezone' take effect immediately. After changing the target device, you should verify it's working with a proximity check.",
    request_body(
        content = UpdateConfigRequest,
        description = "Configuration fields to update. Only include fields you want to change."
    ),
    responses(
        (status = 200, description = "Configuration updated successfully", body = TetherConfig),
        (status = 400, description = "Invalid configuration value", body = ApiError)
    )
)]
pub async fn update_config(
    Json(request): Json<UpdateConfigRequest>,
) -> Result<Json<TetherConfig>, (StatusCode, Json<ApiError>)> {
    // Implementation would go here
    todo!()
}

/// List visible Bluetooth devices.
///
/// Scans for nearby Bluetooth devices. Useful during setup to find
/// your phone's Bluetooth address.
#[utoipa::path(
    get,
    path = "/api/bluetooth/devices",
    tag = "Configuration",
    operation_id = "list_bluetooth_devices",
    summary = "List visible Bluetooth devices",
    description = "Performs a Bluetooth scan and returns a list of all visible devices. Use this during initial setup to find your phone's Bluetooth address, or to troubleshoot if your phone isn't being detected. The scan typically takes 5-10 seconds. Each device includes its MAC address, name (if available), and current signal strength.",
    responses(
        (status = 200, description = "Scan completed successfully", body = Vec<BluetoothDevice>),
        (status = 503, description = "Bluetooth is unavailable", body = ApiError)
    )
)]
pub async fn list_bluetooth_devices() -> Result<Json<Vec<BluetoothDevice>>, (StatusCode, Json<ApiError>)> {
    // Implementation would go here
    todo!()
}

/// List configured Wi-Fi networks.
#[utoipa::path(
    get,
    path = "/api/wifi/networks",
    tag = "Configuration",
    operation_id = "list_wifi_networks",
    summary = "List configured Wi-Fi networks",
    description = "Returns all Wi-Fi networks configured on this tether instance, including which one is primary and which one is currently connected. The Raspberry Pi will attempt to connect to networks in priority order, falling back to the temporary setup network if none are available.",
    responses(
        (status = 200, description = "Networks retrieved successfully", body = Vec<WifiNetwork>)
    )
)]
pub async fn list_wifi_networks() -> Json<Vec<WifiNetwork>> {
    // Implementation would go here
    todo!()
}

/// Add a new Wi-Fi network.
#[utoipa::path(
    post,
    path = "/api/wifi/networks",
    tag = "Configuration",
    operation_id = "add_wifi_network",
    summary = "Add a Wi-Fi network",
    description = "Adds a new Wi-Fi network to the configuration. If 'set_as_primary' is true, this becomes the primary network and the Raspberry Pi will attempt to connect to it. When a new primary network is set, you may need to reconnect to the Pi on that network. The network password is stored securely on the device.",
    request_body(
        content = AddWifiRequest,
        description = "Wi-Fi network credentials and settings"
    ),
    responses(
        (status = 201, description = "Network added successfully", body = WifiNetwork),
        (status = 400, description = "Invalid SSID or password", body = ApiError),
        (status = 409, description = "Network already configured", body = ApiError)
    )
)]
pub async fn add_wifi_network(
    Json(request): Json<AddWifiRequest>,
) -> Result<(StatusCode, Json<WifiNetwork>), (StatusCode, Json<ApiError>)> {
    // Implementation would go here
    todo!()
}

/// Remove a Wi-Fi network.
#[utoipa::path(
    delete,
    path = "/api/wifi/networks/{ssid}",
    tag = "Configuration",
    operation_id = "remove_wifi_network",
    summary = "Remove a Wi-Fi network",
    description = "Removes a Wi-Fi network from the configuration. You cannot remove the currently connected network or the last remaining network. If you remove the primary network, the next network in the list becomes primary.",
    params(
        ("ssid" = String, Path, description = "The SSID (name) of the network to remove")
    ),
    responses(
        (status = 200, description = "Network removed successfully", body = SuccessResponse),
        (status = 400, description = "Cannot remove currently connected or last network", body = ApiError),
        (status = 404, description = "Network not found", body = ApiError)
    )
)]
pub async fn remove_wifi_network(
    axum::extract::Path(ssid): axum::extract::Path<String>,
) -> Result<Json<SuccessResponse>, (StatusCode, Json<ApiError>)> {
    // Implementation would go here
    todo!()
}

/// Restart the Raspberry Pi system.
///
/// This will restart the entire system, including all tether services.
/// The system will be unavailable for approximately 30-60 seconds.
#[utoipa::path(
    post,
    path = "/api/system/restart",
    tag = "System",
    operation_id = "restart_system",
    summary = "Restart the system",
    description = "Initiates a complete system restart of the Raspberry Pi. This will temporarily make tether unavailable for approximately 30-60 seconds while the system reboots. Use this if you're experiencing issues or after major configuration changes. The response is sent before the restart begins, so you won't receive an error even though the connection will drop.",
    responses(
        (status = 202, description = "Restart initiated. System will be unavailable for ~30-60 seconds.", body = SuccessResponse)
    )
)]
pub async fn restart_system() -> (StatusCode, Json<SuccessResponse>) {
    // Implementation would go here
    todo!()
}

/// Serve the OpenAPI specification as JSON.
///
/// Returns the complete OpenAPI 3.0 specification for this API.
/// This is used by code generators and documentation tools.
#[utoipa::path(
    get,
    path = "/api/openapi.json",
    tag = "Documentation",
    operation_id = "get_openapi_spec",
    summary = "Get OpenAPI specification",
    description = "Returns the complete OpenAPI 3.0 specification for the tether API in JSON format. This specification is used by: (1) The web UI to generate a type-safe TypeScript client via @hey-api/openapi-ts, and (2) The MCP server to generate AI-consumable tools via rmcp-openapi. The specification includes detailed descriptions designed to help AI agents understand each endpoint's purpose and behavior.",
    responses(
        (status = 200, description = "OpenAPI specification", content_type = "application/json")
    )
)]
pub async fn get_openapi_spec() -> Json<utoipa::openapi::OpenApi> {
    Json(ApiDoc::openapi())
}

// ============================================================================
// OPENAPI DOCUMENT CONFIGURATION
// ============================================================================

/// Main OpenAPI document structure for tether.
///
/// This struct collects all paths and schemas to generate the complete
/// OpenAPI 3.0 specification. The specification is designed to be consumed
/// by both human developers and AI agents (via MCP).
#[derive(OpenApi)]
#[openapi(
    info(
        title = "tether API",
        version = "1.0.0",
        description = r#"
# tether API

tether helps you hold yourself accountable to keep your phone away from your bedroom at night.

## Overview

This API runs on a Raspberry Pi and provides:

1. **Proximity Detection**: Check if your phone is near the Raspberry Pi via Bluetooth
2. **Emergency Passes**: A limited number of monthly passes for legitimate exceptions
3. **Configuration**: Manage Bluetooth devices, Wi-Fi networks, and settings
4. **Remote Access**: Secure P2P connection via dumbpipe/iroh

## For AI Agents (MCP)

If you're accessing this API via MCP tools, here's what you need to know:

- **check_proximity**: Use this to verify the phone is in its designated spot. Returns `is_nearby: true` when the phone is close to the Pi.
- **get_passes_remaining**: Check how many emergency passes are left this month.
- **use_pass**: Use this when the user has a legitimate reason to keep their phone (on-call, emergency, etc.). Requires a reason.
- **get_pass_history**: Review past pass usage to identify patterns.

## Design Philosophy

- **Lazy evaluation**: Bluetooth checks only happen when requested
- **Intentional friction**: Passes require reasons to encourage mindfulness
- **Delayed effects**: Pass count changes only apply next month to prevent gaming

## Authentication

This API is designed to run on a local network and does not require authentication.
Remote access is secured via dumbpipe tickets.
"#,
        contact(
            name = "tether",
            url = "https://github.com/your-repo/tether"
        ),
        license(
            name = "MIT",
            url = "https://opensource.org/licenses/MIT"
        )
    ),
    servers(
        (url = "/", description = "Local Raspberry Pi"),
    ),
    tags(
        (
            name = "Proximity",
            description = "Core functionality - check if your phone is near the Raspberry Pi. This is what tether is all about: ensuring your phone is in its designated spot at night."
        ),
        (
            name = "Passes",
            description = "Emergency pass management. Passes allow you to keep your phone nearby for legitimate reasons without it counting against you. You get a limited number per month that refresh automatically."
        ),
        (
            name = "Configuration",
            description = "Manage tether settings including: which Bluetooth device to track, signal strength thresholds, Wi-Fi networks, timezone, and passes per month. Some settings have delayed effects."
        ),
        (
            name = "System",
            description = "System-level operations including restart and remote access ticket management."
        ),
        (
            name = "Documentation",
            description = "API documentation and specification endpoints."
        )
    ),
    paths(
        check_proximity,
        get_passes_remaining,
        get_pass_history,
        use_pass,
        get_dumbpipe_ticket,
        get_config,
        update_config,
        list_bluetooth_devices,
        list_wifi_networks,
        add_wifi_network,
        remove_wifi_network,
        restart_system,
        get_openapi_spec
    ),
    components(
        schemas(
            ProximityStatus,
            ProximityResponse,
            Pass,
            PassSummary,
            UsePassRequest,
            UsePassResponse,
            PassHistory,
            ApiError,
            DumbpipeTicket,
            BluetoothDevice,
            TetherConfig,
            UpdateConfigRequest,
            WifiNetwork,
            AddWifiRequest,
            SuccessResponse
        )
    )
)]
pub struct ApiDoc;

// ============================================================================
// ROUTER CONSTRUCTION
// ============================================================================

/// Creates the OpenAPI router with all endpoints registered.
///
/// Returns both the axum Router and the OpenApi specification.
/// Use `split_for_parts()` to extract them separately.
pub fn create_openapi_router() -> OpenApiRouter {
    OpenApiRouter::new()
        // Proximity endpoints
        .routes(routes!(check_proximity))
        // Pass endpoints
        .routes(routes!(get_passes_remaining))
        .routes(routes!(get_pass_history))
        .routes(routes!(use_pass))
        // System endpoints
        .routes(routes!(get_dumbpipe_ticket))
        .routes(routes!(restart_system))
        // Configuration endpoints
        .routes(routes!(get_config))
        .routes(routes!(update_config))
        .routes(routes!(list_bluetooth_devices))
        .routes(routes!(list_wifi_networks))
        .routes(routes!(add_wifi_network))
        .routes(routes!(remove_wifi_network))
        // Documentation
        .routes(routes!(get_openapi_spec))
}

/// Builds the complete router and returns both router and spec.
pub fn build_api() -> (axum::Router, utoipa::openapi::OpenApi) {
    create_openapi_router().split_for_parts()
}
```

---

## 3. Exporting OpenAPI Spec at Build Time

There are two approaches for generating the OpenAPI spec file for consumption by the web UI and MCP server.

### Approach A: Dedicated Binary (Recommended)

Create a separate binary that generates the spec file. This is cleaner than build.rs because utoipa macros are resolved at compile time.

**File: `src/bin/gen_openapi.rs`**

```rust
//! Generates the OpenAPI specification to a JSON file.
//!
//! Run with: cargo run --bin gen-openapi
//!
//! The generated file is placed in a location accessible to both:
//! - Web UI (for @hey-api/openapi-ts TypeScript client generation)
//! - MCP server (for rmcp-openapi tool generation)

use std::fs;
use std::path::PathBuf;
use utoipa::OpenApi;

// Import your API documentation struct
// Adjust the path based on your crate structure
use tether_server::routes::openapi::ApiDoc;

fn main() {
    println!("Generating OpenAPI specification...");

    // Generate the OpenAPI spec
    let spec = ApiDoc::openapi();

    // Serialize to pretty JSON
    let json = spec
        .to_pretty_json()
        .expect("Failed to serialize OpenAPI spec to JSON");

    // Define output paths
    let project_root = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    
    // Output to multiple locations for different consumers
    let output_paths = [
        // For the web UI TypeScript client generation
        project_root.join("web-ui/openapi.json"),
        // For the MCP server
        project_root.join("mcp-server/openapi.json"),
        // For documentation/reference
        project_root.join("docs/openapi.json"),
    ];

    for output_path in &output_paths {
        // Create parent directories if they don't exist
        if let Some(parent) = output_path.parent() {
            fs::create_dir_all(parent)
                .unwrap_or_else(|e| panic!("Failed to create directory {:?}: {}", parent, e));
        }

        // Write the spec
        fs::write(output_path, &json)
            .unwrap_or_else(|e| panic!("Failed to write to {:?}: {}", output_path, e));

        println!("  Written to: {}", output_path.display());
    }

    // Print summary
    println!("\nOpenAPI specification generated successfully!");
    println!("Version: {}", spec.info.version);
    println!("Paths: {}", spec.paths.paths.len());
    println!(
        "Schemas: {}",
        spec.components
            .as_ref()
            .map(|c| c.schemas.len())
            .unwrap_or(0)
    );
}
```

**Add to `Cargo.toml`:**

```toml
[[bin]]
name = "gen-openapi"
path = "src/bin/gen_openapi.rs"
```

### Approach B: Makefile/Just Integration

Create a `justfile` or `Makefile` that orchestrates the build:

**File: `justfile`**

```justfile
# Generate OpenAPI spec and TypeScript client
generate-api:
    cargo run --bin gen-openapi
    cd web-ui && bunx @hey-api/openapi-ts -i ./openapi.json -o ./src/api

# Full build including API generation
build: generate-api
    cargo build --release
    cd web-ui && bun run build

# Development with auto-regeneration
dev:
    cargo watch -x "run --bin gen-openapi" &
    cd web-ui && bun run dev
```

### Approach C: Build Script (build.rs)

This is more complex because you need to compile and run the code during the build phase. Only use this if you need the spec to be regenerated on every build.

**File: `build.rs`**

```rust
//! Build script that generates OpenAPI spec.
//!
//! NOTE: This approach requires careful dependency management because
//! the build script runs before the main crate is compiled.

use std::env;
use std::fs;
use std::path::PathBuf;
use std::process::Command;

fn main() {
    println!("cargo:rerun-if-changed=src/routes/openapi.rs");
    println!("cargo:rerun-if-changed=src/models/");

    // Get output directory
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());

    // Build and run the gen-openapi binary
    let status = Command::new("cargo")
        .args(["run", "--bin", "gen-openapi"])
        .current_dir(&manifest_dir)
        .status()
        .expect("Failed to run gen-openapi");

    if !status.success() {
        panic!("gen-openapi failed with status: {}", status);
    }

    // Copy to OUT_DIR for include_str! if needed
    let spec_path = manifest_dir.join("docs/openapi.json");
    if spec_path.exists() {
        let dest = out_dir.join("openapi.json");
        fs::copy(&spec_path, &dest).expect("Failed to copy openapi.json to OUT_DIR");
    }
}
```

---

## 4. Example Generated OpenAPI JSON Structure

Here is a representative excerpt of what the generated `openapi.json` will look like:

```json
{
  "openapi": "3.1.0",
  "info": {
    "title": "tether API",
    "description": "\n# tether API\n\ntether helps you hold yourself accountable to keep your phone away from your bedroom at night.\n\n## Overview\n\nThis API runs on a Raspberry Pi and provides:\n\n1. **Proximity Detection**: Check if your phone is near the Raspberry Pi via Bluetooth\n2. **Emergency Passes**: A limited number of monthly passes for legitimate exceptions\n3. **Configuration**: Manage Bluetooth devices, Wi-Fi networks, and settings\n4. **Remote Access**: Secure P2P connection via dumbpipe/iroh\n\n## For AI Agents (MCP)\n\nIf you're accessing this API via MCP tools, here's what you need to know:\n\n- **check_proximity**: Use this to verify the phone is in its designated spot. Returns `is_nearby: true` when the phone is close to the Pi.\n- **get_passes_remaining**: Check how many emergency passes are left this month.\n- **use_pass**: Use this when the user has a legitimate reason to keep their phone (on-call, emergency, etc.). Requires a reason.\n- **get_pass_history**: Review past pass usage to identify patterns.\n\n## Design Philosophy\n\n- **Lazy evaluation**: Bluetooth checks only happen when requested\n- **Intentional friction**: Passes require reasons to encourage mindfulness\n- **Delayed effects**: Pass count changes only apply next month to prevent gaming\n\n## Authentication\n\nThis API is designed to run on a local network and does not require authentication.\nRemote access is secured via dumbpipe tickets.\n",
    "contact": {
      "name": "tether",
      "url": "https://github.com/your-repo/tether"
    },
    "license": {
      "name": "MIT",
      "url": "https://opensource.org/licenses/MIT"
    },
    "version": "1.0.0"
  },
  "servers": [
    {
      "url": "/",
      "description": "Local Raspberry Pi"
    }
  ],
  "paths": {
    "/api/proximity": {
      "get": {
        "tags": ["Proximity"],
        "summary": "Check if your phone is nearby",
        "description": "Performs a Bluetooth scan to check if the tracked device (your phone) is within range of the Raspberry Pi. This is a lazy operation - the check only happens when this endpoint is called. Returns the device's signal strength and whether it meets the configured 'nearby' threshold. A device is considered 'nearby' when its signal strength is greater than or equal to the configured threshold. Use this to verify your phone is in its designated charging spot.",
        "operationId": "check_proximity",
        "responses": {
          "200": {
            "description": "Proximity check completed successfully. The 'is_nearby' field indicates whether your phone is in range.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProximityResponse"
                }
              }
            }
          },
          "503": {
            "description": "Bluetooth is unavailable or device not found. This may be temporary - try again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiError"
                }
              }
            }
          }
        }
      }
    },
    "/api/passes": {
      "get": {
        "tags": ["Passes"],
        "summary": "Get remaining emergency passes for this month",
        "description": "Returns a summary of emergency pass usage for the current month. Emergency passes allow you to keep your phone nearby for legitimate reasons (being on-call, family emergencies, etc.) without it counting as a violation of your phone-free bedtime goal. The response includes: total passes allocated for the month, how many have been used, how many remain, and when they will refresh. Passes refresh at midnight UTC on the first day of each month.",
        "operationId": "get_passes_remaining",
        "responses": {
          "200": {
            "description": "Pass summary retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PassSummary"
                }
              }
            }
          }
        }
      }
    },
    "/api/passes/history": {
      "get": {
        "tags": ["Passes"],
        "summary": "Get pass usage history",
        "description": "Returns detailed history of emergency pass usage for a specific month. Each pass entry includes the timestamp and the reason that was provided when the pass was used. This helps you reflect on your pass usage patterns over time. If no month parameter is provided, returns history for the current month. Use YYYY-MM format for the month parameter (e.g., '2024-01' for January 2024).",
        "operationId": "get_pass_history",
        "parameters": [
          {
            "name": "month",
            "in": "query",
            "description": "The month to fetch history for in YYYY-MM format. If not provided, defaults to the current month. Example: \"2024-01\" for January 2024.",
            "required": false,
            "schema": {
              "type": "string",
              "pattern": "^\\d{4}-(0[1-9]|1[0-2])$",
              "example": "2024-01"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Pass history retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PassHistory"
                }
              }
            }
          },
          "400": {
            "description": "Invalid month format. Use YYYY-MM format.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiError"
                }
              }
            }
          }
        }
      }
    },
    "/api/passes/use": {
      "post": {
        "tags": ["Passes"],
        "summary": "Use an emergency pass",
        "description": "Consumes one of your monthly emergency passes, allowing you to keep your phone nearby tonight without it counting as a violation. You MUST provide a reason explaining why you need the pass - this is intentional friction to encourage mindful usage and help you reflect on whether it's truly necessary. Returns an error if you have no passes remaining this month. Passes refresh automatically at midnight UTC on the first day of each month. Common valid reasons include: being on-call for work, family emergencies, travel situations, or medical needs.",
        "operationId": "use_pass",
        "requestBody": {
          "description": "The reason for using this emergency pass. Must be between 1 and 500 characters.",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UsePassRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Pass used successfully. You can keep your phone nearby tonight.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UsePassResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request - reason is required and must be 1-500 characters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiError"
                }
              }
            }
          },
          "409": {
            "description": "No passes remaining this month. Wait for the monthly refresh or adjust your settings.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiError"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "ProximityStatus": {
        "type": "object",
        "required": ["device_name", "device_address", "is_nearby", "threshold_dbm"],
        "properties": {
          "device_name": {
            "type": "string",
            "description": "Human-readable name of the Bluetooth device being tracked. This is the name that appears in Bluetooth settings.",
            "example": "iPhone"
          },
          "device_address": {
            "type": "string",
            "description": "MAC address of the Bluetooth device in colon-separated hexadecimal format. Example: \"AA:BB:CC:DD:EE:FF\"",
            "example": "AA:BB:CC:DD:EE:FF"
          },
          "is_nearby": {
            "type": "boolean",
            "description": "Whether the device is considered \"nearby\" based on signal strength threshold. TRUE means the phone is close to the Raspberry Pi (good - phone is put away). FALSE means the phone is NOT close to the Raspberry Pi (bad - phone might be in bedroom).",
            "example": true
          },
          "signal_strength_dbm": {
            "type": "integer",
            "format": "int32",
            "description": "Current Bluetooth signal strength in decibels relative to one milliwatt (dBm). Typical values range from -30 dBm (very close) to -90 dBm (far away). A value of null means the device was not detected at all.",
            "nullable": true,
            "example": -45
          },
          "threshold_dbm": {
            "type": "integer",
            "format": "int32",
            "description": "The configured threshold in dBm. Signal strength must be greater than or equal to this value for the device to be considered \"nearby\". Higher values (closer to 0) require the device to be physically closer.",
            "example": -70
          },
          "last_seen_utc": {
            "type": "string",
            "description": "ISO 8601 timestamp (UTC) of when the device was last detected. If the device has never been seen, this will be null.",
            "nullable": true,
            "example": "2024-01-15T22:30:00Z"
          }
        },
        "example": {
          "device_name": "iPhone",
          "device_address": "AA:BB:CC:DD:EE:FF",
          "is_nearby": true,
          "signal_strength_dbm": -45,
          "threshold_dbm": -70,
          "last_seen_utc": "2024-01-15T22:30:00Z"
        }
      },
      "ProximityResponse": {
        "type": "object",
        "required": ["status", "checked_at_utc"],
        "properties": {
          "status": {
            "$ref": "#/components/schemas/ProximityStatus"
          },
          "checked_at_utc": {
            "type": "string",
            "description": "ISO 8601 timestamp (UTC) of when this check was performed. tether performs lazy checks - proximity is only evaluated when requested.",
            "example": "2024-01-15T22:30:05Z"
          }
        },
        "example": {
          "status": {
            "device_name": "iPhone",
            "device_address": "AA:BB:CC:DD:EE:FF",
            "is_nearby": true,
            "signal_strength_dbm": -45,
            "threshold_dbm": -70,
            "last_seen_utc": "2024-01-15T22:30:00Z"
          },
          "checked_at_utc": "2024-01-15T22:30:05Z"
        }
      },
      "PassSummary": {
        "type": "object",
        "required": ["month", "total_passes", "used_passes", "remaining_passes", "next_refresh_utc"],
        "properties": {
          "month": {
            "type": "string",
            "description": "The month these statistics apply to in YYYY-MM format.",
            "example": "2024-01"
          },
          "total_passes": {
            "type": "integer",
            "format": "int32",
            "description": "Total number of passes allocated for this month. This is configured in settings but changes only take effect next month.",
            "minimum": 0,
            "maximum": 31,
            "example": 3
          },
          "used_passes": {
            "type": "integer",
            "format": "int32",
            "description": "Number of passes already used this month.",
            "minimum": 0,
            "example": 1
          },
          "remaining_passes": {
            "type": "integer",
            "format": "int32",
            "description": "Number of passes still available this month. When this reaches 0, no more passes can be used until next month.",
            "minimum": 0,
            "example": 2
          },
          "next_refresh_utc": {
            "type": "string",
            "description": "ISO 8601 timestamp (UTC) of when passes will refresh. This is always midnight UTC on the first day of the next month.",
            "example": "2024-02-01T00:00:00Z"
          }
        },
        "example": {
          "month": "2024-01",
          "total_passes": 3,
          "used_passes": 1,
          "remaining_passes": 2,
          "next_refresh_utc": "2024-02-01T00:00:00Z"
        }
      },
      "UsePassRequest": {
        "type": "object",
        "required": ["reason"],
        "properties": {
          "reason": {
            "type": "string",
            "description": "A brief explanation of why you need your phone nearby tonight. This helps you reflect on whether it's truly necessary. Must be between 1 and 500 characters.",
            "minLength": 1,
            "maxLength": 500,
            "example": "Family emergency - need to be reachable overnight"
          }
        },
        "example": {
          "reason": "Family emergency - need to be reachable overnight"
        }
      },
      "ApiError": {
        "type": "object",
        "required": ["error", "message"],
        "properties": {
          "error": {
            "type": "string",
            "description": "Machine-readable error code. Possible values: \"no_passes_remaining\", \"device_not_found\", \"invalid_request\", \"internal_error\"",
            "example": "no_passes_remaining"
          },
          "message": {
            "type": "string",
            "description": "Human-readable error message explaining what went wrong.",
            "example": "You have no emergency passes remaining this month."
          },
          "details": {
            "description": "Additional context-specific details about the error. The structure varies depending on the error type.",
            "nullable": true
          }
        },
        "example": {
          "error": "no_passes_remaining",
          "message": "You have no emergency passes remaining this month. Passes refresh on 2024-02-01.",
          "details": {
            "remaining_passes": 0,
            "next_refresh_utc": "2024-02-01T00:00:00Z"
          }
        }
      }
    }
  },
  "tags": [
    {
      "name": "Proximity",
      "description": "Core functionality - check if your phone is near the Raspberry Pi. This is what tether is all about: ensuring your phone is in its designated spot at night."
    },
    {
      "name": "Passes",
      "description": "Emergency pass management. Passes allow you to keep your phone nearby for legitimate reasons without it counting against you. You get a limited number per month that refresh automatically."
    },
    {
      "name": "Configuration",
      "description": "Manage tether settings including: which Bluetooth device to track, signal strength thresholds, Wi-Fi networks, timezone, and passes per month. Some settings have delayed effects."
    },
    {
      "name": "System",
      "description": "System-level operations including restart and remote access ticket management."
    },
    {
      "name": "Documentation",
      "description": "API documentation and specification endpoints."
    }
  ]
}
```

---

## 5. MCP Server Filtering

When using `rmcp-openapi` to generate MCP tools, you should filter to only expose these endpoints as specified in the requirements:

```rust
// In MCP server setup
use rmcp_openapi::Server;

let mut server = Server::builder()
    .openapi_spec(openapi_json)
    .base_url(base_url)
    .default_headers(headers)
    // Filter to only expose these operation IDs
    .tag_filter(Some(vec!["Proximity".to_string(), "Passes".to_string()]))
    .build();
```

The operation IDs that should be exposed via MCP are:
- `check_proximity` (tag: Proximity)
- `get_passes_remaining` (tag: Passes)
- `get_pass_history` (tag: Passes)
- `use_pass` (tag: Passes)

All other endpoints (Configuration, System, Documentation) should NOT be exposed as MCP tools.

---

## 6. Web UI TypeScript Client Generation

In the web UI project, configure `@hey-api/openapi-ts`:

**File: `web-ui/openapi-ts.config.ts`**

```typescript
import { defineConfig } from '@hey-api/openapi-ts';

export default defineConfig({
  input: './openapi.json',
  output: {
    path: './src/api',
    format: 'prettier',
  },
  plugins: [
    '@hey-api/typescript',
    {
      name: '@hey-api/sdk',
      // Use fetch by default
    },
  ],
});
```

Run generation:
```bash
cd web-ui && bunx @hey-api/openapi-ts
```

---

## Key Design Decisions Summary

1. **AI-Friendly Descriptions**: Every endpoint and schema has detailed descriptions explaining what it does, when to use it, and what the response means. This enables AI agents via MCP to understand the API without seeing the source code.

2. **Lazy Evaluation**: The proximity check is lazy (only checks when called) to save resources. This is documented in the descriptions.

3. **Intentional Friction**: The `use_pass` endpoint requires a reason, and this is explained in the description to help AI agents understand why.

4. **Delayed Effects**: Changes to `passes_per_month` only take effect next month. This is documented to prevent confusion.

5. **Operation IDs**: Each endpoint has an explicit `operation_id` which becomes the function/tool name in generated clients.

6. **Tags for Filtering**: Endpoints are grouped by tags (Proximity, Passes, Configuration, System, Documentation) to enable filtering for MCP tool generation.

7. **Examples Everywhere**: Every schema has realistic examples to help both humans and AI understand the expected data format.

---

### Critical Files for Implementation

- `/Users/jeffrey/code/tether/src/routes/openapi.rs` - Core OpenAPI module with all schemas, handlers, and ApiDoc struct (copy-paste ready code provided above)
- `/Users/jeffrey/code/tether/src/bin/gen_openapi.rs` - Binary for generating OpenAPI JSON to file at build time
- `/Users/jeffrey/code/tether/Cargo.toml` - Add utoipa, utoipa-axum dependencies and gen-openapi binary target
- `/Users/jeffrey/code/tether/justfile` - Build orchestration including API generation step
- `/Users/jeffrey/code/tether/web-ui/openapi-ts.config.ts` - Configuration for TypeScript client generation

---

**Sources:**
- [utoipa GitHub Repository](https://github.com/juhaku/utoipa)
- [utoipa Documentation](https://docs.rs/utoipa/latest/utoipa/)
- [utoipa path attribute reference](https://docs.rs/utoipa/latest/utoipa/attr.path.html)
- [utoipa OpenApi derive macro](https://docs.rs/utoipa/latest/utoipa/derive.OpenApi.html)
- [utoipa ToSchema derive macro](https://docs.rs/utoipa/latest/utoipa/derive.ToSchema.html)
- [utoipa IntoParams derive macro](https://docs.rs/utoipa/latest/utoipa/derive.IntoParams.html)
- [utoipa-axum crate](https://crates.io/crates/utoipa-axum)
- [utoipa-axum documentation](https://docs.rs/utoipa-axum/latest/utoipa_axum/)
- [utoipa todo-axum example](https://github.com/juhaku/utoipa/blob/master/examples/todo-axum/src/main.rs)
- [rmcp-openapi crate](https://crates.io/crates/rmcp-openapi)
- [@hey-api/openapi-ts](https://github.com/hey-api/openapi-ts)
- [Hey API Documentation](https://heyapi.dev/)
