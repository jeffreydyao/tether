Now I have enough context. Let me create a comprehensive implementation plan for all the route handlers.

---

# Excruciating Implementation Details for HTTP Route Handlers

## Project Context

This document provides complete implementation specifications for all HTTP route handlers in `tether-server/src/routes/`. Each handler uses Axum with utoipa OpenAPI annotations. The handlers interact with shared application state containing Bluetooth, WiFi, configuration, and pass management services.

---

## File: `/Users/jeffrey/code/tether/tether-server/src/routes/mod.rs`

This is the module that wires all route files together and exposes the combined router.

```rust
//! Route handlers for the Tether HTTP API.
//!
//! This module contains all HTTP endpoint implementations organized by domain:
//! - `proximity` - Bluetooth proximity detection
//! - `passes` - Monthly pass management
//! - `config` - System configuration
//! - `system` - System status and control
//! - `devices` - Bluetooth device scanning and RSSI

pub mod config;
pub mod devices;
pub mod passes;
pub mod proximity;
pub mod system;

use axum::Router;
use utoipa::OpenApi;
use utoipa_axum::router::OpenApiRouter;

use crate::state::AppState;

/// Combines all route modules into a single OpenApiRouter.
///
/// Returns a tuple of (Router, OpenApi) where Router is the axum router
/// and OpenApi is the generated OpenAPI specification.
pub fn create_router(state: AppState) -> (Router, utoipa::openapi::OpenApi) {
    let (router, api) = OpenApiRouter::with_openapi(ApiDoc::openapi())
        .nest("/api/proximity", proximity::router())
        .nest("/api/passes", passes::router())
        .nest("/api/config", config::router())
        .nest("/api/system", system::router())
        .nest("/api/devices", devices::router())
        .with_state(state)
        .split_for_parts();

    (router, api)
}

/// OpenAPI documentation structure.
#[derive(OpenApi)]
#[openapi(
    info(
        title = "Tether API",
        version = "1.0.0",
        description = "API for the Tether phone proximity tracking system. \
            Tether helps users hold themselves accountable by tracking whether \
            their phone is placed away from their bedroom at night. This API \
            provides endpoints for proximity detection, pass management, \
            system configuration, and device scanning.",
        license(name = "MIT"),
        contact(name = "Tether Support")
    ),
    tags(
        (name = "proximity", description = "Bluetooth proximity detection endpoints"),
        (name = "passes", description = "Monthly pass management - emergency passes for keeping phone nearby"),
        (name = "config", description = "System configuration - Bluetooth, WiFi, timezone, passes"),
        (name = "system", description = "System status, dumbpipe ticket, and restart control"),
        (name = "devices", description = "Bluetooth device scanning for onboarding")
    ),
    servers(
        (url = "http://localhost:3000", description = "Local development server"),
        (url = "http://tether.local", description = "Raspberry Pi local network")
    )
)]
pub struct ApiDoc;
```

---

## File: `/Users/jeffrey/code/tether/tether-server/src/routes/proximity.rs`

### Route: `GET /api/proximity`

Checks if the configured Bluetooth device is currently nearby based on RSSI threshold.

```rust
//! Proximity detection endpoints.
//!
//! Provides lazy proximity checking for the configured Bluetooth device.
//! Proximity is determined by comparing the current RSSI signal strength
//! against the configured threshold.

use axum::{extract::State, Json};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;
use utoipa_axum::{router::OpenApiRouter, routes};

use crate::{
    error::{ApiError, ApiResult},
    services::bluetooth::BluetoothService,
    state::AppState,
};

/// Creates the proximity router with all endpoints.
pub fn router() -> OpenApiRouter<AppState> {
    OpenApiRouter::new().routes(routes!(check_proximity))
}

// ============================================================================
// Request/Response Types
// ============================================================================

/// Response for proximity check.
///
/// Contains the device name and whether it is currently detected as nearby.
/// Proximity is determined by comparing RSSI against the configured threshold.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(example = json!({
    "device_name": "iPhone 15 Pro",
    "device_address": "AA:BB:CC:DD:EE:FF",
    "is_nearby": true,
    "rssi_dbm": -45,
    "threshold_dbm": -70,
    "checked_at_utc": "2025-01-15T03:30:00Z"
}))]
pub struct ProximityResponse {
    /// The configured Bluetooth device name (if known).
    #[schema(example = "iPhone 15 Pro")]
    pub device_name: Option<String>,

    /// The Bluetooth MAC address of the tracked device.
    #[schema(example = "AA:BB:CC:DD:EE:FF")]
    pub device_address: String,

    /// Whether the device is considered nearby based on RSSI threshold.
    /// `true` means the phone is close to the Raspberry Pi.
    /// `false` means the phone is away (desired state at night).
    #[schema(example = true)]
    pub is_nearby: bool,

    /// The current RSSI signal strength in dBm.
    /// More negative values indicate weaker signal (device further away).
    /// `None` if the device was not detected.
    #[schema(example = -45)]
    pub rssi_dbm: Option<i16>,

    /// The configured RSSI threshold in dBm.
    /// Device is considered "nearby" if rssi_dbm >= threshold_dbm.
    #[schema(example = -70)]
    pub threshold_dbm: i16,

    /// UTC timestamp of when this check was performed.
    #[schema(example = "2025-01-15T03:30:00Z")]
    pub checked_at_utc: String,
}

/// Error response when proximity check fails.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(example = json!({
    "error": "bluetooth_unavailable",
    "message": "Bluetooth adapter is not available or powered off",
    "details": null
}))]
pub struct ProximityErrorResponse {
    /// Machine-readable error code.
    #[schema(example = "bluetooth_unavailable")]
    pub error: String,

    /// Human-readable error message.
    #[schema(example = "Bluetooth adapter is not available or powered off")]
    pub message: String,

    /// Optional additional details.
    #[schema(nullable)]
    pub details: Option<String>,
}

// ============================================================================
// Handler
// ============================================================================

/// Check if the configured Bluetooth device is nearby.
///
/// Performs a lazy proximity check by scanning for the configured Bluetooth
/// device and comparing its RSSI signal strength against the threshold.
///
/// **How it works:**
/// 1. Retrieves the configured Bluetooth device address from config
/// 2. Scans for the device (brief scan, typically 1-3 seconds)
/// 3. If found, compares RSSI against configured threshold
/// 4. Returns proximity status with signal details
///
/// **Proximity Logic:**
/// - Device is "nearby" if `rssi_dbm >= threshold_dbm`
/// - RSSI values: 0 dBm (strongest) to -100 dBm (weakest)
/// - Typical thresholds: -50 (very close) to -80 (same room)
///
/// **Use Cases:**
/// - Called by MCP server to check if phone is in bedroom
/// - Used by external automations for accountability checks
#[utoipa::path(
    get,
    path = "",
    tag = "proximity",
    operation_id = "checkProximity",
    summary = "Check if configured Bluetooth device is nearby",
    description = "Performs a lazy Bluetooth scan to determine if the configured \
        device (typically a phone) is within the proximity threshold. This is the \
        primary endpoint for checking accountability - if the device is NOT nearby, \
        the user is successfully keeping their phone away.",
    responses(
        (status = 200, description = "Proximity check completed successfully", body = ProximityResponse,
            example = json!({
                "device_name": "iPhone 15 Pro",
                "device_address": "AA:BB:CC:DD:EE:FF",
                "is_nearby": false,
                "rssi_dbm": -82,
                "threshold_dbm": -70,
                "checked_at_utc": "2025-01-15T03:30:00Z"
            })
        ),
        (status = 424, description = "Bluetooth device not configured - complete onboarding first",
            body = ProximityErrorResponse,
            example = json!({
                "error": "device_not_configured",
                "message": "No Bluetooth device has been configured. Complete onboarding first.",
                "details": null
            })
        ),
        (status = 503, description = "Bluetooth service unavailable",
            body = ProximityErrorResponse,
            example = json!({
                "error": "bluetooth_unavailable",
                "message": "Bluetooth adapter is not available or powered off",
                "details": "hci0: Device not found"
            })
        )
    )
)]
pub async fn check_proximity(
    State(state): State<AppState>,
) -> ApiResult<Json<ProximityResponse>> {
    // 1. Get the configured Bluetooth target from config
    let config = state.config_service.get_config().await?;
    
    let bluetooth_config = config.bluetooth.as_ref().ok_or_else(|| {
        ApiError::FailedDependency {
            error_code: "device_not_configured".to_string(),
            message: "No Bluetooth device has been configured. Complete onboarding first.".to_string(),
            details: None,
        }
    })?;

    // 2. Perform Bluetooth scan for the target device
    let scan_result = state
        .bluetooth_service
        .get_device_rssi(&bluetooth_config.address)
        .await
        .map_err(|e| ApiError::ServiceUnavailable {
            error_code: "bluetooth_unavailable".to_string(),
            message: "Bluetooth adapter is not available or powered off".to_string(),
            details: Some(e.to_string()),
        })?;

    // 3. Determine proximity based on RSSI threshold
    let is_nearby = scan_result
        .rssi_dbm
        .map(|rssi| rssi >= bluetooth_config.threshold_dbm)
        .unwrap_or(false); // Device not found = not nearby

    // 4. Build response with current UTC timestamp
    let checked_at_utc = chrono::Utc::now().to_rfc3339();

    Ok(Json(ProximityResponse {
        device_name: bluetooth_config.name.clone(),
        device_address: bluetooth_config.address.clone(),
        is_nearby,
        rssi_dbm: scan_result.rssi_dbm,
        threshold_dbm: bluetooth_config.threshold_dbm,
        checked_at_utc,
    }))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_proximity_response_serialization() {
        let response = ProximityResponse {
            device_name: Some("Test Phone".to_string()),
            device_address: "AA:BB:CC:DD:EE:FF".to_string(),
            is_nearby: true,
            rssi_dbm: Some(-45),
            threshold_dbm: -70,
            checked_at_utc: "2025-01-15T03:30:00Z".to_string(),
        };
        
        let json = serde_json::to_string(&response).unwrap();
        assert!(json.contains("is_nearby"));
        assert!(json.contains("true"));
    }
}
```

---

## File: `/Users/jeffrey/code/tether/tether-server/src/routes/passes.rs`

### Routes:
- `GET /api/passes` - Get remaining passes this month
- `GET /api/passes/history` - Get pass usage history
- `POST /api/passes/use` - Use a pass

```rust
//! Pass management endpoints.
//!
//! Tether provides a configurable number of emergency passes per month.
//! When users need to keep their phone nearby (e.g., on-call, sick child),
//! they can use a pass with a reason. Passes refresh automatically on the
//! first day of each month at midnight (local timezone).

use axum::{
    extract::{Query, State},
    Json,
};
use serde::{Deserialize, Serialize};
use utoipa::{IntoParams, ToSchema};
use utoipa_axum::{router::OpenApiRouter, routes};

use crate::{
    error::{ApiError, ApiResult},
    state::AppState,
};

/// Creates the passes router with all endpoints.
pub fn router() -> OpenApiRouter<AppState> {
    OpenApiRouter::new()
        .routes(routes!(get_passes))
        .routes(routes!(get_pass_history))
        .routes(routes!(use_pass))
}

// ============================================================================
// Request/Response Types
// ============================================================================

/// Current pass status for the month.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(example = json!({
    "remaining": 2,
    "total_per_month": 3,
    "used_this_month": 1,
    "month": "2025-01",
    "resets_at_utc": "2025-02-01T00:00:00Z",
    "timezone": "America/Los_Angeles"
}))]
pub struct PassesResponse {
    /// Number of passes remaining this month.
    #[schema(example = 2, minimum = 0)]
    pub remaining: u32,

    /// Total passes allocated per month (from config).
    #[schema(example = 3, minimum = 0)]
    pub total_per_month: u32,

    /// Number of passes used this month.
    #[schema(example = 1, minimum = 0)]
    pub used_this_month: u32,

    /// Current month in YYYY-MM format.
    #[schema(example = "2025-01")]
    pub month: String,

    /// UTC timestamp when passes will reset (first of next month, midnight local time).
    #[schema(example = "2025-02-01T08:00:00Z")]
    pub resets_at_utc: String,

    /// Configured timezone for reset calculation.
    #[schema(example = "America/Los_Angeles")]
    pub timezone: String,
}

/// Query parameters for pass history endpoint.
#[derive(Debug, Clone, Deserialize, IntoParams)]
#[into_params(style = Form, parameter_in = Query)]
pub struct PassHistoryQuery {
    /// Month to retrieve history for in YYYY-MM format.
    /// Defaults to current month if not specified.
    #[param(
        style = Form,
        example = "2025-01",
        pattern = r"^\d{4}-(0[1-9]|1[0-2])$"
    )]
    pub month: Option<String>,
}

/// A single pass usage record.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(example = json!({
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "used_at_utc": "2025-01-10T02:30:00Z",
    "reason": "On-call for work emergency"
}))]
pub struct PassUsageRecord {
    /// Unique identifier for this pass usage.
    #[schema(example = "550e8400-e29b-41d4-a716-446655440000")]
    pub id: String,

    /// UTC timestamp when the pass was used.
    /// Stored in UTC for consistency; clients can convert to local time.
    #[schema(example = "2025-01-10T02:30:00Z")]
    pub used_at_utc: String,

    /// User-provided reason for using the pass.
    /// Required to encourage mindful usage.
    #[schema(example = "On-call for work emergency")]
    pub reason: String,
}

/// Pass history response for a specific month.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(example = json!({
    "month": "2025-01",
    "total_per_month": 3,
    "passes_used": 1,
    "passes_remaining": 2,
    "history": [
        {
            "id": "550e8400-e29b-41d4-a716-446655440000",
            "used_at_utc": "2025-01-10T02:30:00Z",
            "reason": "On-call for work emergency"
        }
    ]
}))]
pub struct PassHistoryResponse {
    /// Month this history is for in YYYY-MM format.
    #[schema(example = "2025-01")]
    pub month: String,

    /// Total passes allocated for this month.
    /// Note: For historical months, this reflects the config at that time.
    #[schema(example = 3)]
    pub total_per_month: u32,

    /// Number of passes used in this month.
    #[schema(example = 1)]
    pub passes_used: u32,

    /// Passes remaining (for current month) or unused (for past months).
    #[schema(example = 2)]
    pub passes_remaining: u32,

    /// List of pass usage records, ordered by used_at_utc ascending.
    pub history: Vec<PassUsageRecord>,
}

/// Request body for using a pass.
#[derive(Debug, Clone, Deserialize, ToSchema)]
#[schema(example = json!({
    "reason": "Child is sick and might need to call doctor"
}))]
pub struct UsePassRequest {
    /// Reason for using the pass. Required to encourage mindful usage.
    /// Should be descriptive enough to remind the user why they needed
    /// the exception when reviewing history.
    #[schema(
        example = "Child is sick and might need to call doctor",
        min_length = 1,
        max_length = 500
    )]
    pub reason: String,
}

/// Response after successfully using a pass.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(example = json!({
    "success": true,
    "pass_id": "550e8400-e29b-41d4-a716-446655440001",
    "remaining": 1,
    "used_at_utc": "2025-01-15T03:45:00Z",
    "message": "Pass used successfully. You have 1 pass remaining this month."
}))]
pub struct UsePassResponse {
    /// Whether the pass was used successfully.
    #[schema(example = true)]
    pub success: bool,

    /// Unique identifier for this pass usage.
    #[schema(example = "550e8400-e29b-41d4-a716-446655440001")]
    pub pass_id: String,

    /// Number of passes remaining after this usage.
    #[schema(example = 1)]
    pub remaining: u32,

    /// UTC timestamp when the pass was used.
    #[schema(example = "2025-01-15T03:45:00Z")]
    pub used_at_utc: String,

    /// Human-readable confirmation message.
    #[schema(example = "Pass used successfully. You have 1 pass remaining this month.")]
    pub message: String,
}

/// Error response for pass-related errors.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(example = json!({
    "error": "no_passes_remaining",
    "message": "No passes remaining for January 2025. Passes reset on February 1st.",
    "remaining": 0,
    "resets_at_utc": "2025-02-01T08:00:00Z"
}))]
pub struct PassErrorResponse {
    /// Machine-readable error code.
    #[schema(example = "no_passes_remaining")]
    pub error: String,

    /// Human-readable error message.
    #[schema(example = "No passes remaining for January 2025. Passes reset on February 1st.")]
    pub message: String,

    /// Current remaining passes (always 0 for this error).
    #[schema(example = 0)]
    pub remaining: u32,

    /// When passes will reset.
    #[schema(example = "2025-02-01T08:00:00Z")]
    pub resets_at_utc: String,
}

// ============================================================================
// Handlers
// ============================================================================

/// Get remaining passes for the current month.
///
/// Returns the current pass status including how many passes are remaining,
/// how many have been used, and when they will reset.
///
/// **Pass Reset Logic:**
/// - Passes reset at midnight on the 1st of each month in the configured timezone
/// - The `resets_at_utc` field shows this time converted to UTC
/// - Changes to `passes_per_month` config only take effect the following month
#[utoipa::path(
    get,
    path = "",
    tag = "passes",
    operation_id = "getRemainingPasses",
    summary = "Get remaining passes for current month",
    description = "Returns the current month's pass allocation status. Passes are \
        emergency exceptions that allow keeping the phone nearby. Use these sparingly - \
        the accountability system works best when passes are rarely needed.",
    responses(
        (status = 200, description = "Pass status retrieved successfully", body = PassesResponse,
            example = json!({
                "remaining": 2,
                "total_per_month": 3,
                "used_this_month": 1,
                "month": "2025-01",
                "resets_at_utc": "2025-02-01T08:00:00Z",
                "timezone": "America/Los_Angeles"
            })
        ),
        (status = 500, description = "Internal server error", body = PassErrorResponse)
    )
)]
pub async fn get_passes(State(state): State<AppState>) -> ApiResult<Json<PassesResponse>> {
    // Get config for timezone and passes_per_month
    let config = state.config_service.get_config().await?;
    let timezone = config.timezone.clone();
    let total_per_month = config.passes_per_month;

    // Get current pass status from pass service
    let pass_status = state.pass_service.get_current_status(&timezone).await?;

    // Calculate reset time (first of next month, midnight local, converted to UTC)
    let resets_at_utc = state
        .pass_service
        .calculate_next_reset_utc(&timezone)
        .await?;

    Ok(Json(PassesResponse {
        remaining: pass_status.remaining,
        total_per_month,
        used_this_month: pass_status.used,
        month: pass_status.month,
        resets_at_utc,
        timezone,
    }))
}

/// Get pass usage history for a specific month.
///
/// Retrieves the detailed history of pass usage for the specified month,
/// including the reason provided for each pass used.
///
/// **Query Parameters:**
/// - `month` (optional): Month in YYYY-MM format. Defaults to current month.
///
/// **Historical Data:**
/// - Historical months show the `total_per_month` that was configured at that time
/// - Records are ordered by `used_at_utc` ascending (oldest first)
#[utoipa::path(
    get,
    path = "/history",
    tag = "passes",
    operation_id = "getPassHistory",
    summary = "Get pass usage history for a month",
    description = "Retrieves detailed pass usage history for the specified month. \
        Each record includes the timestamp and reason provided when the pass was used. \
        Useful for reviewing patterns and ensuring passes are used appropriately.",
    params(PassHistoryQuery),
    responses(
        (status = 200, description = "Pass history retrieved successfully", body = PassHistoryResponse,
            example = json!({
                "month": "2025-01",
                "total_per_month": 3,
                "passes_used": 1,
                "passes_remaining": 2,
                "history": [
                    {
                        "id": "550e8400-e29b-41d4-a716-446655440000",
                        "used_at_utc": "2025-01-10T02:30:00Z",
                        "reason": "On-call for work emergency"
                    }
                ]
            })
        ),
        (status = 400, description = "Invalid month format",
            body = PassErrorResponse,
            example = json!({
                "error": "invalid_month_format",
                "message": "Month must be in YYYY-MM format (e.g., 2025-01)",
                "remaining": 0,
                "resets_at_utc": null
            })
        ),
        (status = 404, description = "No history found for specified month",
            body = PassHistoryResponse,
            example = json!({
                "month": "2024-06",
                "total_per_month": 3,
                "passes_used": 0,
                "passes_remaining": 3,
                "history": []
            })
        )
    )
)]
pub async fn get_pass_history(
    State(state): State<AppState>,
    Query(query): Query<PassHistoryQuery>,
) -> ApiResult<Json<PassHistoryResponse>> {
    // Get config for default timezone
    let config = state.config_service.get_config().await?;
    
    // Determine which month to query
    let month = match query.month {
        Some(m) => {
            // Validate month format: YYYY-MM
            if !is_valid_month_format(&m) {
                return Err(ApiError::BadRequest {
                    error_code: "invalid_month_format".to_string(),
                    message: "Month must be in YYYY-MM format (e.g., 2025-01)".to_string(),
                });
            }
            m
        }
        None => {
            // Default to current month in configured timezone
            state.pass_service.get_current_month(&config.timezone).await?
        }
    };

    // Retrieve history from pass service
    let history_data = state.pass_service.get_history(&month).await?;

    // Convert internal records to API response format
    let history: Vec<PassUsageRecord> = history_data
        .records
        .into_iter()
        .map(|r| PassUsageRecord {
            id: r.id,
            used_at_utc: r.used_at_utc,
            reason: r.reason,
        })
        .collect();

    Ok(Json(PassHistoryResponse {
        month,
        total_per_month: history_data.total_per_month,
        passes_used: history.len() as u32,
        passes_remaining: history_data.total_per_month.saturating_sub(history.len() as u32),
        history,
    }))
}

/// Use a pass with a reason.
///
/// Consumes one pass from the monthly allocation. Requires a reason to
/// encourage mindful usage and create an audit trail.
///
/// **Important Notes:**
/// - Passes cannot be "un-used" once consumed
/// - A pass is required when keeping your phone nearby during sleep hours
/// - The reason is stored permanently for accountability review
/// - Returns error if no passes remain this month
#[utoipa::path(
    post,
    path = "/use",
    tag = "passes",
    operation_id = "usePass",
    summary = "Use a pass with a reason",
    description = "Consumes one pass from this month's allocation. The pass system \
        provides emergency exceptions for legitimate needs (on-call, sick family member, etc). \
        A reason is required to maintain accountability. Passes cannot be refunded once used.",
    request_body(
        content = UsePassRequest,
        description = "Reason for using the pass",
        content_type = "application/json",
        example = json!({
            "reason": "Child is sick and might need to call doctor"
        })
    ),
    responses(
        (status = 200, description = "Pass used successfully", body = UsePassResponse,
            example = json!({
                "success": true,
                "pass_id": "550e8400-e29b-41d4-a716-446655440001",
                "remaining": 1,
                "used_at_utc": "2025-01-15T03:45:00Z",
                "message": "Pass used successfully. You have 1 pass remaining this month."
            })
        ),
        (status = 400, description = "Invalid request - reason is required",
            body = PassErrorResponse,
            example = json!({
                "error": "reason_required",
                "message": "A reason is required when using a pass",
                "remaining": 2,
                "resets_at_utc": "2025-02-01T08:00:00Z"
            })
        ),
        (status = 409, description = "No passes remaining this month",
            body = PassErrorResponse,
            example = json!({
                "error": "no_passes_remaining",
                "message": "No passes remaining for January 2025. Passes reset on February 1st.",
                "remaining": 0,
                "resets_at_utc": "2025-02-01T08:00:00Z"
            })
        )
    )
)]
pub async fn use_pass(
    State(state): State<AppState>,
    Json(request): Json<UsePassRequest>,
) -> ApiResult<Json<UsePassResponse>> {
    // Validate reason is not empty or whitespace-only
    let reason = request.reason.trim();
    if reason.is_empty() {
        return Err(ApiError::BadRequest {
            error_code: "reason_required".to_string(),
            message: "A reason is required when using a pass".to_string(),
        });
    }

    // Validate reason length
    if reason.len() > 500 {
        return Err(ApiError::BadRequest {
            error_code: "reason_too_long".to_string(),
            message: "Reason must be 500 characters or less".to_string(),
        });
    }

    // Get config for timezone
    let config = state.config_service.get_config().await?;

    // Attempt to use a pass
    let result = state
        .pass_service
        .use_pass(reason.to_string(), &config.timezone)
        .await;

    match result {
        Ok(pass_result) => {
            let message = format!(
                "Pass used successfully. You have {} pass{} remaining this month.",
                pass_result.remaining,
                if pass_result.remaining == 1 { "" } else { "es" }
            );

            Ok(Json(UsePassResponse {
                success: true,
                pass_id: pass_result.pass_id,
                remaining: pass_result.remaining,
                used_at_utc: pass_result.used_at_utc,
                message,
            }))
        }
        Err(e) if e.is_no_passes_remaining() => {
            let resets_at_utc = state
                .pass_service
                .calculate_next_reset_utc(&config.timezone)
                .await?;
            let current_month = state.pass_service.get_current_month(&config.timezone).await?;
            
            Err(ApiError::Conflict {
                error_code: "no_passes_remaining".to_string(),
                message: format!(
                    "No passes remaining for {}. Passes reset at {}.",
                    format_month_display(&current_month),
                    resets_at_utc
                ),
                remaining: 0,
                resets_at_utc: Some(resets_at_utc),
            })
        }
        Err(e) => Err(e.into()),
    }
}

// ============================================================================
// Helper Functions
// ============================================================================

/// Validates that a string is in YYYY-MM format.
fn is_valid_month_format(s: &str) -> bool {
    if s.len() != 7 {
        return false;
    }
    
    let parts: Vec<&str> = s.split('-').collect();
    if parts.len() != 2 {
        return false;
    }

    // Validate year (4 digits)
    if parts[0].len() != 4 || !parts[0].chars().all(|c| c.is_ascii_digit()) {
        return false;
    }

    // Validate month (01-12)
    match parts[1].parse::<u32>() {
        Ok(m) => (1..=12).contains(&m),
        Err(_) => false,
    }
}

/// Formats a YYYY-MM month string for display (e.g., "January 2025").
fn format_month_display(month: &str) -> String {
    let parts: Vec<&str> = month.split('-').collect();
    if parts.len() != 2 {
        return month.to_string();
    }
    
    let month_name = match parts[1] {
        "01" => "January",
        "02" => "February",
        "03" => "March",
        "04" => "April",
        "05" => "May",
        "06" => "June",
        "07" => "July",
        "08" => "August",
        "09" => "September",
        "10" => "October",
        "11" => "November",
        "12" => "December",
        _ => return month.to_string(),
    };

    format!("{} {}", month_name, parts[0])
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_valid_month_format() {
        assert!(is_valid_month_format("2025-01"));
        assert!(is_valid_month_format("2024-12"));
        assert!(!is_valid_month_format("2025-13"));
        assert!(!is_valid_month_format("2025-1"));
        assert!(!is_valid_month_format("25-01"));
        assert!(!is_valid_month_format("2025/01"));
    }

    #[test]
    fn test_format_month_display() {
        assert_eq!(format_month_display("2025-01"), "January 2025");
        assert_eq!(format_month_display("2024-12"), "December 2024");
    }
}
```

---

## File: `/Users/jeffrey/code/tether/tether-server/src/routes/config.rs`

### Routes:
- `GET /api/config` - Get full configuration
- `PUT /api/config/bluetooth` - Update Bluetooth target
- `PUT /api/config/wifi` - Update WiFi networks
- `PUT /api/config/timezone` - Update timezone
- `PUT /api/config/passes` - Update passes per month
- `POST /api/config/complete-onboarding` - Mark onboarding complete

```rust
//! Configuration management endpoints.
//!
//! Provides endpoints for viewing and updating system configuration including:
//! - Bluetooth device to track
//! - WiFi networks
//! - Timezone settings
//! - Passes per month allocation
//!
//! Configuration changes take effect immediately except for passes_per_month,
//! which only takes effect at the start of the next month.

use axum::{extract::State, Json};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;
use utoipa_axum::{router::OpenApiRouter, routes};

use crate::{
    error::{ApiError, ApiResult},
    state::AppState,
};

/// Creates the config router with all endpoints.
pub fn router() -> OpenApiRouter<AppState> {
    OpenApiRouter::new()
        .routes(routes!(get_config))
        .routes(routes!(update_bluetooth))
        .routes(routes!(update_wifi))
        .routes(routes!(update_timezone))
        .routes(routes!(update_passes))
        .routes(routes!(complete_onboarding))
}

// ============================================================================
// Shared Types
// ============================================================================

/// Bluetooth device configuration.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(example = json!({
    "address": "AA:BB:CC:DD:EE:FF",
    "name": "iPhone 15 Pro",
    "threshold_dbm": -70
}))]
pub struct BluetoothConfig {
    /// Bluetooth MAC address of the device to track.
    /// Format: XX:XX:XX:XX:XX:XX (uppercase hex with colons).
    #[schema(example = "AA:BB:CC:DD:EE:FF", pattern = r"^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$")]
    pub address: String,

    /// Optional friendly name for the device.
    /// Helpful for identifying the device in the UI.
    #[schema(example = "iPhone 15 Pro", nullable)]
    pub name: Option<String>,

    /// RSSI threshold in dBm for considering the device "nearby".
    /// - More negative = weaker signal (farther away)
    /// - Range: -100 (very far) to 0 (touching)
    /// - Typical values: -50 (very close) to -80 (same room)
    /// Device is "nearby" when RSSI >= threshold.
    #[schema(example = -70, minimum = -100, maximum = 0)]
    pub threshold_dbm: i16,
}

/// WiFi network configuration.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(example = json!({
    "ssid": "HomeNetwork",
    "password": "supersecret123",
    "priority": 1,
    "is_primary": true
}))]
pub struct WifiNetwork {
    /// Network SSID (name).
    #[schema(example = "HomeNetwork")]
    pub ssid: String,

    /// Network password (WPA/WPA2).
    /// Empty string for open networks.
    #[schema(example = "supersecret123")]
    pub password: String,

    /// Connection priority (lower = higher priority).
    /// Used when multiple known networks are available.
    #[schema(example = 1, minimum = 0)]
    pub priority: u32,

    /// Whether this is the primary network.
    /// Only one network can be primary. The primary network
    /// is connected to after onboarding completes.
    #[schema(example = true)]
    pub is_primary: bool,
}

// ============================================================================
// GET /api/config - Full Configuration
// ============================================================================

/// Complete system configuration response.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(example = json!({
    "bluetooth": {
        "address": "AA:BB:CC:DD:EE:FF",
        "name": "iPhone 15 Pro",
        "threshold_dbm": -70
    },
    "wifi_networks": [
        {
            "ssid": "HomeNetwork",
            "password": "***REDACTED***",
            "priority": 1,
            "is_primary": true
        }
    ],
    "timezone": "America/Los_Angeles",
    "passes_per_month": 3,
    "passes_per_month_effective": 3,
    "onboarding_complete": true
}))]
pub struct ConfigResponse {
    /// Bluetooth device configuration. Null if not configured yet.
    #[schema(nullable)]
    pub bluetooth: Option<BluetoothConfig>,

    /// List of configured WiFi networks.
    /// Passwords are redacted in responses (shown as "***REDACTED***").
    pub wifi_networks: Vec<WifiNetworkRedacted>,

    /// System timezone (IANA timezone name).
    /// Used for pass reset calculations and local time display.
    #[schema(example = "America/Los_Angeles")]
    pub timezone: String,

    /// Configured passes per month.
    /// Note: Changes only take effect next month.
    #[schema(example = 3)]
    pub passes_per_month: u32,

    /// Currently effective passes per month.
    /// This is what's actually in use for the current month.
    #[schema(example = 3)]
    pub passes_per_month_effective: u32,

    /// Whether onboarding has been completed.
    #[schema(example = true)]
    pub onboarding_complete: bool,
}

/// WiFi network with password redacted for security.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
pub struct WifiNetworkRedacted {
    #[schema(example = "HomeNetwork")]
    pub ssid: String,

    /// Always "***REDACTED***" in responses.
    #[schema(example = "***REDACTED***")]
    pub password: String,

    #[schema(example = 1)]
    pub priority: u32,

    #[schema(example = true)]
    pub is_primary: bool,
}

/// Get the full system configuration.
///
/// Returns all configuration settings. WiFi passwords are redacted for security.
///
/// **Effective vs Configured Passes:**
/// - `passes_per_month`: What's configured (changes take effect next month)
/// - `passes_per_month_effective`: What's actually in use this month
#[utoipa::path(
    get,
    path = "",
    tag = "config",
    operation_id = "getConfig",
    summary = "Get full system configuration",
    description = "Retrieves all system configuration settings including Bluetooth target, \
        WiFi networks (passwords redacted), timezone, and pass allocation. Use this to \
        display current settings in the configuration UI.",
    responses(
        (status = 200, description = "Configuration retrieved successfully", body = ConfigResponse)
    )
)]
pub async fn get_config(State(state): State<AppState>) -> ApiResult<Json<ConfigResponse>> {
    let config = state.config_service.get_config().await?;

    // Redact WiFi passwords
    let wifi_networks: Vec<WifiNetworkRedacted> = config
        .wifi_networks
        .iter()
        .map(|n| WifiNetworkRedacted {
            ssid: n.ssid.clone(),
            password: "***REDACTED***".to_string(),
            priority: n.priority,
            is_primary: n.is_primary,
        })
        .collect();

    // Get effective passes per month (what's actually in use this month)
    let effective_passes = state
        .pass_service
        .get_effective_passes_per_month(&config.timezone)
        .await?;

    Ok(Json(ConfigResponse {
        bluetooth: config.bluetooth,
        wifi_networks,
        timezone: config.timezone,
        passes_per_month: config.passes_per_month,
        passes_per_month_effective: effective_passes,
        onboarding_complete: config.onboarding_complete,
    }))
}

// ============================================================================
// PUT /api/config/bluetooth - Update Bluetooth Target
// ============================================================================

/// Request to update Bluetooth device configuration.
#[derive(Debug, Clone, Deserialize, ToSchema)]
#[schema(example = json!({
    "address": "AA:BB:CC:DD:EE:FF",
    "name": "iPhone 15 Pro",
    "threshold_dbm": -70
}))]
pub struct UpdateBluetoothRequest {
    /// Bluetooth MAC address to track.
    #[schema(example = "AA:BB:CC:DD:EE:FF", pattern = r"^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$")]
    pub address: String,

    /// Optional friendly name for the device.
    #[schema(example = "iPhone 15 Pro", nullable)]
    pub name: Option<String>,

    /// RSSI threshold in dBm (-100 to 0).
    #[schema(example = -70, minimum = -100, maximum = 0)]
    pub threshold_dbm: i16,
}

/// Response after updating Bluetooth configuration.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(example = json!({
    "success": true,
    "message": "Bluetooth configuration updated successfully",
    "bluetooth": {
        "address": "AA:BB:CC:DD:EE:FF",
        "name": "iPhone 15 Pro",
        "threshold_dbm": -70
    }
}))]
pub struct UpdateBluetoothResponse {
    #[schema(example = true)]
    pub success: bool,

    #[schema(example = "Bluetooth configuration updated successfully")]
    pub message: String,

    /// The updated Bluetooth configuration.
    pub bluetooth: BluetoothConfig,
}

/// Update Bluetooth device configuration.
///
/// Sets which Bluetooth device to track for proximity detection and the
/// RSSI threshold for determining "nearby" status.
///
/// **Takes Effect:** Immediately. The next proximity check will use the new settings.
///
/// **Address Format:** Must be a valid Bluetooth MAC address (XX:XX:XX:XX:XX:XX).
/// Use the `/api/devices` endpoint to scan for available devices.
#[utoipa::path(
    put,
    path = "/bluetooth",
    tag = "config",
    operation_id = "updateBluetooth",
    summary = "Update Bluetooth device to track",
    description = "Configures which Bluetooth device to track for proximity detection. \
        The device is typically a smartphone. Use /api/devices to scan for available devices \
        and /api/devices/{address}/rssi to test signal strength before setting a threshold.",
    request_body(
        content = UpdateBluetoothRequest,
        description = "Bluetooth device configuration",
        content_type = "application/json"
    ),
    responses(
        (status = 200, description = "Bluetooth configuration updated", body = UpdateBluetoothResponse),
        (status = 400, description = "Invalid Bluetooth address format",
            example = json!({
                "error": "invalid_bluetooth_address",
                "message": "Bluetooth address must be in format XX:XX:XX:XX:XX:XX"
            })
        ),
        (status = 400, description = "Invalid RSSI threshold",
            example = json!({
                "error": "invalid_threshold",
                "message": "RSSI threshold must be between -100 and 0 dBm"
            })
        )
    )
)]
pub async fn update_bluetooth(
    State(state): State<AppState>,
    Json(request): Json<UpdateBluetoothRequest>,
) -> ApiResult<Json<UpdateBluetoothResponse>> {
    // Validate Bluetooth address format
    if !is_valid_bluetooth_address(&request.address) {
        return Err(ApiError::BadRequest {
            error_code: "invalid_bluetooth_address".to_string(),
            message: "Bluetooth address must be in format XX:XX:XX:XX:XX:XX".to_string(),
        });
    }

    // Validate RSSI threshold range
    if request.threshold_dbm < -100 || request.threshold_dbm > 0 {
        return Err(ApiError::BadRequest {
            error_code: "invalid_threshold".to_string(),
            message: "RSSI threshold must be between -100 and 0 dBm".to_string(),
        });
    }

    // Normalize address to uppercase
    let address = request.address.to_uppercase();

    let bluetooth_config = BluetoothConfig {
        address: address.clone(),
        name: request.name,
        threshold_dbm: request.threshold_dbm,
    };

    // Update configuration
    state
        .config_service
        .update_bluetooth(bluetooth_config.clone())
        .await?;

    Ok(Json(UpdateBluetoothResponse {
        success: true,
        message: "Bluetooth configuration updated successfully".to_string(),
        bluetooth: bluetooth_config,
    }))
}

// ============================================================================
// PUT /api/config/wifi - Update WiFi Networks
// ============================================================================

/// Request to update WiFi network configuration.
#[derive(Debug, Clone, Deserialize, ToSchema)]
#[schema(example = json!({
    "networks": [
        {
            "ssid": "HomeNetwork",
            "password": "supersecret123",
            "priority": 1,
            "is_primary": true
        },
        {
            "ssid": "WorkNetwork",
            "password": "workpass456",
            "priority": 2,
            "is_primary": false
        }
    ]
}))]
pub struct UpdateWifiRequest {
    /// List of WiFi networks to configure.
    /// This replaces the existing network list entirely.
    /// At least one network must be marked as primary.
    pub networks: Vec<WifiNetwork>,
}

/// Response after updating WiFi configuration.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(example = json!({
    "success": true,
    "message": "WiFi configuration updated. Connected to HomeNetwork.",
    "connected_ssid": "HomeNetwork",
    "networks_count": 2
}))]
pub struct UpdateWifiResponse {
    #[schema(example = true)]
    pub success: bool,

    #[schema(example = "WiFi configuration updated. Connected to HomeNetwork.")]
    pub message: String,

    /// SSID of the network now connected to (if any).
    #[schema(example = "HomeNetwork", nullable)]
    pub connected_ssid: Option<String>,

    /// Number of networks configured.
    #[schema(example = 2)]
    pub networks_count: usize,
}

/// Update WiFi network configuration.
///
/// Replaces the entire WiFi network list with the provided networks.
/// The system will attempt to connect to the primary network.
///
/// **Connection Behavior:**
/// - If a new primary network is set, the system connects to it immediately
/// - Adding non-primary networks doesn't trigger reconnection
/// - Internet availability is verified before confirming connection
///
/// **Important:** During onboarding, after configuring WiFi, the temporary
/// AP network will be turned off and users should reconnect on the primary network.
#[utoipa::path(
    put,
    path = "/wifi",
    tag = "config",
    operation_id = "updateWifi",
    summary = "Update WiFi network configuration",
    description = "Configures the list of WiFi networks. Exactly one network must be \
        marked as primary. After update, the system attempts to connect to the primary \
        network. During onboarding, the temporary AP is disabled after successful connection.",
    request_body(
        content = UpdateWifiRequest,
        description = "WiFi networks to configure",
        content_type = "application/json"
    ),
    responses(
        (status = 200, description = "WiFi configuration updated", body = UpdateWifiResponse),
        (status = 400, description = "Invalid WiFi configuration",
            example = json!({
                "error": "no_primary_network",
                "message": "Exactly one network must be marked as primary"
            })
        ),
        (status = 400, description = "Empty network list",
            example = json!({
                "error": "no_networks",
                "message": "At least one WiFi network must be configured"
            })
        ),
        (status = 503, description = "Failed to connect to primary network",
            example = json!({
                "error": "connection_failed",
                "message": "Failed to connect to HomeNetwork. Please verify the password."
            })
        )
    )
)]
pub async fn update_wifi(
    State(state): State<AppState>,
    Json(request): Json<UpdateWifiRequest>,
) -> ApiResult<Json<UpdateWifiResponse>> {
    // Validate at least one network
    if request.networks.is_empty() {
        return Err(ApiError::BadRequest {
            error_code: "no_networks".to_string(),
            message: "At least one WiFi network must be configured".to_string(),
        });
    }

    // Validate exactly one primary network
    let primary_count = request.networks.iter().filter(|n| n.is_primary).count();
    if primary_count != 1 {
        return Err(ApiError::BadRequest {
            error_code: "no_primary_network".to_string(),
            message: "Exactly one network must be marked as primary".to_string(),
        });
    }

    // Validate SSIDs are non-empty
    for network in &request.networks {
        if network.ssid.trim().is_empty() {
            return Err(ApiError::BadRequest {
                error_code: "empty_ssid".to_string(),
                message: "Network SSID cannot be empty".to_string(),
            });
        }
    }

    // Find primary network
    let primary_network = request
        .networks
        .iter()
        .find(|n| n.is_primary)
        .unwrap(); // Safe: we validated above

    // Update configuration
    state
        .config_service
        .update_wifi_networks(request.networks.clone())
        .await?;

    // Attempt to connect to primary network
    let connection_result = state
        .wifi_service
        .connect_to_network(&primary_network.ssid, &primary_network.password)
        .await;

    match connection_result {
        Ok(_) => Ok(Json(UpdateWifiResponse {
            success: true,
            message: format!(
                "WiFi configuration updated. Connected to {}.",
                primary_network.ssid
            ),
            connected_ssid: Some(primary_network.ssid.clone()),
            networks_count: request.networks.len(),
        })),
        Err(e) => Err(ApiError::ServiceUnavailable {
            error_code: "connection_failed".to_string(),
            message: format!(
                "Failed to connect to {}. Please verify the password.",
                primary_network.ssid
            ),
            details: Some(e.to_string()),
        }),
    }
}

// ============================================================================
// PUT /api/config/timezone - Update Timezone
// ============================================================================

/// Request to update timezone.
#[derive(Debug, Clone, Deserialize, ToSchema)]
#[schema(example = json!({
    "timezone": "America/Los_Angeles"
}))]
pub struct UpdateTimezoneRequest {
    /// IANA timezone name (e.g., "America/Los_Angeles", "Europe/London").
    /// See: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    #[schema(example = "America/Los_Angeles")]
    pub timezone: String,
}

/// Response after updating timezone.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(example = json!({
    "success": true,
    "message": "Timezone updated to America/Los_Angeles",
    "timezone": "America/Los_Angeles",
    "current_local_time": "2025-01-14T19:45:00-08:00"
}))]
pub struct UpdateTimezoneResponse {
    #[schema(example = true)]
    pub success: bool,

    #[schema(example = "Timezone updated to America/Los_Angeles")]
    pub message: String,

    /// The new timezone setting.
    #[schema(example = "America/Los_Angeles")]
    pub timezone: String,

    /// Current time in the new timezone (for verification).
    #[schema(example = "2025-01-14T19:45:00-08:00")]
    pub current_local_time: String,
}

/// Update system timezone.
///
/// Sets the timezone used for pass reset calculations and local time display.
///
/// **Takes Effect:** Immediately. The next pass reset calculation will use the new timezone.
///
/// **Pass Reset Impact:** If changed mid-month, the next reset will occur at midnight
/// on the 1st of the next month in the NEW timezone.
#[utoipa::path(
    put,
    path = "/timezone",
    tag = "config",
    operation_id = "updateTimezone",
    summary = "Update system timezone",
    description = "Sets the timezone for the system. This affects when passes reset \
        (midnight on the 1st of each month in local time) and time display. \
        Use IANA timezone names (e.g., 'America/Los_Angeles', 'Europe/London').",
    request_body(
        content = UpdateTimezoneRequest,
        description = "Timezone to set",
        content_type = "application/json"
    ),
    responses(
        (status = 200, description = "Timezone updated", body = UpdateTimezoneResponse),
        (status = 400, description = "Invalid timezone",
            example = json!({
                "error": "invalid_timezone",
                "message": "Unknown timezone: 'NotATimezone'. Use IANA timezone names."
            })
        )
    )
)]
pub async fn update_timezone(
    State(state): State<AppState>,
    Json(request): Json<UpdateTimezoneRequest>,
) -> ApiResult<Json<UpdateTimezoneResponse>> {
    // Validate timezone is a valid IANA timezone
    let tz: chrono_tz::Tz = request
        .timezone
        .parse()
        .map_err(|_| ApiError::BadRequest {
            error_code: "invalid_timezone".to_string(),
            message: format!(
                "Unknown timezone: '{}'. Use IANA timezone names (e.g., 'America/Los_Angeles').",
                request.timezone
            ),
        })?;

    // Update configuration
    state
        .config_service
        .update_timezone(request.timezone.clone())
        .await?;

    // Get current time in new timezone for verification
    let now = chrono::Utc::now();
    let local_time = now.with_timezone(&tz);
    let current_local_time = local_time.to_rfc3339();

    Ok(Json(UpdateTimezoneResponse {
        success: true,
        message: format!("Timezone updated to {}", request.timezone),
        timezone: request.timezone,
        current_local_time,
    }))
}

// ============================================================================
// PUT /api/config/passes - Update Passes Per Month
// ============================================================================

/// Request to update passes per month.
#[derive(Debug, Clone, Deserialize, ToSchema)]
#[schema(example = json!({
    "per_month": 3
}))]
pub struct UpdatePassesRequest {
    /// Number of passes to allow per month.
    /// Must be between 0 and 31 (max 1 pass per day).
    #[schema(example = 3, minimum = 0, maximum = 31)]
    pub per_month: u32,
}

/// Response after updating passes per month.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(example = json!({
    "success": true,
    "message": "Passes per month updated to 3. Change takes effect February 1st.",
    "per_month": 3,
    "effective_date": "2025-02-01",
    "current_month_passes": 2
}))]
pub struct UpdatePassesResponse {
    #[schema(example = true)]
    pub success: bool,

    #[schema(example = "Passes per month updated to 3. Change takes effect February 1st.")]
    pub message: String,

    /// The new passes per month setting.
    #[schema(example = 3)]
    pub per_month: u32,

    /// When this change takes effect (first of next month).
    #[schema(example = "2025-02-01")]
    pub effective_date: String,

    /// Passes per month for the current month (unchanged).
    #[schema(example = 2)]
    pub current_month_passes: u32,
}

/// Update passes per month allocation.
///
/// Sets how many emergency passes are allocated per month.
///
/// **IMPORTANT:** Changes only take effect at the start of the NEXT month.
/// The current month's allocation remains unchanged.
///
/// **Rationale:** This prevents gaming the system by increasing passes mid-month
/// when you've already used them all.
#[utoipa::path(
    put,
    path = "/passes",
    tag = "config",
    operation_id = "updatePassesPerMonth",
    summary = "Update passes per month allocation",
    description = "Sets the number of emergency passes allocated per month. \
        IMPORTANT: Changes only take effect at the start of the next month. \
        The current month's allocation remains unchanged to prevent gaming the system.",
    request_body(
        content = UpdatePassesRequest,
        description = "Passes per month to set",
        content_type = "application/json"
    ),
    responses(
        (status = 200, description = "Passes per month updated", body = UpdatePassesResponse),
        (status = 400, description = "Invalid passes count",
            example = json!({
                "error": "invalid_passes_count",
                "message": "Passes per month must be between 0 and 31"
            })
        )
    )
)]
pub async fn update_passes(
    State(state): State<AppState>,
    Json(request): Json<UpdatePassesRequest>,
) -> ApiResult<Json<UpdatePassesResponse>> {
    // Validate range
    if request.per_month > 31 {
        return Err(ApiError::BadRequest {
            error_code: "invalid_passes_count".to_string(),
            message: "Passes per month must be between 0 and 31".to_string(),
        });
    }

    // Get current config for timezone
    let config = state.config_service.get_config().await?;

    // Get current month's effective passes (won't change)
    let current_month_passes = state
        .pass_service
        .get_effective_passes_per_month(&config.timezone)
        .await?;

    // Calculate effective date (first of next month)
    let effective_date = state
        .pass_service
        .get_next_month_start(&config.timezone)
        .await?;

    // Update configuration
    state
        .config_service
        .update_passes_per_month(request.per_month)
        .await?;

    // Format effective date for display
    let effective_month = format_month_name(&effective_date);

    Ok(Json(UpdatePassesResponse {
        success: true,
        message: format!(
            "Passes per month updated to {}. Change takes effect {}.",
            request.per_month, effective_month
        ),
        per_month: request.per_month,
        effective_date,
        current_month_passes,
    }))
}

// ============================================================================
// POST /api/config/complete-onboarding - Mark Onboarding Complete
// ============================================================================

/// Response after completing onboarding.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(example = json!({
    "success": true,
    "message": "Onboarding complete! Temporary AP will be disabled. Connect to your primary WiFi network to continue.",
    "primary_network_ssid": "HomeNetwork",
    "local_url": "http://tether.local"
}))]
pub struct CompleteOnboardingResponse {
    #[schema(example = true)]
    pub success: bool,

    #[schema(example = "Onboarding complete! Temporary AP will be disabled. Connect to your primary WiFi network to continue.")]
    pub message: String,

    /// The primary WiFi network to connect to.
    #[schema(example = "HomeNetwork")]
    pub primary_network_ssid: String,

    /// Local URL to access tether on the primary network.
    #[schema(example = "http://tether.local")]
    pub local_url: String,
}

/// Mark onboarding as complete.
///
/// Call this after all onboarding steps are finished:
/// 1. Bluetooth device selected and threshold configured
/// 2. At least one WiFi network configured (with primary set)
/// 3. Timezone configured
/// 4. Passes per month configured
///
/// **Side Effects:**
/// - Sets `onboarding_complete = true` in config
/// - Disables the temporary AP WiFi network
/// - Starts dumbpipe for remote access
///
/// After this call, the user should switch to the primary WiFi network
/// and access tether at `http://tether.local`.
#[utoipa::path(
    post,
    path = "/complete-onboarding",
    tag = "config",
    operation_id = "completeOnboarding",
    summary = "Mark onboarding as complete",
    description = "Finalizes the onboarding process. This disables the temporary AP network \
        and starts dumbpipe for remote access. Call this only after all configuration is complete. \
        The user must then switch to the primary WiFi network.",
    responses(
        (status = 200, description = "Onboarding completed", body = CompleteOnboardingResponse),
        (status = 400, description = "Onboarding already complete",
            example = json!({
                "error": "already_complete",
                "message": "Onboarding has already been completed"
            })
        ),
        (status = 424, description = "Onboarding prerequisites not met",
            example = json!({
                "error": "prerequisites_not_met",
                "message": "Cannot complete onboarding: Bluetooth device not configured"
            })
        )
    )
)]
pub async fn complete_onboarding(
    State(state): State<AppState>,
) -> ApiResult<Json<CompleteOnboardingResponse>> {
    // Get current config
    let config = state.config_service.get_config().await?;

    // Check if already complete
    if config.onboarding_complete {
        return Err(ApiError::BadRequest {
            error_code: "already_complete".to_string(),
            message: "Onboarding has already been completed".to_string(),
        });
    }

    // Validate prerequisites
    if config.bluetooth.is_none() {
        return Err(ApiError::FailedDependency {
            error_code: "prerequisites_not_met".to_string(),
            message: "Cannot complete onboarding: Bluetooth device not configured".to_string(),
            details: None,
        });
    }

    if config.wifi_networks.is_empty() {
        return Err(ApiError::FailedDependency {
            error_code: "prerequisites_not_met".to_string(),
            message: "Cannot complete onboarding: No WiFi networks configured".to_string(),
            details: None,
        });
    }

    let primary_network = config
        .wifi_networks
        .iter()
        .find(|n| n.is_primary)
        .ok_or_else(|| ApiError::FailedDependency {
            error_code: "prerequisites_not_met".to_string(),
            message: "Cannot complete onboarding: No primary WiFi network set".to_string(),
            details: None,
        })?;

    // Mark onboarding complete
    state.config_service.set_onboarding_complete(true).await?;

    // Disable temporary AP
    state.wifi_service.disable_temporary_ap().await?;

    // Start dumbpipe for remote access
    state.dumbpipe_service.start().await?;

    Ok(Json(CompleteOnboardingResponse {
        success: true,
        message: "Onboarding complete! Temporary AP will be disabled. Connect to your primary WiFi network to continue.".to_string(),
        primary_network_ssid: primary_network.ssid.clone(),
        local_url: "http://tether.local".to_string(),
    }))
}

// ============================================================================
// Helper Functions
// ============================================================================

/// Validates Bluetooth MAC address format (XX:XX:XX:XX:XX:XX).
fn is_valid_bluetooth_address(address: &str) -> bool {
    let parts: Vec<&str> = address.split(':').collect();
    if parts.len() != 6 {
        return false;
    }

    parts.iter().all(|part| {
        part.len() == 2 && part.chars().all(|c| c.is_ascii_hexdigit())
    })
}

/// Formats a date string (YYYY-MM-DD) to a readable month name (e.g., "February 1st").
fn format_month_name(date: &str) -> String {
    let parts: Vec<&str> = date.split('-').collect();
    if parts.len() < 2 {
        return date.to_string();
    }

    let month_name = match parts[1] {
        "01" => "January",
        "02" => "February",
        "03" => "March",
        "04" => "April",
        "05" => "May",
        "06" => "June",
        "07" => "July",
        "08" => "August",
        "09" => "September",
        "10" => "October",
        "11" => "November",
        "12" => "December",
        _ => return date.to_string(),
    };

    let day = parts.get(2).map(|d| format!(" {}", d.trim_start_matches('0'))).unwrap_or_default();
    let suffix = match day.trim() {
        "1" | "21" | "31" => "st",
        "2" | "22" => "nd",
        "3" | "23" => "rd",
        _ => "th",
    };

    format!("{}{}{}", month_name, day, suffix)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_valid_bluetooth_address() {
        assert!(is_valid_bluetooth_address("AA:BB:CC:DD:EE:FF"));
        assert!(is_valid_bluetooth_address("aa:bb:cc:dd:ee:ff"));
        assert!(is_valid_bluetooth_address("00:11:22:33:44:55"));
        assert!(!is_valid_bluetooth_address("AA:BB:CC:DD:EE"));
        assert!(!is_valid_bluetooth_address("AABBCCDDEEFF"));
        assert!(!is_valid_bluetooth_address("GG:HH:II:JJ:KK:LL"));
    }
}
```

---

## File: `/Users/jeffrey/code/tether/tether-server/src/routes/system.rs`

### Routes:
- `GET /api/system/status` - Get system status
- `GET /api/system/ticket` - Get dumbpipe ticket
- `POST /api/system/restart` - Trigger system restart

```rust
//! System status and control endpoints.
//!
//! Provides endpoints for:
//! - Checking overall system status
//! - Retrieving the dumbpipe ticket for remote access
//! - Triggering a system restart

use axum::{extract::State, Json};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;
use utoipa_axum::{router::OpenApiRouter, routes};

use crate::{
    error::{ApiError, ApiResult},
    state::AppState,
};

/// Creates the system router with all endpoints.
pub fn router() -> OpenApiRouter<AppState> {
    OpenApiRouter::new()
        .routes(routes!(get_status))
        .routes(routes!(get_ticket))
        .routes(routes!(restart_system))
}

// ============================================================================
// GET /api/system/status - System Status
// ============================================================================

/// System status response.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(example = json!({
    "status": "healthy",
    "onboarding_complete": true,
    "bluetooth": {
        "available": true,
        "adapter": "hci0",
        "powered": true
    },
    "wifi": {
        "connected": true,
        "ssid": "HomeNetwork",
        "signal_strength_percent": 85,
        "internet_available": true
    },
    "dumbpipe": {
        "running": true,
        "connected_peers": 1
    },
    "uptime_seconds": 86400,
    "version": "1.0.0",
    "timestamp_utc": "2025-01-15T03:30:00Z"
}))]
pub struct SystemStatusResponse {
    /// Overall system health status.
    /// - "healthy": All systems operational
    /// - "degraded": Some non-critical issues
    /// - "unhealthy": Critical issues present
    #[schema(example = "healthy")]
    pub status: String,

    /// Whether the onboarding process has been completed.
    #[schema(example = true)]
    pub onboarding_complete: bool,

    /// Bluetooth subsystem status.
    pub bluetooth: BluetoothStatus,

    /// WiFi subsystem status.
    pub wifi: WifiStatus,

    /// Dumbpipe (remote access) subsystem status.
    pub dumbpipe: DumbpipeStatus,

    /// System uptime in seconds since boot.
    #[schema(example = 86400)]
    pub uptime_seconds: u64,

    /// Tether server version.
    #[schema(example = "1.0.0")]
    pub version: String,

    /// Current UTC timestamp.
    #[schema(example = "2025-01-15T03:30:00Z")]
    pub timestamp_utc: String,
}

/// Bluetooth subsystem status.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(example = json!({
    "available": true,
    "adapter": "hci0",
    "powered": true
}))]
pub struct BluetoothStatus {
    /// Whether a Bluetooth adapter is available.
    #[schema(example = true)]
    pub available: bool,

    /// Adapter identifier (e.g., "hci0").
    #[schema(example = "hci0", nullable)]
    pub adapter: Option<String>,

    /// Whether the adapter is powered on.
    #[schema(example = true)]
    pub powered: bool,
}

/// WiFi subsystem status.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(example = json!({
    "connected": true,
    "ssid": "HomeNetwork",
    "signal_strength_percent": 85,
    "internet_available": true
}))]
pub struct WifiStatus {
    /// Whether connected to a WiFi network.
    #[schema(example = true)]
    pub connected: bool,

    /// SSID of connected network (if connected).
    #[schema(example = "HomeNetwork", nullable)]
    pub ssid: Option<String>,

    /// Signal strength as percentage (0-100).
    #[schema(example = 85, nullable, minimum = 0, maximum = 100)]
    pub signal_strength_percent: Option<u8>,

    /// Whether internet is reachable.
    #[schema(example = true)]
    pub internet_available: bool,
}

/// Dumbpipe (remote access) subsystem status.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(example = json!({
    "running": true,
    "connected_peers": 1
}))]
pub struct DumbpipeStatus {
    /// Whether dumbpipe is running.
    #[schema(example = true)]
    pub running: bool,

    /// Number of connected peers (MCP clients).
    #[schema(example = 1)]
    pub connected_peers: u32,
}

/// Get comprehensive system status.
///
/// Returns the health status of all system components including Bluetooth,
/// WiFi, and dumbpipe. Use this endpoint to check if the system is
/// operational and diagnose issues.
///
/// **Health Status Logic:**
/// - `healthy`: Bluetooth available, WiFi connected with internet, dumbpipe running
/// - `degraded`: Some components have non-critical issues
/// - `unhealthy`: Critical components are unavailable
#[utoipa::path(
    get,
    path = "/status",
    tag = "system",
    operation_id = "getSystemStatus",
    summary = "Get system status",
    description = "Returns comprehensive system health status including Bluetooth adapter, \
        WiFi connection, internet availability, and dumbpipe (remote access) status. \
        Use this to verify the system is operational and diagnose any issues.",
    responses(
        (status = 200, description = "System status retrieved", body = SystemStatusResponse)
    )
)]
pub async fn get_status(State(state): State<AppState>) -> ApiResult<Json<SystemStatusResponse>> {
    // Get config for onboarding status
    let config = state.config_service.get_config().await?;

    // Get Bluetooth status
    let bt_status = state.bluetooth_service.get_adapter_status().await;
    let bluetooth = BluetoothStatus {
        available: bt_status.available,
        adapter: bt_status.adapter_name,
        powered: bt_status.powered,
    };

    // Get WiFi status
    let wifi_status = state.wifi_service.get_connection_status().await;
    let wifi = WifiStatus {
        connected: wifi_status.connected,
        ssid: wifi_status.ssid,
        signal_strength_percent: wifi_status.signal_strength_percent,
        internet_available: wifi_status.internet_available,
    };

    // Get dumbpipe status
    let dp_status = state.dumbpipe_service.get_status().await;
    let dumbpipe = DumbpipeStatus {
        running: dp_status.running,
        connected_peers: dp_status.connected_peers,
    };

    // Determine overall health
    let status = determine_health_status(&bluetooth, &wifi, &dumbpipe, config.onboarding_complete);

    // Get uptime
    let uptime_seconds = state.system_service.get_uptime_seconds().await?;

    // Get version
    let version = env!("CARGO_PKG_VERSION").to_string();

    // Current timestamp
    let timestamp_utc = chrono::Utc::now().to_rfc3339();

    Ok(Json(SystemStatusResponse {
        status,
        onboarding_complete: config.onboarding_complete,
        bluetooth,
        wifi,
        dumbpipe,
        uptime_seconds,
        version,
        timestamp_utc,
    }))
}

/// Determines the overall health status based on component states.
fn determine_health_status(
    bluetooth: &BluetoothStatus,
    wifi: &WifiStatus,
    dumbpipe: &DumbpipeStatus,
    onboarding_complete: bool,
) -> String {
    // Before onboarding, we're in setup mode - not unhealthy
    if !onboarding_complete {
        return "setup".to_string();
    }

    // Critical: Bluetooth must be available and powered
    if !bluetooth.available || !bluetooth.powered {
        return "unhealthy".to_string();
    }

    // Critical: WiFi must be connected with internet
    if !wifi.connected || !wifi.internet_available {
        return "unhealthy".to_string();
    }

    // Degraded: dumbpipe not running (local access still works)
    if !dumbpipe.running {
        return "degraded".to_string();
    }

    "healthy".to_string()
}

// ============================================================================
// GET /api/system/ticket - Dumbpipe Ticket
// ============================================================================

/// Dumbpipe ticket response.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(example = json!({
    "ticket": "blob1234abcd5678efgh9012ijkl3456mnop7890qrst",
    "generated_at_utc": "2025-01-15T03:30:00Z",
    "expires_at_utc": null,
    "connection_instructions": "Use this ticket with the MCP server to connect remotely. Set TETHER_TICKET environment variable."
}))]
pub struct TicketResponse {
    /// The dumbpipe connection ticket.
    /// This is a base64-encoded iroh ticket that allows remote connection.
    #[schema(example = "blob1234abcd5678efgh9012ijkl3456mnop7890qrst")]
    pub ticket: String,

    /// When this ticket was generated.
    #[schema(example = "2025-01-15T03:30:00Z")]
    pub generated_at_utc: String,

    /// When this ticket expires (null if no expiration).
    #[schema(nullable, example = json!(null))]
    pub expires_at_utc: Option<String>,

    /// Human-readable instructions for using the ticket.
    #[schema(example = "Use this ticket with the MCP server to connect remotely. Set TETHER_TICKET environment variable.")]
    pub connection_instructions: String,
}

/// Get the dumbpipe connection ticket.
///
/// Returns the ticket needed for remote access via dumbpipe/iroh.
/// This ticket should be provided to the MCP server as an environment variable.
///
/// **Security Note:**
/// - The ticket allows anyone with it to connect to this device
/// - Keep the ticket private and share only with trusted MCP clients
/// - A new ticket is generated each time dumbpipe starts
///
/// **Usage:**
/// Set `TETHER_TICKET=<ticket>` when running the MCP server.
#[utoipa::path(
    get,
    path = "/ticket",
    tag = "system",
    operation_id = "getDumbpipeTicket",
    summary = "Get dumbpipe connection ticket",
    description = "Returns the dumbpipe ticket for remote access. This ticket allows \
        MCP clients to connect to the Tether device over the internet via iroh. \
        Keep this ticket secure - anyone with it can connect to your device.",
    responses(
        (status = 200, description = "Ticket retrieved successfully", body = TicketResponse,
            example = json!({
                "ticket": "blob1234abcd5678efgh9012ijkl3456mnop7890qrst",
                "generated_at_utc": "2025-01-15T03:30:00Z",
                "expires_at_utc": null,
                "connection_instructions": "Use this ticket with the MCP server to connect remotely. Set TETHER_TICKET environment variable."
            })
        ),
        (status = 503, description = "Dumbpipe not running",
            example = json!({
                "error": "dumbpipe_not_running",
                "message": "Dumbpipe is not running. Complete onboarding to enable remote access."
            })
        )
    )
)]
pub async fn get_ticket(State(state): State<AppState>) -> ApiResult<Json<TicketResponse>> {
    // Check if dumbpipe is running
    let dp_status = state.dumbpipe_service.get_status().await;
    if !dp_status.running {
        return Err(ApiError::ServiceUnavailable {
            error_code: "dumbpipe_not_running".to_string(),
            message: "Dumbpipe is not running. Complete onboarding to enable remote access."
                .to_string(),
            details: None,
        });
    }

    // Get the ticket
    let ticket = state.dumbpipe_service.get_ticket().await?;

    Ok(Json(TicketResponse {
        ticket: ticket.value,
        generated_at_utc: ticket.generated_at_utc,
        expires_at_utc: ticket.expires_at_utc,
        connection_instructions:
            "Use this ticket with the MCP server to connect remotely. Set TETHER_TICKET environment variable."
                .to_string(),
    }))
}

// ============================================================================
// POST /api/system/restart - System Restart
// ============================================================================

/// Request to restart the system.
#[derive(Debug, Clone, Deserialize, ToSchema)]
#[schema(example = json!({
    "delay_seconds": 5,
    "reason": "User requested restart"
}))]
pub struct RestartRequest {
    /// Delay before restart in seconds (0-60).
    /// Allows time for the response to be sent.
    #[schema(example = 5, minimum = 0, maximum = 60, default = 3)]
    pub delay_seconds: Option<u32>,

    /// Optional reason for the restart (for logging).
    #[schema(example = "User requested restart", nullable)]
    pub reason: Option<String>,
}

/// Response before system restart.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(example = json!({
    "success": true,
    "message": "System will restart in 5 seconds",
    "delay_seconds": 5,
    "restart_at_utc": "2025-01-15T03:30:05Z"
}))]
pub struct RestartResponse {
    #[schema(example = true)]
    pub success: bool,

    #[schema(example = "System will restart in 5 seconds")]
    pub message: String,

    /// The delay before restart.
    #[schema(example = 5)]
    pub delay_seconds: u32,

    /// When the restart will occur.
    #[schema(example = "2025-01-15T03:30:05Z")]
    pub restart_at_utc: String,
}

/// Trigger a system restart.
///
/// Initiates a full system restart (reboot) of the Raspberry Pi.
/// Useful for applying system updates or recovering from issues.
///
/// **What Happens:**
/// 1. Response is sent with restart time
/// 2. After delay, all services are stopped gracefully
/// 3. System reboots
/// 4. Services restart automatically after boot
///
/// **Recovery:**
/// - All services auto-start after reboot
/// - Configuration is preserved
/// - Dumbpipe reconnects automatically
#[utoipa::path(
    post,
    path = "/restart",
    tag = "system",
    operation_id = "restartSystem",
    summary = "Trigger system restart",
    description = "Initiates a full system reboot of the Raspberry Pi. The system will \
        restart after the specified delay. All services will restart automatically after boot. \
        Use this to apply updates or recover from issues.",
    request_body(
        content = RestartRequest,
        description = "Restart options",
        content_type = "application/json",
        example = json!({
            "delay_seconds": 5,
            "reason": "User requested restart"
        })
    ),
    responses(
        (status = 200, description = "Restart scheduled", body = RestartResponse),
        (status = 400, description = "Invalid delay",
            example = json!({
                "error": "invalid_delay",
                "message": "Delay must be between 0 and 60 seconds"
            })
        )
    )
)]
pub async fn restart_system(
    State(state): State<AppState>,
    Json(request): Json<RestartRequest>,
) -> ApiResult<Json<RestartResponse>> {
    let delay_seconds = request.delay_seconds.unwrap_or(3);

    // Validate delay
    if delay_seconds > 60 {
        return Err(ApiError::BadRequest {
            error_code: "invalid_delay".to_string(),
            message: "Delay must be between 0 and 60 seconds".to_string(),
        });
    }

    // Calculate restart time
    let restart_at = chrono::Utc::now() + chrono::Duration::seconds(delay_seconds as i64);
    let restart_at_utc = restart_at.to_rfc3339();

    // Log the restart request
    let reason = request.reason.unwrap_or_else(|| "No reason provided".to_string());
    tracing::info!(
        delay_seconds = delay_seconds,
        reason = %reason,
        "System restart requested"
    );

    // Schedule the restart
    state
        .system_service
        .schedule_restart(delay_seconds, reason)
        .await?;

    Ok(Json(RestartResponse {
        success: true,
        message: format!("System will restart in {} seconds", delay_seconds),
        delay_seconds,
        restart_at_utc,
    }))
}
```

---

## File: `/Users/jeffrey/code/tether/tether-server/src/routes/devices.rs`

### Routes:
- `GET /api/devices` - Scan for Bluetooth devices (onboarding)
- `GET /api/devices/:address/rssi` - Get RSSI for specific device

```rust
//! Bluetooth device scanning endpoints.
//!
//! Provides endpoints for discovering and inspecting Bluetooth devices.
//! Used during onboarding to select which device to track and to
//! determine appropriate RSSI thresholds.

use axum::{
    extract::{Path, State},
    Json,
};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;
use utoipa_axum::{router::OpenApiRouter, routes};

use crate::{
    error::{ApiError, ApiResult},
    state::AppState,
};

/// Creates the devices router with all endpoints.
pub fn router() -> OpenApiRouter<AppState> {
    OpenApiRouter::new()
        .routes(routes!(scan_devices))
        .routes(routes!(get_device_rssi))
}

// ============================================================================
// GET /api/devices - Scan for Bluetooth Devices
// ============================================================================

/// A discovered Bluetooth device.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(example = json!({
    "address": "AA:BB:CC:DD:EE:FF",
    "name": "iPhone 15 Pro",
    "rssi_dbm": -45,
    "device_type": "phone",
    "last_seen_utc": "2025-01-15T03:30:00Z"
}))]
pub struct DiscoveredDevice {
    /// Bluetooth MAC address.
    #[schema(example = "AA:BB:CC:DD:EE:FF")]
    pub address: String,

    /// Device name (if advertised).
    /// Some devices don't advertise their name.
    #[schema(example = "iPhone 15 Pro", nullable)]
    pub name: Option<String>,

    /// Current RSSI signal strength in dBm.
    #[schema(example = -45)]
    pub rssi_dbm: i16,

    /// Inferred device type based on Bluetooth class/appearance.
    /// Possible values: "phone", "tablet", "computer", "watch", "headphones", "unknown"
    #[schema(example = "phone")]
    pub device_type: String,

    /// When this device was last detected.
    #[schema(example = "2025-01-15T03:30:00Z")]
    pub last_seen_utc: String,
}

/// Response from Bluetooth device scan.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(example = json!({
    "devices": [
        {
            "address": "AA:BB:CC:DD:EE:FF",
            "name": "iPhone 15 Pro",
            "rssi_dbm": -45,
            "device_type": "phone",
            "last_seen_utc": "2025-01-15T03:30:00Z"
        },
        {
            "address": "11:22:33:44:55:66",
            "name": "MacBook Pro",
            "rssi_dbm": -62,
            "device_type": "computer",
            "last_seen_utc": "2025-01-15T03:30:00Z"
        }
    ],
    "scan_duration_ms": 5000,
    "scanned_at_utc": "2025-01-15T03:30:00Z"
}))]
pub struct ScanDevicesResponse {
    /// List of discovered Bluetooth devices, sorted by RSSI (strongest first).
    pub devices: Vec<DiscoveredDevice>,

    /// How long the scan took in milliseconds.
    #[schema(example = 5000)]
    pub scan_duration_ms: u64,

    /// When the scan was performed.
    #[schema(example = "2025-01-15T03:30:00Z")]
    pub scanned_at_utc: String,
}

/// Scan for nearby Bluetooth devices.
///
/// Performs a Bluetooth scan to discover nearby devices. This is used during
/// onboarding to help the user select which device (typically their phone)
/// to track for proximity detection.
///
/// **Scan Duration:** Approximately 5 seconds to ensure good device discovery.
///
/// **Device Types:**
/// - `phone` - Mobile phones (iOS, Android)
/// - `tablet` - Tablets (iPad, Android tablets)
/// - `computer` - Laptops, desktops
/// - `watch` - Smartwatches
/// - `headphones` - Audio devices
/// - `unknown` - Unidentified device class
///
/// **Usage Tips:**
/// - Ensure the target device has Bluetooth enabled and is discoverable
/// - iPhones may need the Bluetooth settings screen open to be visible
/// - Devices closer to the Pi will have higher (less negative) RSSI values
#[utoipa::path(
    get,
    path = "",
    tag = "devices",
    operation_id = "scanDevices",
    summary = "Scan for Bluetooth devices",
    description = "Performs a Bluetooth scan to discover nearby devices. Used during \
        onboarding to select which device to track. Returns devices sorted by signal \
        strength (strongest first). The scan takes approximately 5 seconds.",
    responses(
        (status = 200, description = "Scan completed successfully", body = ScanDevicesResponse,
            example = json!({
                "devices": [
                    {
                        "address": "AA:BB:CC:DD:EE:FF",
                        "name": "iPhone 15 Pro",
                        "rssi_dbm": -45,
                        "device_type": "phone",
                        "last_seen_utc": "2025-01-15T03:30:00Z"
                    }
                ],
                "scan_duration_ms": 5000,
                "scanned_at_utc": "2025-01-15T03:30:00Z"
            })
        ),
        (status = 503, description = "Bluetooth unavailable",
            example = json!({
                "error": "bluetooth_unavailable",
                "message": "Bluetooth adapter is not available or powered off"
            })
        )
    )
)]
pub async fn scan_devices(
    State(state): State<AppState>,
) -> ApiResult<Json<ScanDevicesResponse>> {
    // Check Bluetooth adapter status first
    let adapter_status = state.bluetooth_service.get_adapter_status().await;
    if !adapter_status.available || !adapter_status.powered {
        return Err(ApiError::ServiceUnavailable {
            error_code: "bluetooth_unavailable".to_string(),
            message: "Bluetooth adapter is not available or powered off".to_string(),
            details: None,
        });
    }

    // Perform the scan
    let scan_start = std::time::Instant::now();
    let scanned_at_utc = chrono::Utc::now().to_rfc3339();

    let discovered = state
        .bluetooth_service
        .scan_for_devices(std::time::Duration::from_secs(5))
        .await
        .map_err(|e| ApiError::ServiceUnavailable {
            error_code: "scan_failed".to_string(),
            message: "Failed to complete Bluetooth scan".to_string(),
            details: Some(e.to_string()),
        })?;

    let scan_duration_ms = scan_start.elapsed().as_millis() as u64;

    // Convert to response format and sort by RSSI (strongest first)
    let mut devices: Vec<DiscoveredDevice> = discovered
        .into_iter()
        .map(|d| DiscoveredDevice {
            address: d.address,
            name: d.name,
            rssi_dbm: d.rssi_dbm,
            device_type: infer_device_type(d.device_class),
            last_seen_utc: scanned_at_utc.clone(),
        })
        .collect();

    // Sort by RSSI (highest/strongest first)
    devices.sort_by(|a, b| b.rssi_dbm.cmp(&a.rssi_dbm));

    Ok(Json(ScanDevicesResponse {
        devices,
        scan_duration_ms,
        scanned_at_utc,
    }))
}

// ============================================================================
// GET /api/devices/:address/rssi - Get Device RSSI
// ============================================================================

/// Path parameters for device RSSI endpoint.
#[derive(Debug, Deserialize)]
pub struct DeviceAddressPath {
    /// Bluetooth MAC address (XX:XX:XX:XX:XX:XX format).
    pub address: String,
}

/// Response with current RSSI for a specific device.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(example = json!({
    "address": "AA:BB:CC:DD:EE:FF",
    "name": "iPhone 15 Pro",
    "rssi_dbm": -52,
    "detected": true,
    "signal_quality": "excellent",
    "checked_at_utc": "2025-01-15T03:30:00Z"
}))]
pub struct DeviceRssiResponse {
    /// Bluetooth MAC address.
    #[schema(example = "AA:BB:CC:DD:EE:FF")]
    pub address: String,

    /// Device name (if known/cached).
    #[schema(example = "iPhone 15 Pro", nullable)]
    pub name: Option<String>,

    /// Current RSSI signal strength in dBm.
    /// `None` if device was not detected.
    #[schema(example = -52, nullable)]
    pub rssi_dbm: Option<i16>,

    /// Whether the device was detected in this scan.
    #[schema(example = true)]
    pub detected: bool,

    /// Human-readable signal quality assessment.
    /// - "excellent": RSSI >= -50 (very close)
    /// - "good": RSSI >= -60 (same room)
    /// - "fair": RSSI >= -70 (nearby room)
    /// - "weak": RSSI >= -80 (far)
    /// - "very_weak": RSSI < -80 (barely detectable)
    /// - "not_detected": Device not found
    #[schema(example = "excellent")]
    pub signal_quality: String,

    /// When this check was performed.
    #[schema(example = "2025-01-15T03:30:00Z")]
    pub checked_at_utc: String,
}

/// Get current RSSI for a specific Bluetooth device.
///
/// Performs a targeted scan to measure the current signal strength of a
/// specific device. Use this during onboarding to help the user determine
/// an appropriate RSSI threshold.
///
/// **How to Use for Threshold Selection:**
/// 1. Place the phone where it should be when "docked" (on the charger, in another room)
/// 2. Call this endpoint repeatedly to see the RSSI values
/// 3. Note the typical RSSI range
/// 4. Set threshold slightly above this range (less negative)
///
/// **Example:**
/// If the phone at the dock location shows RSSI around -75 to -80,
/// set the threshold to -70. This means anything stronger than -70
/// is considered "too close" (phone not at dock).
#[utoipa::path(
    get,
    path = "/{address}/rssi",
    tag = "devices",
    operation_id = "getDeviceRssi",
    summary = "Get current RSSI for a specific device",
    description = "Performs a quick scan to measure the signal strength of a specific \
        Bluetooth device. Use this during onboarding to help determine the appropriate \
        RSSI threshold. The device should be at the 'docked' location when measuring \
        to establish baseline signal strength.",
    params(
        ("address" = String, Path, description = "Bluetooth MAC address (XX:XX:XX:XX:XX:XX)", 
            example = "AA:BB:CC:DD:EE:FF")
    ),
    responses(
        (status = 200, description = "RSSI measurement completed", body = DeviceRssiResponse,
            example = json!({
                "address": "AA:BB:CC:DD:EE:FF",
                "name": "iPhone 15 Pro",
                "rssi_dbm": -52,
                "detected": true,
                "signal_quality": "excellent",
                "checked_at_utc": "2025-01-15T03:30:00Z"
            })
        ),
        (status = 200, description = "Device not detected", body = DeviceRssiResponse,
            example = json!({
                "address": "AA:BB:CC:DD:EE:FF",
                "name": null,
                "rssi_dbm": null,
                "detected": false,
                "signal_quality": "not_detected",
                "checked_at_utc": "2025-01-15T03:30:00Z"
            })
        ),
        (status = 400, description = "Invalid Bluetooth address",
            example = json!({
                "error": "invalid_address",
                "message": "Invalid Bluetooth address format. Expected XX:XX:XX:XX:XX:XX"
            })
        ),
        (status = 503, description = "Bluetooth unavailable",
            example = json!({
                "error": "bluetooth_unavailable",
                "message": "Bluetooth adapter is not available or powered off"
            })
        )
    )
)]
pub async fn get_device_rssi(
    State(state): State<AppState>,
    Path(params): Path<DeviceAddressPath>,
) -> ApiResult<Json<DeviceRssiResponse>> {
    // Validate address format
    if !is_valid_bluetooth_address(&params.address) {
        return Err(ApiError::BadRequest {
            error_code: "invalid_address".to_string(),
            message: "Invalid Bluetooth address format. Expected XX:XX:XX:XX:XX:XX".to_string(),
        });
    }

    // Normalize to uppercase
    let address = params.address.to_uppercase();

    // Check Bluetooth adapter status
    let adapter_status = state.bluetooth_service.get_adapter_status().await;
    if !adapter_status.available || !adapter_status.powered {
        return Err(ApiError::ServiceUnavailable {
            error_code: "bluetooth_unavailable".to_string(),
            message: "Bluetooth adapter is not available or powered off".to_string(),
            details: None,
        });
    }

    let checked_at_utc = chrono::Utc::now().to_rfc3339();

    // Perform targeted RSSI lookup
    let result = state
        .bluetooth_service
        .get_device_rssi(&address)
        .await
        .map_err(|e| ApiError::ServiceUnavailable {
            error_code: "rssi_check_failed".to_string(),
            message: "Failed to check device RSSI".to_string(),
            details: Some(e.to_string()),
        })?;

    let signal_quality = match result.rssi_dbm {
        Some(rssi) => assess_signal_quality(rssi),
        None => "not_detected".to_string(),
    };

    Ok(Json(DeviceRssiResponse {
        address,
        name: result.name,
        rssi_dbm: result.rssi_dbm,
        detected: result.rssi_dbm.is_some(),
        signal_quality,
        checked_at_utc,
    }))
}

// ============================================================================
// Helper Functions
// ============================================================================

/// Validates Bluetooth MAC address format.
fn is_valid_bluetooth_address(address: &str) -> bool {
    let parts: Vec<&str> = address.split(':').collect();
    if parts.len() != 6 {
        return false;
    }

    parts
        .iter()
        .all(|part| part.len() == 2 && part.chars().all(|c| c.is_ascii_hexdigit()))
}

/// Infers device type from Bluetooth device class.
fn infer_device_type(device_class: Option<u32>) -> String {
    match device_class {
        Some(class) => {
            // Major device class is bits 8-12
            let major_class = (class >> 8) & 0x1F;
            match major_class {
                1 => "computer".to_string(),   // Computer
                2 => "phone".to_string(),      // Phone
                3 => "network".to_string(),    // LAN/Network Access Point
                4 => "audio".to_string(),      // Audio/Video
                5 => "peripheral".to_string(), // Peripheral
                6 => "imaging".to_string(),    // Imaging
                7 => "wearable".to_string(),   // Wearable (includes watches)
                _ => "unknown".to_string(),
            }
        }
        None => "unknown".to_string(),
    }
}

/// Assesses signal quality based on RSSI value.
fn assess_signal_quality(rssi: i16) -> String {
    if rssi >= -50 {
        "excellent".to_string()
    } else if rssi >= -60 {
        "good".to_string()
    } else if rssi >= -70 {
        "fair".to_string()
    } else if rssi >= -80 {
        "weak".to_string()
    } else {
        "very_weak".to_string()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_valid_bluetooth_address() {
        assert!(is_valid_bluetooth_address("AA:BB:CC:DD:EE:FF"));
        assert!(is_valid_bluetooth_address("aa:bb:cc:dd:ee:ff"));
        assert!(!is_valid_bluetooth_address("AABBCCDDEEFF"));
        assert!(!is_valid_bluetooth_address("AA:BB:CC:DD:EE"));
    }

    #[test]
    fn test_signal_quality() {
        assert_eq!(assess_signal_quality(-40), "excellent");
        assert_eq!(assess_signal_quality(-55), "good");
        assert_eq!(assess_signal_quality(-65), "fair");
        assert_eq!(assess_signal_quality(-75), "weak");
        assert_eq!(assess_signal_quality(-90), "very_weak");
    }

    #[test]
    fn test_device_type_inference() {
        assert_eq!(infer_device_type(Some(0x200)), "phone");
        assert_eq!(infer_device_type(Some(0x100)), "computer");
        assert_eq!(infer_device_type(None), "unknown");
    }
}
```

---

## File: `/Users/jeffrey/code/tether/tether-server/src/error.rs`

Supporting error types referenced by all handlers:

```rust
//! API error types and handling.
//!
//! Provides a unified error type that maps to appropriate HTTP status codes
//! and JSON error responses. Implements IntoResponse for seamless integration
//! with Axum handlers.

use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

/// Result type alias for API handlers.
pub type ApiResult<T> = Result<T, ApiError>;

/// Unified API error type.
///
/// Each variant maps to a specific HTTP status code and produces a
/// consistent JSON error response.
#[derive(Debug, Clone)]
pub enum ApiError {
    /// 400 Bad Request - Invalid input from client.
    BadRequest {
        error_code: String,
        message: String,
    },

    /// 404 Not Found - Requested resource doesn't exist.
    NotFound {
        error_code: String,
        message: String,
    },

    /// 409 Conflict - Request conflicts with current state.
    Conflict {
        error_code: String,
        message: String,
        remaining: u32,
        resets_at_utc: Option<String>,
    },

    /// 424 Failed Dependency - Required precondition not met.
    FailedDependency {
        error_code: String,
        message: String,
        details: Option<String>,
    },

    /// 500 Internal Server Error - Unexpected server error.
    InternalError {
        error_code: String,
        message: String,
        details: Option<String>,
    },

    /// 503 Service Unavailable - Dependent service is unavailable.
    ServiceUnavailable {
        error_code: String,
        message: String,
        details: Option<String>,
    },
}

/// JSON structure for error responses.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[schema(example = json!({
    "error": "not_found",
    "message": "The requested resource was not found",
    "details": null
}))]
pub struct ErrorResponse {
    /// Machine-readable error code (snake_case).
    #[schema(example = "not_found")]
    pub error: String,

    /// Human-readable error message.
    #[schema(example = "The requested resource was not found")]
    pub message: String,

    /// Optional additional details for debugging.
    #[schema(nullable)]
    pub details: Option<serde_json::Value>,
}

impl IntoResponse for ApiError {
    fn into_response(self) -> Response {
        let (status, error_response) = match self {
            ApiError::BadRequest { error_code, message } => (
                StatusCode::BAD_REQUEST,
                ErrorResponse {
                    error: error_code,
                    message,
                    details: None,
                },
            ),

            ApiError::NotFound { error_code, message } => (
                StatusCode::NOT_FOUND,
                ErrorResponse {
                    error: error_code,
                    message,
                    details: None,
                },
            ),

            ApiError::Conflict {
                error_code,
                message,
                remaining,
                resets_at_utc,
            } => (
                StatusCode::CONFLICT,
                ErrorResponse {
                    error: error_code,
                    message,
                    details: Some(serde_json::json!({
                        "remaining": remaining,
                        "resets_at_utc": resets_at_utc
                    })),
                },
            ),

            ApiError::FailedDependency {
                error_code,
                message,
                details,
            } => (
                StatusCode::from_u16(424).unwrap_or(StatusCode::INTERNAL_SERVER_ERROR),
                ErrorResponse {
                    error: error_code,
                    message,
                    details: details.map(|d| serde_json::json!(d)),
                },
            ),

            ApiError::InternalError {
                error_code,
                message,
                details,
            } => {
                // Log internal errors
                tracing::error!(
                    error_code = %error_code,
                    message = %message,
                    details = ?details,
                    "Internal server error"
                );
                (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    ErrorResponse {
                        error: error_code,
                        message,
                        details: details.map(|d| serde_json::json!(d)),
                    },
                )
            }

            ApiError::ServiceUnavailable {
                error_code,
                message,
                details,
            } => (
                StatusCode::SERVICE_UNAVAILABLE,
                ErrorResponse {
                    error: error_code,
                    message,
                    details: details.map(|d| serde_json::json!(d)),
                },
            ),
        };

        (status, Json(error_response)).into_response()
    }
}

impl std::fmt::Display for ApiError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ApiError::BadRequest { message, .. } => write!(f, "Bad Request: {}", message),
            ApiError::NotFound { message, .. } => write!(f, "Not Found: {}", message),
            ApiError::Conflict { message, .. } => write!(f, "Conflict: {}", message),
            ApiError::FailedDependency { message, .. } => {
                write!(f, "Failed Dependency: {}", message)
            }
            ApiError::InternalError { message, .. } => {
                write!(f, "Internal Error: {}", message)
            }
            ApiError::ServiceUnavailable { message, .. } => {
                write!(f, "Service Unavailable: {}", message)
            }
        }
    }
}

impl std::error::Error for ApiError {}

/// Extension trait for checking specific error types.
pub trait PassErrorExt {
    fn is_no_passes_remaining(&self) -> bool;
}

// This would be implemented on your PassService error type
// Example implementation for a hypothetical PassServiceError:
// impl PassErrorExt for PassServiceError {
//     fn is_no_passes_remaining(&self) -> bool {
//         matches!(self, PassServiceError::NoPassesRemaining)
//     }
// }
```

---

## File: `/Users/jeffrey/code/tether/tether-server/src/state.rs`

Application state shared across handlers:

```rust
//! Application state for Axum handlers.
//!
//! Provides shared access to all services via Arc references.
//! The AppState is cloned into each request handler.

use std::sync::Arc;

use crate::services::{
    bluetooth::BluetoothService,
    config::ConfigService,
    dumbpipe::DumbpipeService,
    pass::PassService,
    system::SystemService,
    wifi::WifiService,
};

/// Shared application state for all handlers.
///
/// Services are wrapped in Arc for thread-safe sharing across
/// async handler tasks.
#[derive(Clone)]
pub struct AppState {
    /// Bluetooth device scanning and RSSI measurement.
    pub bluetooth_service: Arc<BluetoothService>,
    
    /// System configuration management.
    pub config_service: Arc<ConfigService>,
    
    /// Monthly pass tracking and management.
    pub pass_service: Arc<PassService>,
    
    /// WiFi network management.
    pub wifi_service: Arc<WifiService>,
    
    /// Dumbpipe (iroh) remote access management.
    pub dumbpipe_service: Arc<DumbpipeService>,
    
    /// System control (restart, uptime, etc.).
    pub system_service: Arc<SystemService>,
}

impl AppState {
    /// Creates a new AppState with all services initialized.
    pub async fn new() -> Result<Self, Box<dyn std::error::Error>> {
        let config_service = Arc::new(ConfigService::new().await?);
        let bluetooth_service = Arc::new(BluetoothService::new().await?);
        let pass_service = Arc::new(PassService::new(config_service.clone()).await?);
        let wifi_service = Arc::new(WifiService::new().await?);
        let dumbpipe_service = Arc::new(DumbpipeService::new().await?);
        let system_service = Arc::new(SystemService::new());
        
        Ok(Self {
            bluetooth_service,
            config_service,
            pass_service,
            wifi_service,
            dumbpipe_service,
            system_service,
        })
    }
}
```

---

## Summary of Endpoints

| Method | Path | Description | Status Codes |
|--------|------|-------------|--------------|
| GET | `/api/proximity` | Check device proximity | 200, 424, 503 |
| GET | `/api/passes` | Get remaining passes | 200, 500 |
| GET | `/api/passes/history` | Get pass history | 200, 400, 404 |
| POST | `/api/passes/use` | Use a pass | 200, 400, 409 |
| GET | `/api/config` | Get full config | 200 |
| PUT | `/api/config/bluetooth` | Update Bluetooth | 200, 400 |
| PUT | `/api/config/wifi` | Update WiFi | 200, 400, 503 |
| PUT | `/api/config/timezone` | Update timezone | 200, 400 |
| PUT | `/api/config/passes` | Update passes/month | 200, 400 |
| POST | `/api/config/complete-onboarding` | Complete onboarding | 200, 400, 424 |
| GET | `/api/system/status` | Get system status | 200 |
| GET | `/api/system/ticket` | Get dumbpipe ticket | 200, 503 |
| POST | `/api/system/restart` | Restart system | 200, 400 |
| GET | `/api/devices` | Scan for devices | 200, 503 |
| GET | `/api/devices/:address/rssi` | Get device RSSI | 200, 400, 503 |

---

### Critical Files for Implementation

- `/Users/jeffrey/code/tether/tether-server/src/routes/mod.rs` - Router composition and OpenAPI doc structure; entry point for all routes
- `/Users/jeffrey/code/tether/tether-server/src/error.rs` - Unified ApiError type with IntoResponse implementation; used by all handlers
- `/Users/jeffrey/code/tether/tether-server/src/state.rs` - AppState struct with all service dependencies; required extractor for handlers
- `/Users/jeffrey/code/tether/tether-server/src/routes/passes.rs` - Most complex route file with pass history logic and month validation
- `/Users/jeffrey/code/tether/tether-server/src/routes/config.rs` - Configuration endpoints with validation logic and onboarding flow

**Sources:**
- [utoipa GitHub Repository](https://github.com/juhaku/utoipa)
- [utoipa-axum Documentation](https://docs.rs/utoipa-axum)
- [Axum Extractors Documentation](https://docs.rs/axum/latest/axum/extract/index.html)
- [Axum Error Handling Guide](https://nolanbraman.com/axum_chat_app_blog_post/)
