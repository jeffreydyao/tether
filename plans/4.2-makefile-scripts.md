Now I have all the information needed. Let me provide the excruciating implementation details for the Makefile and build scripts.

---

# Excruciating Implementation Details: Makefile and Build Scripts

This document provides complete, copy-paste ready content for the build system of the `tether` project. Each file includes detailed explanations of syntax, error handling, and rationale.

---

## 1. `Makefile` (at repository root: `/Users/jeffrey/code/tether/Makefile`)

```makefile
# =============================================================================
# TETHER - Makefile
# =============================================================================
# Orchestrates all build tasks for the tether project.
# Run `make help` for available targets.
#
# IMPORTANT NOTES FOR CLAUDE CODE INSTANCES:
# - All targets use absolute paths relative to $(PROJECT_ROOT)
# - Cross-compilation requires Docker or native toolchain (see CROSS_COMPILE_METHOD)
# - The OpenAPI spec must be generated BEFORE building web or MCP
# - Pi image building requires Linux with sdm installed (Docker handles this)
# =============================================================================

# -----------------------------------------------------------------------------
# Configuration Variables
# -----------------------------------------------------------------------------

# Project root directory (where this Makefile lives)
PROJECT_ROOT := $(shell pwd)

# Rust configuration
CARGO := cargo
# Using 32-bit target for Pi Zero 2 W (512MB RAM)
RUST_TARGET_PI := armv7-unknown-linux-gnueabihf
# Alternative 64-bit target (not recommended for Pi Zero 2 W):
# RUST_TARGET_PI := aarch64-unknown-linux-gnu

# Build output directories
BUILD_DIR := $(PROJECT_ROOT)/target
DIST_DIR := $(PROJECT_ROOT)/dist
PI_BUILD_DIR := $(DIST_DIR)/pi
WEB_BUILD_DIR := $(PROJECT_ROOT)/web/dist
MCP_BUILD_DIR := $(DIST_DIR)/mcp

# OpenAPI specification paths
OPENAPI_OUTPUT_DIR := $(PROJECT_ROOT)/web/src/client
OPENAPI_SPEC_FILE := $(PROJECT_ROOT)/openapi.json

# Docker configuration for cross-compilation and image building
DOCKER := docker
CROSS_IMAGE := ghcr.io/cross-rs/armv7-unknown-linux-gnueabihf:latest
SDM_IMAGE := tether-sdm-builder:latest

# Cloud Run configuration
GCP_PROJECT := $(shell gcloud config get-value project 2>/dev/null)
GCP_REGION := us-central1
CLOUD_RUN_SERVICE := tether-mcp
ARTIFACT_REGISTRY := $(GCP_REGION)-docker.pkg.dev/$(GCP_PROJECT)/tether

# Cross-compilation method: "cross" (recommended), "docker", or "native"
CROSS_COMPILE_METHOD := cross

# Verbosity: set V=1 for verbose output
V ?= 0
ifeq ($(V),1)
    Q :=
    CARGO_VERBOSE := -v
else
    Q := @
    CARGO_VERBOSE :=
endif

# -----------------------------------------------------------------------------
# Color Output (for terminals that support it)
# -----------------------------------------------------------------------------

# Only use colors if stdout is a terminal
ifneq ($(TERM),)
    COLOR_RESET := \033[0m
    COLOR_GREEN := \033[32m
    COLOR_YELLOW := \033[33m
    COLOR_BLUE := \033[34m
    COLOR_RED := \033[31m
else
    COLOR_RESET :=
    COLOR_GREEN :=
    COLOR_YELLOW :=
    COLOR_BLUE :=
    COLOR_RED :=
endif

# Print a status message
define print_status
	@printf "$(COLOR_BLUE)==>$(COLOR_RESET) $(1)\n"
endef

# Print a success message
define print_success
	@printf "$(COLOR_GREEN)==>$(COLOR_RESET) $(1)\n"
endef

# Print a warning message
define print_warning
	@printf "$(COLOR_YELLOW)==>$(COLOR_RESET) $(1)\n"
endef

# Print an error message
define print_error
	@printf "$(COLOR_RED)==>$(COLOR_RESET) $(1)\n"
endef

# -----------------------------------------------------------------------------
# .PHONY Declarations
# -----------------------------------------------------------------------------
# CRITICAL: All non-file targets MUST be declared .PHONY to:
# 1. Prevent conflicts with files of the same name
# 2. Ensure recipes always run (no caching based on file timestamps)
# 3. Improve make performance by skipping implicit rule search
# -----------------------------------------------------------------------------

.PHONY: all
.PHONY: build-pi build-web build-mcp build-image
.PHONY: deploy-cloud
.PHONY: dev-server dev-web dev
.PHONY: generate-openapi
.PHONY: clean clean-pi clean-web clean-mcp clean-openapi clean-all
.PHONY: check fmt lint test
.PHONY: help
.PHONY: install-deps check-deps
.PHONY: docker-build-sdm

# -----------------------------------------------------------------------------
# Default Target
# -----------------------------------------------------------------------------
# The first target in the Makefile is the default.
# `make` with no arguments will build the full Pi image.
# -----------------------------------------------------------------------------

all: build-image
	$(call print_success,Default target (build-image) completed successfully)

# -----------------------------------------------------------------------------
# Help Target
# -----------------------------------------------------------------------------

help:
	@echo ""
	@echo "TETHER Build System"
	@echo "==================="
	@echo ""
	@echo "Usage: make [target] [V=1]"
	@echo ""
	@echo "Primary Targets:"
	@echo "  all              Build the full Pi image (default)"
	@echo "  build-pi         Cross-compile Rust binaries for Raspberry Pi"
	@echo "  build-web        Build React web application"
	@echo "  build-mcp        Build MCP server for cloud deployment"
	@echo "  build-image      Build complete Raspberry Pi OS image"
	@echo ""
	@echo "Deployment Targets:"
	@echo "  deploy-cloud     Deploy MCP server to Google Cloud Run"
	@echo ""
	@echo "Development Targets:"
	@echo "  dev-server       Run Rust server locally"
	@echo "  dev-web          Run React development server"
	@echo "  dev              Run both dev-server and dev-web (requires tmux)"
	@echo ""
	@echo "Code Generation:"
	@echo "  generate-openapi Export OpenAPI spec and generate TypeScript client"
	@echo ""
	@echo "Quality Targets:"
	@echo "  check            Run cargo check on all crates"
	@echo "  fmt              Format all code (Rust + TypeScript)"
	@echo "  lint             Run all linters (clippy + biome)"
	@echo "  test             Run all tests"
	@echo ""
	@echo "Cleanup Targets:"
	@echo "  clean            Remove primary build artifacts"
	@echo "  clean-all        Remove ALL generated files"
	@echo ""
	@echo "Setup Targets:"
	@echo "  install-deps     Install required development dependencies"
	@echo "  check-deps       Verify all dependencies are available"
	@echo ""
	@echo "Options:"
	@echo "  V=1              Enable verbose output"
	@echo ""

# -----------------------------------------------------------------------------
# Dependency Checking
# -----------------------------------------------------------------------------

check-deps:
	$(call print_status,Checking dependencies...)
	$(Q)command -v cargo >/dev/null 2>&1 || { echo "ERROR: cargo not found. Install Rust from https://rustup.rs"; exit 1; }
	$(Q)command -v bun >/dev/null 2>&1 || { echo "ERROR: bun not found. Install from https://bun.sh"; exit 1; }
	$(Q)command -v docker >/dev/null 2>&1 || { echo "WARNING: docker not found. Required for Pi image building"; }
	$(Q)command -v cross >/dev/null 2>&1 || { echo "WARNING: cross not found. Run: cargo install cross"; }
	$(Q)command -v gcloud >/dev/null 2>&1 || { echo "WARNING: gcloud not found. Required for cloud deployment"; }
	$(call print_success,Dependency check complete)

install-deps:
	$(call print_status,Installing development dependencies...)
	$(Q)rustup target add $(RUST_TARGET_PI)
	$(Q)cargo install cross --git https://github.com/cross-rs/cross
	$(Q)cd $(PROJECT_ROOT)/web && bun install
	$(call print_success,Dependencies installed)

# -----------------------------------------------------------------------------
# OpenAPI Specification Generation
# -----------------------------------------------------------------------------
# CRITICAL: This MUST run before build-web and build-mcp
# The OpenAPI spec is generated by running the Rust binary with a special flag
# Then openapi-ts generates the TypeScript client from the spec
# -----------------------------------------------------------------------------

# Marker file to track when OpenAPI was last generated
OPENAPI_MARKER := $(BUILD_DIR)/.openapi-generated

generate-openapi: $(OPENAPI_MARKER)
	$(call print_success,OpenAPI specification is up to date)

$(OPENAPI_MARKER): $(shell find $(PROJECT_ROOT)/crates -name "*.rs" 2>/dev/null)
	$(call print_status,Generating OpenAPI specification...)
	$(Q)mkdir -p $(BUILD_DIR)
	$(Q)mkdir -p $(OPENAPI_OUTPUT_DIR)
	$(Q)$(PROJECT_ROOT)/scripts/generate-openapi.sh
	$(Q)touch $(OPENAPI_MARKER)
	$(call print_success,OpenAPI spec generated at $(OPENAPI_SPEC_FILE))

# Force regeneration (ignores marker file)
.PHONY: generate-openapi-force
generate-openapi-force:
	$(call print_status,Force regenerating OpenAPI specification...)
	$(Q)rm -f $(OPENAPI_MARKER)
	$(Q)$(MAKE) generate-openapi

# -----------------------------------------------------------------------------
# Raspberry Pi Cross-Compilation
# -----------------------------------------------------------------------------
# Uses the `cross` tool for reliable cross-compilation
# Alternative: Direct Docker-based cross-compilation
# Alternative: Native toolchain (requires arm-linux-gnueabihf-gcc)
# -----------------------------------------------------------------------------

PI_BINARY := $(PI_BUILD_DIR)/tether-server
PI_CRATES := tether-server tether-core

build-pi: $(PI_BINARY)
	$(call print_success,Raspberry Pi binaries built successfully)

$(PI_BINARY): $(shell find $(PROJECT_ROOT)/crates -name "*.rs" 2>/dev/null) $(PROJECT_ROOT)/Cargo.toml
	$(call print_status,Cross-compiling for Raspberry Pi ($(RUST_TARGET_PI))...)
	$(Q)mkdir -p $(PI_BUILD_DIR)
	$(Q)$(PROJECT_ROOT)/scripts/build-pi.sh
	$(call print_success,Binary output: $(PI_BINARY))

# -----------------------------------------------------------------------------
# Web UI Build
# -----------------------------------------------------------------------------
# DEPENDENCY: Requires generate-openapi to run first
# Uses bun for package management and vite for building
# -----------------------------------------------------------------------------

WEB_DIST_MARKER := $(WEB_BUILD_DIR)/.build-complete

build-web: $(WEB_DIST_MARKER)
	$(call print_success,Web UI built successfully)

# The web build depends on:
# 1. OpenAPI generation (for TypeScript client)
# 2. Any changes to web source files
$(WEB_DIST_MARKER): $(OPENAPI_MARKER) $(shell find $(PROJECT_ROOT)/web/src -type f 2>/dev/null) $(PROJECT_ROOT)/web/package.json
	$(call print_status,Building web UI...)
	$(Q)$(PROJECT_ROOT)/scripts/build-web.sh
	$(Q)touch $(WEB_DIST_MARKER)
	$(call print_success,Web UI output: $(WEB_BUILD_DIR))

# -----------------------------------------------------------------------------
# MCP Server Build
# -----------------------------------------------------------------------------
# DEPENDENCY: Requires generate-openapi (for API client in Rust)
# Builds native binary for cloud deployment
# -----------------------------------------------------------------------------

MCP_BINARY := $(MCP_BUILD_DIR)/tether-mcp

build-mcp: $(MCP_BINARY)
	$(call print_success,MCP server built successfully)

$(MCP_BINARY): $(OPENAPI_MARKER) $(shell find $(PROJECT_ROOT)/crates/tether-mcp -name "*.rs" 2>/dev/null)
	$(call print_status,Building MCP server...)
	$(Q)mkdir -p $(MCP_BUILD_DIR)
	$(Q)$(CARGO) build --release --package tether-mcp $(CARGO_VERBOSE)
	$(Q)cp $(BUILD_DIR)/release/tether-mcp $(MCP_BINARY)
	$(call print_success,MCP server output: $(MCP_BINARY))

# -----------------------------------------------------------------------------
# Raspberry Pi Image Build
# -----------------------------------------------------------------------------
# Creates a complete, flashable SD card image with:
# - Raspberry Pi OS Lite (32-bit armhf)
# - Pre-installed tether binaries
# - Configured services (systemd units)
# - Wi-Fi AP mode for initial setup
# 
# DEPENDENCIES: build-pi, build-web (in that order)
# REQUIRES: Linux with sdm installed, OR Docker
# -----------------------------------------------------------------------------

PI_IMAGE := $(DIST_DIR)/tether-pi.img
SDM_CONFIG := $(PROJECT_ROOT)/pi/sdm-config

build-image: $(PI_IMAGE)
	$(call print_success,Raspberry Pi image built: $(PI_IMAGE))
	@echo ""
	@echo "Flash the image to an SD card using:"
	@echo "  sudo dd if=$(PI_IMAGE) of=/dev/sdX bs=4M status=progress"
	@echo "  # OR use Raspberry Pi Imager"
	@echo ""

# Image depends on Pi binaries and web build
$(PI_IMAGE): $(PI_BINARY) $(WEB_DIST_MARKER) $(shell find $(PROJECT_ROOT)/pi -type f 2>/dev/null)
	$(call print_status,Building Raspberry Pi image...)
	$(Q)mkdir -p $(DIST_DIR)
	$(Q)$(PROJECT_ROOT)/scripts/build-image.sh
	$(call print_success,Image created: $(PI_IMAGE))

# Build the Docker image for sdm (if using Docker-based approach)
docker-build-sdm:
	$(call print_status,Building SDM Docker image...)
	$(Q)$(DOCKER) build -t $(SDM_IMAGE) -f $(PROJECT_ROOT)/pi/Dockerfile.sdm $(PROJECT_ROOT)/pi

# -----------------------------------------------------------------------------
# Cloud Deployment
# -----------------------------------------------------------------------------
# Deploys MCP server to Google Cloud Run
# REQUIRES: gcloud CLI authenticated, Docker for building
# -----------------------------------------------------------------------------

MCP_DOCKER_IMAGE := $(ARTIFACT_REGISTRY)/tether-mcp:latest

deploy-cloud: build-mcp
	$(call print_status,Deploying MCP server to Cloud Run...)
ifndef GCP_PROJECT
	$(error GCP_PROJECT is not set. Run: gcloud config set project YOUR_PROJECT)
endif
	$(Q)$(PROJECT_ROOT)/scripts/deploy-cloud.sh
	$(call print_success,Deployment complete!)
	@echo ""
	@gcloud run services describe $(CLOUD_RUN_SERVICE) --region=$(GCP_REGION) --format='value(status.url)'
	@echo ""

# -----------------------------------------------------------------------------
# Development Servers
# -----------------------------------------------------------------------------

# Run the Rust server locally (for development)
dev-server: generate-openapi
	$(call print_status,Starting development server...)
	$(Q)RUST_LOG=debug $(CARGO) run --package tether-server $(CARGO_VERBOSE)

# Run the React development server
dev-web: generate-openapi
	$(call print_status,Starting web development server...)
	$(Q)cd $(PROJECT_ROOT)/web && bun run dev

# Run both servers (requires tmux)
dev: generate-openapi
	$(call print_status,Starting development environment...)
	$(Q)command -v tmux >/dev/null 2>&1 || { echo "ERROR: tmux required for 'make dev'. Use 'make dev-server' and 'make dev-web' separately."; exit 1; }
	$(Q)tmux new-session -d -s tether-dev "$(MAKE) dev-server"
	$(Q)tmux split-window -h "$(MAKE) dev-web"
	$(Q)tmux attach-session -t tether-dev

# -----------------------------------------------------------------------------
# Code Quality
# -----------------------------------------------------------------------------

check:
	$(call print_status,Running cargo check...)
	$(Q)$(CARGO) check --workspace $(CARGO_VERBOSE)
	$(call print_success,Cargo check passed)

fmt:
	$(call print_status,Formatting code...)
	$(Q)$(CARGO) fmt --all
	$(Q)cd $(PROJECT_ROOT)/web && bun run format
	$(call print_success,Formatting complete)

lint:
	$(call print_status,Running linters...)
	$(Q)$(CARGO) clippy --workspace -- -D warnings
	$(Q)cd $(PROJECT_ROOT)/web && bun run lint
	$(call print_success,Linting complete)

test:
	$(call print_status,Running tests...)
	$(Q)$(CARGO) test --workspace $(CARGO_VERBOSE)
	$(Q)cd $(PROJECT_ROOT)/web && bun test
	$(call print_success,All tests passed)

# -----------------------------------------------------------------------------
# Cleanup Targets
# -----------------------------------------------------------------------------

clean:
	$(call print_status,Cleaning build artifacts...)
	$(Q)rm -rf $(DIST_DIR)
	$(Q)rm -rf $(WEB_BUILD_DIR)
	$(Q)rm -f $(OPENAPI_MARKER)
	$(Q)$(CARGO) clean
	$(call print_success,Clean complete)

clean-pi:
	$(call print_status,Cleaning Pi build artifacts...)
	$(Q)rm -rf $(PI_BUILD_DIR)
	$(call print_success,Pi artifacts cleaned)

clean-web:
	$(call print_status,Cleaning web build artifacts...)
	$(Q)rm -rf $(WEB_BUILD_DIR)
	$(Q)rm -rf $(PROJECT_ROOT)/web/node_modules
	$(call print_success,Web artifacts cleaned)

clean-mcp:
	$(call print_status,Cleaning MCP build artifacts...)
	$(Q)rm -rf $(MCP_BUILD_DIR)
	$(call print_success,MCP artifacts cleaned)

clean-openapi:
	$(call print_status,Cleaning OpenAPI artifacts...)
	$(Q)rm -f $(OPENAPI_SPEC_FILE)
	$(Q)rm -rf $(OPENAPI_OUTPUT_DIR)
	$(Q)rm -f $(OPENAPI_MARKER)
	$(call print_success,OpenAPI artifacts cleaned)

clean-all: clean clean-openapi
	$(call print_status,Performing deep clean...)
	$(Q)rm -rf $(PROJECT_ROOT)/web/node_modules
	$(Q)rm -rf $(PROJECT_ROOT)/.bun
	$(Q)$(DOCKER) rmi $(SDM_IMAGE) 2>/dev/null || true
	$(call print_success,Deep clean complete)

# -----------------------------------------------------------------------------
# End of Makefile
# -----------------------------------------------------------------------------
```

---

## 2. `scripts/build-pi.sh` (at `/Users/jeffrey/code/tether/scripts/build-pi.sh`)

```bash
#!/usr/bin/env bash
# =============================================================================
# TETHER - Raspberry Pi Cross-Compilation Script
# =============================================================================
# Cross-compiles the Rust server binary for Raspberry Pi Zero 2 W.
#
# SUPPORTED METHODS:
# 1. cross (recommended) - Uses Docker containers with pre-configured toolchains
# 2. docker - Direct Docker-based compilation
# 3. native - Requires locally installed ARM toolchain
#
# USAGE:
#   ./scripts/build-pi.sh [--method cross|docker|native] [--release|--debug]
#
# ENVIRONMENT VARIABLES:
#   CROSS_COMPILE_METHOD - Override compilation method
#   RUST_TARGET_PI       - Override target triple (default: aarch64-unknown-linux-gnu)
#   CARGO_BUILD_JOBS     - Number of parallel jobs
# =============================================================================

set -euo pipefail

# -----------------------------------------------------------------------------
# Configuration
# -----------------------------------------------------------------------------

# Script directory (for finding project root)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

# Target architecture for Raspberry Pi Zero 2 W (32-bit armhf)
# The Pi Zero 2 W has a Cortex-A53, which supports both armv7 (32-bit) and aarch64 (64-bit)
# We use 32-bit for better memory efficiency on the 512MB RAM device
RUST_TARGET="${RUST_TARGET_PI:-armv7-unknown-linux-gnueabihf}"

# Alternative 64-bit target (not recommended for Pi Zero 2 W due to RAM constraints):
# RUST_TARGET="${RUST_TARGET_PI:-aarch64-unknown-linux-gnu}"

# Compilation method: cross, docker, or native
METHOD="${CROSS_COMPILE_METHOD:-cross}"

# Build profile: release or debug
PROFILE="release"

# Output directory
OUTPUT_DIR="${PROJECT_ROOT}/dist/pi"

# Packages to build
PACKAGES=("tether-server")

# Docker cross-compilation image
CROSS_DOCKER_IMAGE="ghcr.io/cross-rs/${RUST_TARGET}:latest"

# Native toolchain prefix (for native method)
TOOLCHAIN_PREFIX="arm-linux-gnueabihf"

# -----------------------------------------------------------------------------
# Logging Functions
# -----------------------------------------------------------------------------

log_info() {
    echo -e "\033[34m[INFO]\033[0m $*"
}

log_success() {
    echo -e "\033[32m[SUCCESS]\033[0m $*"
}

log_warning() {
    echo -e "\033[33m[WARNING]\033[0m $*"
}

log_error() {
    echo -e "\033[31m[ERROR]\033[0m $*" >&2
}

die() {
    log_error "$*"
    exit 1
}

# -----------------------------------------------------------------------------
# Argument Parsing
# -----------------------------------------------------------------------------

parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --method)
                METHOD="$2"
                shift 2
                ;;
            --method=*)
                METHOD="${1#*=}"
                shift
                ;;
            --release)
                PROFILE="release"
                shift
                ;;
            --debug)
                PROFILE="debug"
                shift
                ;;
            --target)
                RUST_TARGET="$2"
                shift 2
                ;;
            --target=*)
                RUST_TARGET="${1#*=}"
                shift
                ;;
            --help|-h)
                print_usage
                exit 0
                ;;
            *)
                die "Unknown argument: $1"
                ;;
        esac
    done
}

print_usage() {
    cat <<EOF
Usage: $0 [OPTIONS]

Cross-compile Rust binaries for Raspberry Pi.

Options:
    --method METHOD     Compilation method: cross, docker, or native (default: cross)
    --release          Build in release mode (default)
    --debug            Build in debug mode
    --target TARGET    Override Rust target triple
    -h, --help         Show this help message

Environment Variables:
    CROSS_COMPILE_METHOD  Override compilation method
    RUST_TARGET_PI        Override target triple
    CARGO_BUILD_JOBS      Number of parallel jobs

Examples:
    $0                         # Build using cross (default)
    $0 --method docker         # Build using Docker directly
    $0 --method native         # Build using native toolchain
    $0 --debug                 # Build debug version
EOF
}

# -----------------------------------------------------------------------------
# Pre-flight Checks
# -----------------------------------------------------------------------------

check_dependencies() {
    log_info "Checking dependencies for method: ${METHOD}"
    
    case "${METHOD}" in
        cross)
            if ! command -v cross &>/dev/null; then
                log_warning "cross not found. Attempting to install..."
                cargo install cross --git https://github.com/cross-rs/cross \
                    || die "Failed to install cross. Install manually: cargo install cross"
            fi
            
            if ! command -v docker &>/dev/null; then
                die "Docker is required for cross. Install from https://docs.docker.com/get-docker/"
            fi
            
            # Check Docker is running
            if ! docker info &>/dev/null; then
                die "Docker daemon is not running. Start Docker and try again."
            fi
            ;;
            
        docker)
            if ! command -v docker &>/dev/null; then
                die "Docker is required. Install from https://docs.docker.com/get-docker/"
            fi
            
            if ! docker info &>/dev/null; then
                die "Docker daemon is not running. Start Docker and try again."
            fi
            ;;
            
        native)
            # Check for Rust target
            if ! rustup target list --installed | grep -q "${RUST_TARGET}"; then
                log_info "Adding Rust target: ${RUST_TARGET}"
                rustup target add "${RUST_TARGET}" \
                    || die "Failed to add Rust target: ${RUST_TARGET}"
            fi
            
            # Check for linker
            local linker="${TOOLCHAIN_PREFIX}-gcc"
            if ! command -v "${linker}" &>/dev/null; then
                die "Cross-compiler not found: ${linker}

Install on macOS:
    brew install ${TOOLCHAIN_PREFIX}

Install on Ubuntu/Debian:
    sudo apt-get install gcc-${TOOLCHAIN_PREFIX}

Install on Arch Linux:
    sudo pacman -S arm-linux-gnueabihf-gcc"
            fi
            ;;
            
        *)
            die "Unknown method: ${METHOD}. Use: cross, docker, or native"
            ;;
    esac
    
    log_success "Dependency check passed"
}

# -----------------------------------------------------------------------------
# Build Methods
# -----------------------------------------------------------------------------

# Method 1: Use cross (recommended)
build_with_cross() {
    log_info "Building with cross for target: ${RUST_TARGET}"
    
    local cargo_args=("--target" "${RUST_TARGET}")
    
    if [[ "${PROFILE}" == "release" ]]; then
        cargo_args+=("--release")
    fi
    
    for package in "${PACKAGES[@]}"; do
        log_info "Building package: ${package}"
        cargo_args+=("--package" "${package}")
    done
    
    # Run cross build
    # Cross automatically handles:
    # - Docker container setup
    # - Volume mounts
    # - Cross-compilation toolchain
    # - Linking with correct libc
    (
        cd "${PROJECT_ROOT}"
        cross build "${cargo_args[@]}"
    )
}

# Method 2: Direct Docker-based build
build_with_docker() {
    log_info "Building with Docker for target: ${RUST_TARGET}"
    
    # Pull the cross-compilation image if not present
    if ! docker image inspect "${CROSS_DOCKER_IMAGE}" &>/dev/null; then
        log_info "Pulling cross-compilation image: ${CROSS_DOCKER_IMAGE}"
        docker pull "${CROSS_DOCKER_IMAGE}"
    fi
    
    local cargo_args=("build" "--target" "${RUST_TARGET}")
    
    if [[ "${PROFILE}" == "release" ]]; then
        cargo_args+=("--release")
    fi
    
    for package in "${PACKAGES[@]}"; do
        cargo_args+=("--package" "${package}")
    done
    
    # Run build in Docker container
    docker run --rm \
        -v "${PROJECT_ROOT}":/project:Z \
        -v "${HOME}/.cargo/registry":/root/.cargo/registry:Z \
        -v "${HOME}/.cargo/git":/root/.cargo/git:Z \
        -w /project \
        -e CARGO_HOME=/root/.cargo \
        "${CROSS_DOCKER_IMAGE}" \
        cargo "${cargo_args[@]}"
}

# Method 3: Native toolchain build
build_with_native() {
    log_info "Building with native toolchain for target: ${RUST_TARGET}"
    
    local cargo_args=("--target" "${RUST_TARGET}")
    
    if [[ "${PROFILE}" == "release" ]]; then
        cargo_args+=("--release")
    fi
    
    for package in "${PACKAGES[@]}"; do
        cargo_args+=("--package" "${package}")
    done
    
    # Set up linker configuration
    # This creates/updates .cargo/config.toml with linker settings
    local cargo_config="${PROJECT_ROOT}/.cargo/config.toml"
    mkdir -p "${PROJECT_ROOT}/.cargo"
    
    # Check if config already exists and has correct settings
    if ! grep -q "\[target.${RUST_TARGET}\]" "${cargo_config}" 2>/dev/null; then
        log_info "Configuring linker for ${RUST_TARGET}"
        cat >> "${cargo_config}" <<EOF

[target.${RUST_TARGET}]
linker = "${TOOLCHAIN_PREFIX}-gcc"
EOF
    fi
    
    # Run native build
    (
        cd "${PROJECT_ROOT}"
        cargo build "${cargo_args[@]}"
    )
}

# -----------------------------------------------------------------------------
# Copy Outputs
# -----------------------------------------------------------------------------

copy_binaries() {
    log_info "Copying binaries to output directory: ${OUTPUT_DIR}"
    
    mkdir -p "${OUTPUT_DIR}"
    
    local build_dir="${PROJECT_ROOT}/target/${RUST_TARGET}/${PROFILE}"
    
    for package in "${PACKAGES[@]}"; do
        local binary_name="${package}"
        local source="${build_dir}/${binary_name}"
        local dest="${OUTPUT_DIR}/${binary_name}"
        
        if [[ -f "${source}" ]]; then
            cp "${source}" "${dest}"
            chmod +x "${dest}"
            log_success "Copied: ${dest}"
            
            # Print binary info
            local size
            size=$(du -h "${dest}" | cut -f1)
            log_info "Binary size: ${size}"
            
            # Verify it's the correct architecture
            if command -v file &>/dev/null; then
                local file_info
                file_info=$(file "${dest}")
                log_info "Binary type: ${file_info}"
            fi
        else
            die "Binary not found: ${source}"
        fi
    done
}

# -----------------------------------------------------------------------------
# Strip Binaries (optional, for smaller size)
# -----------------------------------------------------------------------------

strip_binaries() {
    log_info "Stripping binaries for smaller size..."
    
    local strip_cmd
    
    case "${METHOD}" in
        native)
            strip_cmd="${TOOLCHAIN_PREFIX}-strip"
            ;;
        *)
            # For cross/docker, we need to strip inside container or use llvm-strip
            if command -v llvm-strip &>/dev/null; then
                strip_cmd="llvm-strip"
            else
                log_warning "llvm-strip not found. Skipping binary stripping."
                return 0
            fi
            ;;
    esac
    
    for package in "${PACKAGES[@]}"; do
        local binary="${OUTPUT_DIR}/${package}"
        if [[ -f "${binary}" ]]; then
            local before_size
            before_size=$(du -h "${binary}" | cut -f1)
            
            ${strip_cmd} "${binary}" 2>/dev/null || log_warning "Failed to strip ${binary}"
            
            local after_size
            after_size=$(du -h "${binary}" | cut -f1)
            log_info "Stripped ${package}: ${before_size} -> ${after_size}"
        fi
    done
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------

main() {
    parse_args "$@"
    
    log_info "========================================"
    log_info "TETHER - Raspberry Pi Cross-Compilation"
    log_info "========================================"
    log_info "Method:  ${METHOD}"
    log_info "Target:  ${RUST_TARGET}"
    log_info "Profile: ${PROFILE}"
    log_info "Output:  ${OUTPUT_DIR}"
    log_info "========================================"
    
    # Pre-flight checks
    check_dependencies
    
    # Build based on method
    case "${METHOD}" in
        cross)
            build_with_cross
            ;;
        docker)
            build_with_docker
            ;;
        native)
            build_with_native
            ;;
    esac
    
    # Copy binaries to output directory
    copy_binaries
    
    # Strip binaries in release mode
    if [[ "${PROFILE}" == "release" ]]; then
        strip_binaries
    fi
    
    log_success "========================================"
    log_success "Cross-compilation complete!"
    log_success "Binaries available at: ${OUTPUT_DIR}"
    log_success "========================================"
}

main "$@"
```

---

## 3. `scripts/build-web.sh` (at `/Users/jeffrey/code/tether/scripts/build-web.sh`)

```bash
#!/usr/bin/env bash
# =============================================================================
# TETHER - Web UI Build Script
# =============================================================================
# Builds the React web application for production deployment on the Pi.
#
# STEPS:
# 1. Verify OpenAPI spec exists (dependency)
# 2. Generate TypeScript API client from OpenAPI spec
# 3. Install npm dependencies (using bun)
# 4. Run production build
# 5. Optimize output
#
# USAGE:
#   ./scripts/build-web.sh [--skip-client-gen] [--dev]
#
# ENVIRONMENT VARIABLES:
#   OPENAPI_SPEC_FILE  - Path to OpenAPI JSON file
#   WEB_DIR            - Path to web directory
#   NODE_ENV           - Build environment (production/development)
# =============================================================================

set -euo pipefail

# -----------------------------------------------------------------------------
# Configuration
# -----------------------------------------------------------------------------

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

# Web application directory
WEB_DIR="${WEB_DIR:-${PROJECT_ROOT}/web}"

# OpenAPI specification file
OPENAPI_SPEC_FILE="${OPENAPI_SPEC_FILE:-${PROJECT_ROOT}/openapi.json}"

# Generated client output directory
CLIENT_OUTPUT_DIR="${WEB_DIR}/src/client"

# Build output directory
BUILD_OUTPUT_DIR="${WEB_DIR}/dist"

# Build mode
BUILD_MODE="production"

# Skip client generation flag
SKIP_CLIENT_GEN=false

# -----------------------------------------------------------------------------
# Logging Functions
# -----------------------------------------------------------------------------

log_info() {
    echo -e "\033[34m[INFO]\033[0m $*"
}

log_success() {
    echo -e "\033[32m[SUCCESS]\033[0m $*"
}

log_warning() {
    echo -e "\033[33m[WARNING]\033[0m $*"
}

log_error() {
    echo -e "\033[31m[ERROR]\033[0m $*" >&2
}

die() {
    log_error "$*"
    exit 1
}

# -----------------------------------------------------------------------------
# Argument Parsing
# -----------------------------------------------------------------------------

parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --skip-client-gen)
                SKIP_CLIENT_GEN=true
                shift
                ;;
            --dev)
                BUILD_MODE="development"
                shift
                ;;
            --help|-h)
                print_usage
                exit 0
                ;;
            *)
                die "Unknown argument: $1"
                ;;
        esac
    done
}

print_usage() {
    cat <<EOF
Usage: $0 [OPTIONS]

Build the Tether web UI for production.

Options:
    --skip-client-gen  Skip OpenAPI client generation (use existing)
    --dev              Build in development mode
    -h, --help         Show this help message

Environment Variables:
    OPENAPI_SPEC_FILE  Path to OpenAPI JSON file
    WEB_DIR            Path to web directory
    NODE_ENV           Build environment (production/development)

Prerequisites:
    - bun (https://bun.sh)
    - OpenAPI spec generated (run 'make generate-openapi' first)
EOF
}

# -----------------------------------------------------------------------------
# Pre-flight Checks
# -----------------------------------------------------------------------------

check_dependencies() {
    log_info "Checking dependencies..."
    
    # Check for bun
    if ! command -v bun &>/dev/null; then
        die "bun not found. Install from https://bun.sh
        
Run: curl -fsSL https://bun.sh/install | bash"
    fi
    
    # Check bun version
    local bun_version
    bun_version=$(bun --version)
    log_info "Using bun version: ${bun_version}"
    
    # Check web directory exists
    if [[ ! -d "${WEB_DIR}" ]]; then
        die "Web directory not found: ${WEB_DIR}"
    fi
    
    # Check package.json exists
    if [[ ! -f "${WEB_DIR}/package.json" ]]; then
        die "package.json not found in ${WEB_DIR}"
    fi
    
    log_success "Dependency check passed"
}

check_openapi_spec() {
    log_info "Checking OpenAPI specification..."
    
    if [[ ! -f "${OPENAPI_SPEC_FILE}" ]]; then
        die "OpenAPI specification not found: ${OPENAPI_SPEC_FILE}

Run 'make generate-openapi' first to generate the spec."
    fi
    
    # Validate JSON is parseable
    if ! python3 -c "import json; json.load(open('${OPENAPI_SPEC_FILE}'))" 2>/dev/null; then
        if ! jq empty "${OPENAPI_SPEC_FILE}" 2>/dev/null; then
            die "OpenAPI specification is not valid JSON: ${OPENAPI_SPEC_FILE}"
        fi
    fi
    
    log_success "OpenAPI specification found: ${OPENAPI_SPEC_FILE}"
}

# -----------------------------------------------------------------------------
# TypeScript Client Generation
# -----------------------------------------------------------------------------

generate_api_client() {
    if [[ "${SKIP_CLIENT_GEN}" == true ]]; then
        log_warning "Skipping API client generation (--skip-client-gen)"
        return 0
    fi
    
    log_info "Generating TypeScript API client from OpenAPI spec..."
    
    # Create output directory if it doesn't exist
    mkdir -p "${CLIENT_OUTPUT_DIR}"
    
    # Change to web directory for proper package resolution
    (
        cd "${WEB_DIR}"
        
        # Generate client using @hey-api/openapi-ts
        # See: https://heyapi.dev/openapi-ts/get-started
        bunx @hey-api/openapi-ts \
            --input "${OPENAPI_SPEC_FILE}" \
            --output "${CLIENT_OUTPUT_DIR}" \
            --client @hey-api/client-fetch \
            --services \
            --types
    )
    
    # Verify client was generated
    if [[ ! -f "${CLIENT_OUTPUT_DIR}/index.ts" ]]; then
        die "API client generation failed. No index.ts found in ${CLIENT_OUTPUT_DIR}"
    fi
    
    log_success "API client generated at: ${CLIENT_OUTPUT_DIR}"
    
    # List generated files
    log_info "Generated files:"
    ls -la "${CLIENT_OUTPUT_DIR}"
}

# -----------------------------------------------------------------------------
# Install Dependencies
# -----------------------------------------------------------------------------

install_dependencies() {
    log_info "Installing npm dependencies..."
    
    (
        cd "${WEB_DIR}"
        
        # Install dependencies with bun
        # Using --frozen-lockfile in CI to ensure reproducible builds
        if [[ "${CI:-}" == "true" ]]; then
            bun install --frozen-lockfile
        else
            bun install
        fi
    )
    
    log_success "Dependencies installed"
}

# -----------------------------------------------------------------------------
# Type Checking
# -----------------------------------------------------------------------------

run_type_check() {
    log_info "Running TypeScript type checking..."
    
    (
        cd "${WEB_DIR}"
        
        # Run TypeScript compiler in check mode
        if ! bun run tsc --noEmit; then
            die "TypeScript type checking failed"
        fi
    )
    
    log_success "Type checking passed"
}

# -----------------------------------------------------------------------------
# Linting
# -----------------------------------------------------------------------------

run_lint() {
    log_info "Running linter (biome)..."
    
    (
        cd "${WEB_DIR}"
        
        # Run biome check
        if ! bun run lint; then
            log_warning "Linting found issues. Continuing build..."
        fi
    )
}

# -----------------------------------------------------------------------------
# Build
# -----------------------------------------------------------------------------

run_build() {
    log_info "Building web application (mode: ${BUILD_MODE})..."
    
    # Clean previous build
    rm -rf "${BUILD_OUTPUT_DIR}"
    
    (
        cd "${WEB_DIR}"
        
        # Set environment for build
        export NODE_ENV="${BUILD_MODE}"
        
        # Run Vite build
        if [[ "${BUILD_MODE}" == "production" ]]; then
            bun run build
        else
            bun run build -- --mode development
        fi
    )
    
    # Verify build output
    if [[ ! -d "${BUILD_OUTPUT_DIR}" ]]; then
        die "Build failed. Output directory not found: ${BUILD_OUTPUT_DIR}"
    fi
    
    if [[ ! -f "${BUILD_OUTPUT_DIR}/index.html" ]]; then
        die "Build failed. index.html not found in ${BUILD_OUTPUT_DIR}"
    fi
    
    log_success "Build complete: ${BUILD_OUTPUT_DIR}"
}

# -----------------------------------------------------------------------------
# Post-build Optimization
# -----------------------------------------------------------------------------

optimize_build() {
    log_info "Optimizing build output..."
    
    local original_size
    original_size=$(du -sh "${BUILD_OUTPUT_DIR}" | cut -f1)
    
    # Compress with gzip for servers that support pre-compressed files
    find "${BUILD_OUTPUT_DIR}" -type f \( -name "*.js" -o -name "*.css" -o -name "*.html" -o -name "*.svg" \) | while read -r file; do
        gzip -9 -k "${file}" 2>/dev/null || true
    done
    
    # Compress with brotli if available (better compression than gzip)
    if command -v brotli &>/dev/null; then
        find "${BUILD_OUTPUT_DIR}" -type f \( -name "*.js" -o -name "*.css" -o -name "*.html" -o -name "*.svg" \) | while read -r file; do
            brotli -9 -k "${file}" 2>/dev/null || true
        done
    fi
    
    local final_size
    final_size=$(du -sh "${BUILD_OUTPUT_DIR}" | cut -f1)
    
    log_info "Original size: ${original_size}, Final size: ${final_size} (includes compressed versions)"
    log_success "Optimization complete"
}

# -----------------------------------------------------------------------------
# Build Report
# -----------------------------------------------------------------------------

print_build_report() {
    log_info "========================================"
    log_info "Build Report"
    log_info "========================================"
    
    # Count files by type
    local js_count css_count html_count total_count
    js_count=$(find "${BUILD_OUTPUT_DIR}" -name "*.js" -not -name "*.gz" -not -name "*.br" | wc -l | tr -d ' ')
    css_count=$(find "${BUILD_OUTPUT_DIR}" -name "*.css" -not -name "*.gz" -not -name "*.br" | wc -l | tr -d ' ')
    html_count=$(find "${BUILD_OUTPUT_DIR}" -name "*.html" -not -name "*.gz" -not -name "*.br" | wc -l | tr -d ' ')
    total_count=$(find "${BUILD_OUTPUT_DIR}" -type f -not -name "*.gz" -not -name "*.br" | wc -l | tr -d ' ')
    
    log_info "Files generated:"
    log_info "  - JavaScript: ${js_count}"
    log_info "  - CSS: ${css_count}"
    log_info "  - HTML: ${html_count}"
    log_info "  - Total: ${total_count}"
    
    # Show largest files
    log_info ""
    log_info "Largest files:"
    find "${BUILD_OUTPUT_DIR}" -type f -not -name "*.gz" -not -name "*.br" -exec du -h {} \; | sort -rh | head -5
    
    log_info "========================================"
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------

main() {
    parse_args "$@"
    
    log_info "========================================"
    log_info "TETHER - Web UI Build"
    log_info "========================================"
    log_info "Web directory: ${WEB_DIR}"
    log_info "Build mode:    ${BUILD_MODE}"
    log_info "Output:        ${BUILD_OUTPUT_DIR}"
    log_info "========================================"
    
    # Pre-flight checks
    check_dependencies
    check_openapi_spec
    
    # Generate API client from OpenAPI spec
    generate_api_client
    
    # Install dependencies
    install_dependencies
    
    # Type checking
    run_type_check
    
    # Linting (non-blocking)
    run_lint
    
    # Build
    run_build
    
    # Optimize (compression)
    if [[ "${BUILD_MODE}" == "production" ]]; then
        optimize_build
    fi
    
    # Print report
    print_build_report
    
    log_success "========================================"
    log_success "Web UI build complete!"
    log_success "Output: ${BUILD_OUTPUT_DIR}"
    log_success "========================================"
}

main "$@"
```

---

## 4. `scripts/generate-openapi.sh` (at `/Users/jeffrey/code/tether/scripts/generate-openapi.sh`)

```bash
#!/usr/bin/env bash
# =============================================================================
# TETHER - OpenAPI Specification Generator
# =============================================================================
# Generates OpenAPI specification from the Rust server code using utoipa.
#
# MECHANISM:
# The Rust binary has a special mode that exports the OpenAPI spec to stdout.
# This script runs the binary with the appropriate flag and captures the output.
#
# USAGE:
#   ./scripts/generate-openapi.sh [--output PATH] [--format json|yaml]
#
# ENVIRONMENT VARIABLES:
#   OPENAPI_OUTPUT_FILE  - Path to output OpenAPI spec
#   CLIENT_OUTPUT_DIR    - Path to generated TypeScript client
# =============================================================================

set -euo pipefail

# -----------------------------------------------------------------------------
# Configuration
# -----------------------------------------------------------------------------

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

# Output file for OpenAPI specification
OPENAPI_OUTPUT_FILE="${OPENAPI_OUTPUT_FILE:-${PROJECT_ROOT}/openapi.json}"

# TypeScript client output directory
CLIENT_OUTPUT_DIR="${CLIENT_OUTPUT_DIR:-${PROJECT_ROOT}/web/src/client}"

# Output format: json or yaml
OUTPUT_FORMAT="json"

# Rust package that exports OpenAPI spec
OPENAPI_PACKAGE="tether-server"

# Cargo build profile for running the exporter
CARGO_PROFILE="dev"

# -----------------------------------------------------------------------------
# Logging Functions
# -----------------------------------------------------------------------------

log_info() {
    echo -e "\033[34m[INFO]\033[0m $*"
}

log_success() {
    echo -e "\033[32m[SUCCESS]\033[0m $*"
}

log_warning() {
    echo -e "\033[33m[WARNING]\033[0m $*"
}

log_error() {
    echo -e "\033[31m[ERROR]\033[0m $*" >&2
}

die() {
    log_error "$*"
    exit 1
}

# -----------------------------------------------------------------------------
# Argument Parsing
# -----------------------------------------------------------------------------

parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --output|-o)
                OPENAPI_OUTPUT_FILE="$2"
                shift 2
                ;;
            --output=*)
                OPENAPI_OUTPUT_FILE="${1#*=}"
                shift
                ;;
            --format|-f)
                OUTPUT_FORMAT="$2"
                shift 2
                ;;
            --format=*)
                OUTPUT_FORMAT="${1#*=}"
                shift
                ;;
            --client-dir)
                CLIENT_OUTPUT_DIR="$2"
                shift 2
                ;;
            --client-dir=*)
                CLIENT_OUTPUT_DIR="${1#*=}"
                shift
                ;;
            --help|-h)
                print_usage
                exit 0
                ;;
            *)
                die "Unknown argument: $1"
                ;;
        esac
    done
}

print_usage() {
    cat <<EOF
Usage: $0 [OPTIONS]

Generate OpenAPI specification from Rust code.

Options:
    -o, --output PATH       Output file path (default: openapi.json)
    -f, --format FORMAT     Output format: json or yaml (default: json)
    --client-dir PATH       TypeScript client output directory
    -h, --help              Show this help message

Environment Variables:
    OPENAPI_OUTPUT_FILE  Path to output OpenAPI spec
    CLIENT_OUTPUT_DIR    Path to generated TypeScript client

The OpenAPI spec is extracted from the Rust code using utoipa annotations.
The binary is run with --export-openapi flag to output the spec to stdout.
EOF
}

# -----------------------------------------------------------------------------
# Pre-flight Checks
# -----------------------------------------------------------------------------

check_dependencies() {
    log_info "Checking dependencies..."
    
    # Check Rust/Cargo
    if ! command -v cargo &>/dev/null; then
        die "cargo not found. Install Rust from https://rustup.rs"
    fi
    
    # Check project has the required package
    if ! grep -q "name = \"${OPENAPI_PACKAGE}\"" "${PROJECT_ROOT}/Cargo.toml" 2>/dev/null; then
        # Check in workspace members
        if [[ ! -d "${PROJECT_ROOT}/crates/${OPENAPI_PACKAGE}" ]]; then
            die "Package '${OPENAPI_PACKAGE}' not found in project"
        fi
    fi
    
    log_success "Dependencies check passed"
}

# -----------------------------------------------------------------------------
# Build OpenAPI Exporter
# -----------------------------------------------------------------------------

build_exporter() {
    log_info "Building OpenAPI exporter..."
    
    (
        cd "${PROJECT_ROOT}"
        
        # Build the package with the openapi-export feature
        # This compiles the code needed to generate the OpenAPI spec
        cargo build --package "${OPENAPI_PACKAGE}" --features openapi-export 2>&1 \
            || cargo build --package "${OPENAPI_PACKAGE}" 2>&1
    )
    
    log_success "Exporter built successfully"
}

# -----------------------------------------------------------------------------
# Generate OpenAPI Specification
# -----------------------------------------------------------------------------

generate_openapi() {
    log_info "Generating OpenAPI specification..."
    
    # Create output directory if it doesn't exist
    mkdir -p "$(dirname "${OPENAPI_OUTPUT_FILE}")"
    
    # Temporary file for output
    local temp_file
    temp_file=$(mktemp)
    
    # Cleanup on exit
    trap "rm -f ${temp_file}" EXIT
    
    (
        cd "${PROJECT_ROOT}"
        
        # Method 1: Run the binary with --export-openapi flag
        # The binary should detect this flag and output OpenAPI JSON to stdout, then exit
        if cargo run --package "${OPENAPI_PACKAGE}" -- --export-openapi > "${temp_file}" 2>/dev/null; then
            log_info "Generated via --export-openapi flag"
        # Method 2: Use a dedicated binary target for OpenAPI export
        elif cargo run --package "${OPENAPI_PACKAGE}" --bin openapi-export > "${temp_file}" 2>/dev/null; then
            log_info "Generated via openapi-export binary"
        # Method 3: Use a cargo run with environment variable
        elif TETHER_EXPORT_OPENAPI=1 cargo run --package "${OPENAPI_PACKAGE}" > "${temp_file}" 2>/dev/null; then
            log_info "Generated via TETHER_EXPORT_OPENAPI environment variable"
        else
            # Fallback: Try to extract from the running server
            log_warning "Direct export failed. Trying to extract from server..."
            
            # Start server in background
            local server_pid
            cargo run --package "${OPENAPI_PACKAGE}" &
            server_pid=$!
            
            # Wait for server to start
            sleep 3
            
            # Try to fetch OpenAPI spec from server
            if curl -s "http://localhost:3000/api/openapi.json" > "${temp_file}" 2>/dev/null; then
                log_info "Generated via HTTP endpoint"
            elif curl -s "http://localhost:8080/api/openapi.json" > "${temp_file}" 2>/dev/null; then
                log_info "Generated via HTTP endpoint (port 8080)"
            else
                # Kill server and fail
                kill "${server_pid}" 2>/dev/null || true
                die "Failed to generate OpenAPI specification. 

Ensure your Rust code has one of:
1. --export-openapi CLI flag handling
2. openapi-export binary target  
3. TETHER_EXPORT_OPENAPI env var handling
4. /api/openapi.json HTTP endpoint"
            fi
            
            # Kill server
            kill "${server_pid}" 2>/dev/null || true
        fi
    )
    
    # Validate the output is valid JSON
    if ! python3 -c "import json; json.load(open('${temp_file}'))" 2>/dev/null; then
        if ! jq empty "${temp_file}" 2>/dev/null; then
            log_error "Generated file is not valid JSON"
            log_error "Content preview:"
            head -20 "${temp_file}" >&2
            die "OpenAPI generation produced invalid JSON"
        fi
    fi
    
    # Validate it looks like an OpenAPI spec
    if ! grep -q '"openapi"' "${temp_file}" && ! grep -q '"swagger"' "${temp_file}"; then
        log_error "Generated file does not appear to be an OpenAPI spec"
        log_error "Content preview:"
        head -20 "${temp_file}" >&2
        die "Output does not contain 'openapi' or 'swagger' field"
    fi
    
    # Convert to YAML if requested
    if [[ "${OUTPUT_FORMAT}" == "yaml" ]]; then
        log_info "Converting to YAML format..."
        if command -v yq &>/dev/null; then
            yq -P "${temp_file}" > "${OPENAPI_OUTPUT_FILE}"
        elif command -v python3 &>/dev/null; then
            python3 -c "
import json
import yaml
with open('${temp_file}') as f:
    data = json.load(f)
with open('${OPENAPI_OUTPUT_FILE}', 'w') as f:
    yaml.dump(data, f, default_flow_style=False, allow_unicode=True)
"
        else
            die "YAML conversion requested but neither yq nor python3+pyyaml available"
        fi
    else
        # Pretty-print JSON
        if command -v jq &>/dev/null; then
            jq '.' "${temp_file}" > "${OPENAPI_OUTPUT_FILE}"
        elif command -v python3 &>/dev/null; then
            python3 -c "
import json
with open('${temp_file}') as f:
    data = json.load(f)
with open('${OPENAPI_OUTPUT_FILE}', 'w') as f:
    json.dump(data, f, indent=2)
"
        else
            cp "${temp_file}" "${OPENAPI_OUTPUT_FILE}"
        fi
    fi
    
    log_success "OpenAPI spec written to: ${OPENAPI_OUTPUT_FILE}"
}

# -----------------------------------------------------------------------------
# Generate TypeScript Client
# -----------------------------------------------------------------------------

generate_typescript_client() {
    log_info "Generating TypeScript client from OpenAPI spec..."
    
    # Check if web directory exists (might be building MCP only)
    if [[ ! -d "${PROJECT_ROOT}/web" ]]; then
        log_warning "Web directory not found. Skipping TypeScript client generation."
        return 0
    fi
    
    # Check for bun
    if ! command -v bun &>/dev/null; then
        log_warning "bun not found. Skipping TypeScript client generation."
        log_warning "Install bun and run 'bunx @hey-api/openapi-ts' manually"
        return 0
    fi
    
    # Create client output directory
    mkdir -p "${CLIENT_OUTPUT_DIR}"
    
    (
        cd "${PROJECT_ROOT}/web"
        
        # Generate TypeScript client using @hey-api/openapi-ts
        # See: https://heyapi.dev/openapi-ts/get-started
        bunx @hey-api/openapi-ts \
            --input "${OPENAPI_OUTPUT_FILE}" \
            --output "${CLIENT_OUTPUT_DIR}" \
            --client @hey-api/client-fetch \
            --services \
            --types
    )
    
    # Verify generation succeeded
    if [[ -f "${CLIENT_OUTPUT_DIR}/index.ts" ]]; then
        log_success "TypeScript client generated at: ${CLIENT_OUTPUT_DIR}"
    else
        log_warning "TypeScript client generation may have failed. Check ${CLIENT_OUTPUT_DIR}"
    fi
}

# -----------------------------------------------------------------------------
# Print OpenAPI Info
# -----------------------------------------------------------------------------

print_openapi_info() {
    log_info "========================================"
    log_info "OpenAPI Specification Info"
    log_info "========================================"
    
    local title version paths
    
    if command -v jq &>/dev/null; then
        title=$(jq -r '.info.title // "Unknown"' "${OPENAPI_OUTPUT_FILE}")
        version=$(jq -r '.info.version // "Unknown"' "${OPENAPI_OUTPUT_FILE}")
        paths=$(jq -r '.paths | keys | length' "${OPENAPI_OUTPUT_FILE}")
    elif command -v python3 &>/dev/null; then
        title=$(python3 -c "import json; d=json.load(open('${OPENAPI_OUTPUT_FILE}')); print(d.get('info',{}).get('title','Unknown'))")
        version=$(python3 -c "import json; d=json.load(open('${OPENAPI_OUTPUT_FILE}')); print(d.get('info',{}).get('version','Unknown'))")
        paths=$(python3 -c "import json; d=json.load(open('${OPENAPI_OUTPUT_FILE}')); print(len(d.get('paths',{})))")
    else
        title="(jq/python3 required to parse)"
        version="(jq/python3 required to parse)"
        paths="(jq/python3 required to parse)"
    fi
    
    log_info "Title:      ${title}"
    log_info "Version:    ${version}"
    log_info "Endpoints:  ${paths}"
    log_info "Output:     ${OPENAPI_OUTPUT_FILE}"
    log_info "Client:     ${CLIENT_OUTPUT_DIR}"
    log_info "========================================"
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------

main() {
    parse_args "$@"
    
    log_info "========================================"
    log_info "TETHER - OpenAPI Generator"
    log_info "========================================"
    
    # Pre-flight checks
    check_dependencies
    
    # Build the exporter
    build_exporter
    
    # Generate OpenAPI spec
    generate_openapi
    
    # Generate TypeScript client
    generate_typescript_client
    
    # Print info
    print_openapi_info
    
    log_success "========================================"
    log_success "OpenAPI generation complete!"
    log_success "========================================"
}

main "$@"
```

---

## 5. `.env.example` (at `/Users/jeffrey/code/tether/.env.example`)

```bash
# =============================================================================
# TETHER - Environment Variables
# =============================================================================
# Copy this file to .env and modify as needed:
#   cp .env.example .env
#
# IMPORTANT: Never commit .env to version control!
# =============================================================================

# -----------------------------------------------------------------------------
# Rust Server Configuration
# -----------------------------------------------------------------------------

# Path to tether configuration file
# Default: /etc/tether/config.toml (on Pi), ./config/dev.toml (local dev)
TETHER_CONFIG=./config/dev.toml

# Logging level: error, warn, info, debug, trace
# Format: RUST_LOG=tether_server=debug,tether_core=info
# Use 'debug' for development, 'info' for production
RUST_LOG=debug

# Server bind address
# Default: 0.0.0.0:3000
TETHER_BIND_ADDR=0.0.0.0:3000

# Enable development mode (disables certain production checks)
TETHER_DEV_MODE=true

# -----------------------------------------------------------------------------
# Bluetooth Configuration (Development)
# -----------------------------------------------------------------------------

# Mock Bluetooth for development (no real Bluetooth hardware)
TETHER_MOCK_BLUETOOTH=true

# Simulated Bluetooth device name
TETHER_MOCK_DEVICE_NAME="Mock iPhone"

# Simulated RSSI signal strength (-100 to 0, closer to 0 = stronger)
TETHER_MOCK_DEVICE_RSSI=-45

# -----------------------------------------------------------------------------
# Wi-Fi Configuration (Development)
# -----------------------------------------------------------------------------

# Mock Wi-Fi for development
TETHER_MOCK_WIFI=true

# Skip network connectivity checks in development
TETHER_SKIP_NETWORK_CHECK=true

# -----------------------------------------------------------------------------
# dumbpipe / iroh Configuration
# -----------------------------------------------------------------------------

# Pre-generated dumbpipe ticket (for development/testing)
# Leave empty to generate new ticket on startup
TETHER_DUMBPIPE_TICKET=

# Disable dumbpipe in development (no P2P connectivity)
TETHER_DISABLE_DUMBPIPE=true

# -----------------------------------------------------------------------------
# Data Storage
# -----------------------------------------------------------------------------

# Directory for persistent data (passes, logs, etc.)
# Default: /var/lib/tether (on Pi), ./data (local dev)
TETHER_DATA_DIR=./data

# Log file location
# Default: /var/log/tether/tether.log (on Pi), ./logs/tether.log (local dev)
TETHER_LOG_FILE=./logs/tether.log

# -----------------------------------------------------------------------------
# MCP Server Configuration
# -----------------------------------------------------------------------------

# dumbpipe ticket for connecting to the Raspberry Pi
# REQUIRED for MCP server to function
# Get this from the Pi's web UI after setup
MCP_DUMBPIPE_TICKET=

# Base URL for HTTP API (constructed from dumbpipe connection)
# Usually set automatically, but can be overridden for testing
# MCP_API_BASE_URL=http://localhost:3000

# -----------------------------------------------------------------------------
# Cloud Deployment (MCP Server)
# -----------------------------------------------------------------------------

# Google Cloud Project ID
GCP_PROJECT=your-project-id

# Google Cloud region for Cloud Run
GCP_REGION=us-central1

# Cloud Run service name
CLOUD_RUN_SERVICE=tether-mcp

# Artifact Registry repository
ARTIFACT_REGISTRY=${GCP_REGION}-docker.pkg.dev/${GCP_PROJECT}/tether

# -----------------------------------------------------------------------------
# Development Tools
# -----------------------------------------------------------------------------

# Enable OpenAPI export mode (for generate-openapi script)
# When set, the server outputs OpenAPI JSON to stdout and exits
TETHER_EXPORT_OPENAPI=false

# Web UI development server port
WEB_DEV_PORT=5173

# Enable CORS for local development
TETHER_ENABLE_CORS=true

# CORS allowed origins (comma-separated)
TETHER_CORS_ORIGINS=http://localhost:5173,http://127.0.0.1:5173

# -----------------------------------------------------------------------------
# Testing
# -----------------------------------------------------------------------------

# Use in-memory storage for tests
TETHER_TEST_MODE=false

# Seed data for development (creates sample pass history)
TETHER_SEED_DATA=false
```

---

## 6. `README.md` Outline (at `/Users/jeffrey/code/tether/README.md`)

```markdown
# tether

> Hold yourself accountable to place your phone away from your bedroom at night.

tether is a hardware and software project that uses a Raspberry Pi to track whether your phone is nearby via Bluetooth. It exposes this information via a secure P2P connection, allowing AI assistants (via MCP) to verify your bedtime phone habits.

## Features

- **Bluetooth Proximity Detection**: Checks if your configured phone is near the Raspberry Pi
- **Emergency Passes**: Configurable monthly passes for nights when you need your phone
- **Web-Based Configuration**: Mobile-friendly UI for setup and monitoring
- **Secure Remote Access**: Uses [iroh](https://github.com/n0-computer/iroh) via [dumbpipe](https://github.com/n0-computer/dumbpipe) for secure P2P connectivity
- **MCP Integration**: Query status and manage passes via AI assistants

## Architecture

```

                         Raspberry Pi                            
       
   tether-core tether-server     Web UI (React)       
    (Bluetooth      (axum)        - Configuration         
     + Logic)       HTTP API      - Status Dashboard      
       
                                                                
                                                    
                     dumbpipe    Secure P2P tunnel            
                                                    

                           
                            iroh (P2P)
                           

                    Cloud Run                                    
                                        
                   tether-mcp                                  
                 (MCP Server)          Claude, etc.           
                                        

```

## Prerequisites

### For Development

- [Rust](https://rustup.rs/) (latest stable)
- [Bun](https://bun.sh/) (for web UI)
- [Docker](https://docs.docker.com/get-docker/) (for cross-compilation and Pi image building)

### For Raspberry Pi Image Building

- Linux host (or Docker)
- [sdm](https://github.com/gitbls/sdm) (Raspberry Pi image customization)

### For Cloud Deployment

- [Google Cloud SDK](https://cloud.google.com/sdk/docs/install) (gcloud CLI)
- Google Cloud project with billing enabled

## Quick Start

### 1. Clone and Setup

```bash
git clone https://github.com/yourusername/tether.git
cd tether

# Copy environment file
cp .env.example .env

# Install dependencies
make install-deps
```

### 2. Development

```bash
# Run both Rust server and web UI in development mode
make dev

# Or run them separately:
make dev-server  # Rust server on :3000
make dev-web     # Vite dev server on :5173
```

### 3. Build for Raspberry Pi

```bash
# Build complete SD card image
make build-image

# The image will be at dist/tether-pi.img
```

### 4. Deploy MCP Server

```bash
# Configure your Google Cloud project
gcloud config set project YOUR_PROJECT_ID

# Deploy to Cloud Run
make deploy-cloud
```

## Development Setup

### Project Structure

```
tether/
 Cargo.toml              # Rust workspace configuration
 Makefile                # Build orchestration
 crates/
    tether-core/        # Core business logic (Bluetooth, passes, config)
    tether-server/      # HTTP server (axum) with OpenAPI
    tether-mcp/         # MCP server for cloud deployment
 web/                    # React web UI
    src/
       client/         # Generated TypeScript API client
    package.json
 pi/                     # Raspberry Pi image configuration
    sdm-config/         # sdm customization scripts
    systemd/            # Service unit files
 scripts/                # Build and deployment scripts
    build-pi.sh         # Cross-compilation
    build-web.sh        # Web UI build
    generate-openapi.sh # OpenAPI spec generation
    deploy-cloud.sh     # Cloud Run deployment
 config/                 # Configuration files
     dev.toml            # Development configuration
```

### Make Targets

| Target | Description |
|--------|-------------|
| `make` | Build full Pi image (default) |
| `make build-pi` | Cross-compile Rust for Pi |
| `make build-web` | Build React web UI |
| `make build-mcp` | Build MCP server |
| `make build-image` | Build complete Pi SD image |
| `make deploy-cloud` | Deploy MCP to Cloud Run |
| `make dev-server` | Run Rust server locally |
| `make dev-web` | Run React dev server |
| `make generate-openapi` | Export OpenAPI spec |
| `make clean` | Remove build artifacts |
| `make help` | Show all targets |

### Environment Variables

See `.env.example` for all available configuration options.

Key variables for development:

| Variable | Description | Default |
|----------|-------------|---------|
| `TETHER_CONFIG` | Path to config file | `./config/dev.toml` |
| `RUST_LOG` | Log level | `debug` |
| `TETHER_MOCK_BLUETOOTH` | Mock Bluetooth for dev | `true` |
| `TETHER_MOCK_WIFI` | Mock Wi-Fi for dev | `true` |

## Building for Raspberry Pi

### Cross-Compilation

The build system uses [cross](https://github.com/cross-rs/cross) for reliable cross-compilation:

```bash
# Default: uses cross (Docker-based)
make build-pi

# Alternative: direct Docker
./scripts/build-pi.sh --method docker

# Alternative: native toolchain (requires arm-linux-gnu-gcc)
./scripts/build-pi.sh --method native
```

### Creating the SD Card Image

The image is built using [sdm](https://github.com/gitbls/sdm), which customizes a Raspberry Pi OS image with:

- Pre-installed tether binaries
- systemd services configured
- Wi-Fi AP mode for initial setup
- All required packages

```bash
# Build the image (requires Linux or Docker)
make build-image

# Flash to SD card
sudo dd if=dist/tether-pi.img of=/dev/sdX bs=4M status=progress
```

## Deployment

### MCP Server to Cloud Run

1. Configure Google Cloud:
   ```bash
   gcloud auth login
   gcloud config set project YOUR_PROJECT_ID
   gcloud services enable run.googleapis.com artifactregistry.googleapis.com
   ```

2. Create Artifact Registry repository:
   ```bash
   gcloud artifacts repositories create tether \
       --repository-format=docker \
       --location=us-central1
   ```

3. Deploy:
   ```bash
   make deploy-cloud
   ```

4. Set the dumbpipe ticket as a secret:
   ```bash
   # After setting up your Pi, get the ticket from the web UI
   gcloud run services update tether-mcp \
       --set-env-vars="MCP_DUMBPIPE_TICKET=YOUR_TICKET_HERE"
   ```

## API Documentation

The HTTP API is documented using OpenAPI. After running the server:

- **Swagger UI**: http://localhost:3000/api/docs
- **OpenAPI JSON**: http://localhost:3000/api/openapi.json

### Key Endpoints

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/api/proximity` | Check if phone is nearby |
| GET | `/api/passes` | Get remaining passes this month |
| GET | `/api/passes/history` | Get pass usage history |
| POST | `/api/passes/use` | Use a pass (with reason) |
| GET | `/api/ticket` | Get dumbpipe ticket |
| GET | `/api/config` | Get current configuration |
| PUT | `/api/config` | Update configuration |

## Contributing

1. Fork the repository
2. Create a feature branch: `git checkout -b feature/amazing-feature`
3. Make your changes
4. Run tests: `make test`
5. Run lints: `make lint`
6. Commit: `git commit -m 'Add amazing feature'`
7. Push: `git push origin feature/amazing-feature`
8. Open a Pull Request

## License

[MIT License](LICENSE)

## Acknowledgments

- [iroh](https://github.com/n0-computer/iroh) - P2P networking
- [dumbpipe](https://github.com/n0-computer/dumbpipe) - Simple P2P tunnel
- [sdm](https://github.com/gitbls/sdm) - Raspberry Pi image customization
- [axum](https://github.com/tokio-rs/axum) - Web framework
- [utoipa](https://github.com/juhaku/utoipa) - OpenAPI generation
- [shadcn/ui](https://ui.shadcn.com/) - UI components
```

---

## 7. `CLAUDE.md` (at `/Users/jeffrey/code/tether/CLAUDE.md`)

```markdown
# CLAUDE.md - AI Assistant Context for tether

This file provides context for AI assistants (Claude, etc.) working on this codebase.

## Project Overview

**tether** is a Raspberry Pi-based phone proximity tracker that helps users keep their phones away from the bedroom at night. It consists of:

1. **Raspberry Pi Application**: Rust server + React web UI running on a Pi Zero 2 W
2. **MCP Server**: Cloud-deployed service that exposes the Pi's API to AI assistants

## Architecture Summary

```
Raspberry Pi Zero 2 W
 tether-core       # Business logic (Bluetooth, passes, config)
 tether-server     # HTTP API (axum) with OpenAPI via utoipa
 web/              # React + Vite + shadcn/ui
 dumbpipe          # Secure P2P tunnel via iroh

Cloud Run
 tether-mcp        # MCP server (uses rmcp-openapi)
```

## Key Files

| Path | Purpose |
|------|---------|
| `Cargo.toml` | Rust workspace root |
| `crates/tether-core/src/lib.rs` | Core business logic entry |
| `crates/tether-server/src/main.rs` | HTTP server entry point |
| `crates/tether-server/src/api/` | API route handlers |
| `crates/tether-mcp/src/main.rs` | MCP server entry |
| `web/src/App.tsx` | React app entry |
| `web/src/client/` | Generated TypeScript API client |
| `Makefile` | Build orchestration |
| `scripts/` | Build and deployment scripts |
| `pi/sdm-config/` | Raspberry Pi image customization |

## Common Tasks

### Generate OpenAPI spec and TypeScript client
```bash
make generate-openapi
```
This runs `scripts/generate-openapi.sh`, which:
1. Builds and runs the Rust server with `--export-openapi`
2. Writes `openapi.json` to project root
3. Generates TypeScript client in `web/src/client/`

### Build for Raspberry Pi
```bash
make build-pi
```
Cross-compiles using `cross` (Docker-based) to `aarch64-unknown-linux-gnu`.

### Build complete Pi image
```bash
make build-image
```
Creates `dist/tether-pi.img` using sdm.

### Run development servers
```bash
make dev-server  # Rust on :3000
make dev-web     # Vite on :5173
```

## Code Conventions

### Rust
- Use `thiserror` for error types
- Use `tracing` for logging (not `log`)
- OpenAPI: Heavy use of utoipa macros (`#[utoipa::path]`, `#[derive(ToSchema)]`)
- Axum: Use extractors, state, and layers idiomatically
- Config: TOML format, validated with `serde` + custom validation

### TypeScript/React
- Use `bun` as package manager
- Use `biome` for formatting/linting
- Use `@hey-api/openapi-ts` for API client generation
- Use shadcn/ui components exclusively
- Mobile-first: Use `<Drawer>` on mobile, dialogs on desktop

### Make
- All targets are `.PHONY` unless they produce files
- Dependencies are explicitly declared
- Scripts in `scripts/` handle complex logic
- Use `$(Q)` prefix for quietable commands

## Testing

```bash
make test          # All tests (Rust + TypeScript)
make lint          # All linters (clippy + biome)
make check         # Rust type checking only
```

## Environment

Development uses `.env` (copied from `.env.example`). Key variables:

- `RUST_LOG=debug` - Logging level
- `TETHER_MOCK_BLUETOOTH=true` - Mock Bluetooth for dev
- `TETHER_CONFIG=./config/dev.toml` - Config file path

## Common Issues

### OpenAPI generation fails
1. Ensure `--export-openapi` flag is handled in `main.rs`
2. Check that `utoipa` features are enabled in `Cargo.toml`
3. Try `make generate-openapi-force` to regenerate

### Cross-compilation fails
1. Ensure Docker is running
2. Try `./scripts/build-pi.sh --method docker` explicitly
3. Check `~/.cargo/config.toml` for conflicting linker settings

### Web build fails
1. Run `cd web && bun install` to ensure dependencies
2. Ensure OpenAPI client is generated: `make generate-openapi`
3. Check `web/src/client/` exists and has `index.ts`

### MCP server can't connect
1. Verify `MCP_DUMBPIPE_TICKET` environment variable is set
2. Check the Pi is online and dumbpipe is running
3. Test with `dumbpipe connect <ticket>` locally

## Adding New API Endpoints

1. Add handler in `crates/tether-server/src/api/`
2. Add utoipa annotations (`#[utoipa::path]`, schemas)
3. Register in router (`src/api/mod.rs`)
4. Run `make generate-openapi` to update TypeScript client
5. Use generated client in `web/src/client/` in React components

## Build Dependencies Graph

```
generate-openapi
       
   build-web 
                   
   build-pi 
                   
  build-image 
       
   build-mcp  generate-openapi
       
  deploy-cloud
```

## Useful Commands

```bash
# Check what make will do without running
make -n build-image

# Verbose output
make V=1 build-pi

# Clean and rebuild everything
make clean-all && make build-image

# Just regenerate TypeScript client (skip Rust rebuild)
cd web && bunx @hey-api/openapi-ts -i ../openapi.json -o src/client
```
```

---

## Additional Script: `scripts/build-image.sh`

For completeness, here is the Pi image building script:

```bash
#!/usr/bin/env bash
# =============================================================================
# TETHER - Raspberry Pi Image Builder
# =============================================================================
# Creates a complete, flashable SD card image using sdm.
#
# PREREQUISITES:
# - Linux host (or Docker with privileged access)
# - sdm installed: https://github.com/gitbls/sdm
# - Base Raspberry Pi OS image downloaded
#
# USAGE:
#   ./scripts/build-image.sh [--base-image PATH] [--output PATH]
#
# =============================================================================

set -euo pipefail

# -----------------------------------------------------------------------------
# Configuration
# -----------------------------------------------------------------------------

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

# Output image path
OUTPUT_IMAGE="${PROJECT_ROOT}/dist/tether-pi.img"

# Base Raspberry Pi OS image (64-bit Lite)
BASE_IMAGE_URL="https://downloads.raspberrypi.com/raspios_lite_arm64/images/raspios_lite_arm64-2024-03-15/2024-03-15-raspios-bookworm-arm64-lite.img.xz"
BASE_IMAGE_DIR="${PROJECT_ROOT}/.cache/pi-images"
BASE_IMAGE="${BASE_IMAGE_DIR}/raspios-bookworm-arm64-lite.img"

# Built artifacts
PI_BINARY="${PROJECT_ROOT}/dist/pi/tether-server"
WEB_DIST="${PROJECT_ROOT}/web/dist"

# sdm configuration directory
SDM_CONFIG_DIR="${PROJECT_ROOT}/pi/sdm-config"

# Docker image for sdm (if not running on Linux)
SDM_DOCKER_IMAGE="tether-sdm-builder:latest"

# Hostname for the Pi
PI_HOSTNAME="tether"

# Default user credentials
PI_USER="tether"
PI_PASSWORD="tether"  # User should change this

# -----------------------------------------------------------------------------
# Logging Functions
# -----------------------------------------------------------------------------

log_info() {
    echo -e "\033[34m[INFO]\033[0m $*"
}

log_success() {
    echo -e "\033[32m[SUCCESS]\033[0m $*"
}

log_warning() {
    echo -e "\033[33m[WARNING]\033[0m $*"
}

log_error() {
    echo -e "\033[31m[ERROR]\033[0m $*" >&2
}

die() {
    log_error "$*"
    exit 1
}

# -----------------------------------------------------------------------------
# Pre-flight Checks
# -----------------------------------------------------------------------------

check_dependencies() {
    log_info "Checking dependencies..."
    
    # Check if running on Linux or if Docker is available
    if [[ "$(uname)" != "Linux" ]]; then
        log_warning "Not running on Linux. Will use Docker."
        
        if ! command -v docker &>/dev/null; then
            die "Docker required on non-Linux systems"
        fi
        
        USE_DOCKER=true
    else
        USE_DOCKER=false
        
        # Check for sdm
        if ! command -v sdm &>/dev/null; then
            die "sdm not found. Install from: https://github.com/gitbls/sdm"
        fi
    fi
    
    # Check built artifacts exist
    if [[ ! -f "${PI_BINARY}" ]]; then
        die "Pi binary not found: ${PI_BINARY}
Run 'make build-pi' first."
    fi
    
    if [[ ! -d "${WEB_DIST}" ]]; then
        die "Web dist not found: ${WEB_DIST}
Run 'make build-web' first."
    fi
    
    log_success "Dependency check passed"
}

# -----------------------------------------------------------------------------
# Download Base Image
# -----------------------------------------------------------------------------

download_base_image() {
    if [[ -f "${BASE_IMAGE}" ]]; then
        log_info "Base image already exists: ${BASE_IMAGE}"
        return 0
    fi
    
    log_info "Downloading Raspberry Pi OS base image..."
    
    mkdir -p "${BASE_IMAGE_DIR}"
    
    local compressed_image="${BASE_IMAGE}.xz"
    
    # Download
    curl -L -o "${compressed_image}" "${BASE_IMAGE_URL}"
    
    # Decompress
    log_info "Decompressing image..."
    xz -d "${compressed_image}"
    
    log_success "Base image downloaded: ${BASE_IMAGE}"
}

# -----------------------------------------------------------------------------
# Create sdm Configuration
# -----------------------------------------------------------------------------

create_sdm_config() {
    log_info "Creating sdm configuration..."
    
    mkdir -p "${SDM_CONFIG_DIR}"
    
    # Create first-boot script
    cat > "${SDM_CONFIG_DIR}/01-tether-install.sh" <<'SCRIPT'
#!/bin/bash
# Tether installation script - runs during sdm customization

# Install required packages
apt-get update
apt-get install -y \
    bluez \
    bluetooth \
    libbluetooth-dev \
    hostapd \
    dnsmasq \
    nginx-light

# Create tether user if not exists
if ! id -u tether &>/dev/null; then
    useradd -m -s /bin/bash tether
    echo "tether:tether" | chpasswd
    usermod -aG sudo,bluetooth tether
fi

# Create directories
mkdir -p /opt/tether/bin
mkdir -p /opt/tether/web
mkdir -p /var/lib/tether
mkdir -p /var/log/tether
mkdir -p /etc/tether

# Set permissions
chown -R tether:tether /opt/tether
chown -R tether:tether /var/lib/tether
chown -R tether:tether /var/log/tether
chown -R tether:tether /etc/tether

echo "Tether installation complete"
SCRIPT

    chmod +x "${SDM_CONFIG_DIR}/01-tether-install.sh"
    
    # Create systemd service file
    cat > "${SDM_CONFIG_DIR}/tether.service" <<'SERVICE'
[Unit]
Description=Tether Server
After=network.target bluetooth.target
Wants=bluetooth.target

[Service]
Type=simple
User=tether
Group=tether
Environment="RUST_LOG=info"
Environment="TETHER_CONFIG=/etc/tether/config.toml"
ExecStart=/opt/tether/bin/tether-server
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
SERVICE

    log_success "sdm configuration created"
}

# -----------------------------------------------------------------------------
# Build Image with sdm
# -----------------------------------------------------------------------------

build_with_sdm() {
    log_info "Building image with sdm..."
    
    # Copy base image to work on
    mkdir -p "$(dirname "${OUTPUT_IMAGE}")"
    cp "${BASE_IMAGE}" "${OUTPUT_IMAGE}"
    
    # Run sdm customize
    sudo sdm --customize "${OUTPUT_IMAGE}" \
        --hostname "${PI_HOSTNAME}" \
        --user "${PI_USER}" \
        --password "${PI_PASSWORD}" \
        --locale "en_US.UTF-8" \
        --timezone "UTC" \
        --ssh service \
        --extend 1024 \
        --script "${SDM_CONFIG_DIR}/01-tether-install.sh"
    
    # Copy binaries into image
    sudo sdm --mount "${OUTPUT_IMAGE}"
    
    # Copy tether binary
    sudo cp "${PI_BINARY}" /mnt/sdm/opt/tether/bin/
    sudo chmod +x /mnt/sdm/opt/tether/bin/tether-server
    
    # Copy web dist
    sudo cp -r "${WEB_DIST}"/* /mnt/sdm/opt/tether/web/
    
    # Copy systemd service
    sudo cp "${SDM_CONFIG_DIR}/tether.service" /mnt/sdm/etc/systemd/system/
    sudo ln -sf /etc/systemd/system/tether.service /mnt/sdm/etc/systemd/system/multi-user.target.wants/
    
    # Create default config
    sudo tee /mnt/sdm/etc/tether/config.toml > /dev/null <<'CONFIG'
# Tether Configuration
# This file is created on first boot - modify as needed

[server]
bind_address = "0.0.0.0:3000"
web_root = "/opt/tether/web"

[bluetooth]
# Configured via web UI on first boot
target_device = ""
rssi_threshold = -70

[passes]
monthly_allowance = 3

[storage]
data_dir = "/var/lib/tether"
log_file = "/var/log/tether/tether.log"
CONFIG

    sudo sdm --unmount "${OUTPUT_IMAGE}"
    
    log_success "Image built: ${OUTPUT_IMAGE}"
}

# -----------------------------------------------------------------------------
# Build with Docker (for non-Linux hosts)
# -----------------------------------------------------------------------------

build_with_docker() {
    log_info "Building image using Docker..."
    
    # Build Docker image for sdm if not exists
    if ! docker image inspect "${SDM_DOCKER_IMAGE}" &>/dev/null; then
        log_info "Building sdm Docker image..."
        docker build -t "${SDM_DOCKER_IMAGE}" -f "${PROJECT_ROOT}/pi/Dockerfile.sdm" "${PROJECT_ROOT}/pi"
    fi
    
    mkdir -p "$(dirname "${OUTPUT_IMAGE}")"
    
    # Run sdm in Docker
    docker run --rm --privileged \
        -v "${PROJECT_ROOT}:/project" \
        -v "${BASE_IMAGE_DIR}:/cache" \
        -v "$(dirname "${OUTPUT_IMAGE}"):/output" \
        "${SDM_DOCKER_IMAGE}" \
        /project/scripts/build-image.sh --in-docker
    
    log_success "Image built: ${OUTPUT_IMAGE}"
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------

main() {
    # Check if running inside Docker
    if [[ "${1:-}" == "--in-docker" ]]; then
        # We're inside Docker, run sdm directly
        build_with_sdm
        exit 0
    fi
    
    log_info "========================================"
    log_info "TETHER - Raspberry Pi Image Builder"
    log_info "========================================"
    
    check_dependencies
    download_base_image
    create_sdm_config
    
    if [[ "${USE_DOCKER:-false}" == true ]]; then
        build_with_docker
    else
        build_with_sdm
    fi
    
    # Print image info
    local image_size
    image_size=$(du -h "${OUTPUT_IMAGE}" | cut -f1)
    
    log_success "========================================"
    log_success "Image build complete!"
    log_success "========================================"
    log_info "Output:   ${OUTPUT_IMAGE}"
    log_info "Size:     ${image_size}"
    log_info ""
    log_info "Flash to SD card:"
    log_info "  sudo dd if=${OUTPUT_IMAGE} of=/dev/sdX bs=4M status=progress"
    log_info ""
    log_info "Or use Raspberry Pi Imager"
    log_success "========================================"
}

main "$@"
```

---

## Additional Script: `scripts/deploy-cloud.sh`

```bash
#!/usr/bin/env bash
# =============================================================================
# TETHER - Cloud Run Deployment Script
# =============================================================================
# Deploys the MCP server to Google Cloud Run.
#
# PREREQUISITES:
# - gcloud CLI authenticated
# - Artifact Registry repository created
# - Cloud Run API enabled
#
# USAGE:
#   ./scripts/deploy-cloud.sh [--project PROJECT_ID] [--region REGION]
#
# =============================================================================

set -euo pipefail

# -----------------------------------------------------------------------------
# Configuration
# -----------------------------------------------------------------------------

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

# Google Cloud configuration
GCP_PROJECT="${GCP_PROJECT:-$(gcloud config get-value project 2>/dev/null || echo "")}"
GCP_REGION="${GCP_REGION:-us-central1}"
SERVICE_NAME="${CLOUD_RUN_SERVICE:-tether-mcp}"

# Artifact Registry
REGISTRY="${GCP_REGION}-docker.pkg.dev/${GCP_PROJECT}/tether"
IMAGE_NAME="${REGISTRY}/tether-mcp"
IMAGE_TAG="${IMAGE_TAG:-latest}"

# Docker build
DOCKERFILE="${PROJECT_ROOT}/crates/tether-mcp/Dockerfile"

# -----------------------------------------------------------------------------
# Logging Functions
# -----------------------------------------------------------------------------

log_info() {
    echo -e "\033[34m[INFO]\033[0m $*"
}

log_success() {
    echo -e "\033[32m[SUCCESS]\033[0m $*"
}

log_warning() {
    echo -e "\033[33m[WARNING]\033[0m $*"
}

log_error() {
    echo -e "\033[31m[ERROR]\033[0m $*" >&2
}

die() {
    log_error "$*"
    exit 1
}

# -----------------------------------------------------------------------------
# Pre-flight Checks
# -----------------------------------------------------------------------------

check_dependencies() {
    log_info "Checking dependencies..."
    
    if ! command -v gcloud &>/dev/null; then
        die "gcloud CLI not found. Install from: https://cloud.google.com/sdk/docs/install"
    fi
    
    if ! command -v docker &>/dev/null; then
        die "Docker not found. Install from: https://docs.docker.com/get-docker/"
    fi
    
    if [[ -z "${GCP_PROJECT}" ]]; then
        die "GCP_PROJECT not set. Run: gcloud config set project YOUR_PROJECT"
    fi
    
    # Check authentication
    if ! gcloud auth print-access-token &>/dev/null; then
        die "Not authenticated. Run: gcloud auth login"
    fi
    
    log_success "Dependencies check passed"
    log_info "Project: ${GCP_PROJECT}"
    log_info "Region:  ${GCP_REGION}"
}

# -----------------------------------------------------------------------------
# Setup Infrastructure
# -----------------------------------------------------------------------------

setup_infrastructure() {
    log_info "Setting up infrastructure..."
    
    # Enable required APIs
    gcloud services enable \
        run.googleapis.com \
        artifactregistry.googleapis.com \
        --project="${GCP_PROJECT}"
    
    # Create Artifact Registry repository if not exists
    if ! gcloud artifacts repositories describe tether \
        --location="${GCP_REGION}" \
        --project="${GCP_PROJECT}" &>/dev/null; then
        
        log_info "Creating Artifact Registry repository..."
        gcloud artifacts repositories create tether \
            --repository-format=docker \
            --location="${GCP_REGION}" \
            --description="Tether container images" \
            --project="${GCP_PROJECT}"
    fi
    
    # Configure Docker authentication
    gcloud auth configure-docker "${GCP_REGION}-docker.pkg.dev" --quiet
    
    log_success "Infrastructure ready"
}

# -----------------------------------------------------------------------------
# Build Container
# -----------------------------------------------------------------------------

build_container() {
    log_info "Building container image..."
    
    # Ensure we're building for linux/amd64 (Cloud Run requirement)
    docker build \
        --platform linux/amd64 \
        --tag "${IMAGE_NAME}:${IMAGE_TAG}" \
        --file "${DOCKERFILE}" \
        "${PROJECT_ROOT}"
    
    log_success "Container built: ${IMAGE_NAME}:${IMAGE_TAG}"
}

# -----------------------------------------------------------------------------
# Push Container
# -----------------------------------------------------------------------------

push_container() {
    log_info "Pushing container to Artifact Registry..."
    
    docker push "${IMAGE_NAME}:${IMAGE_TAG}"
    
    log_success "Container pushed: ${IMAGE_NAME}:${IMAGE_TAG}"
}

# -----------------------------------------------------------------------------
# Deploy to Cloud Run
# -----------------------------------------------------------------------------

deploy_to_cloud_run() {
    log_info "Deploying to Cloud Run..."
    
    gcloud run deploy "${SERVICE_NAME}" \
        --image="${IMAGE_NAME}:${IMAGE_TAG}" \
        --region="${GCP_REGION}" \
        --project="${GCP_PROJECT}" \
        --platform=managed \
        --allow-unauthenticated \
        --port=8080 \
        --memory=512Mi \
        --cpu=1 \
        --min-instances=0 \
        --max-instances=10 \
        --set-env-vars="RUST_LOG=info"
    
    log_success "Deployment complete"
}

# -----------------------------------------------------------------------------
# Print Service Info
# -----------------------------------------------------------------------------

print_service_info() {
    log_info "========================================"
    log_info "Deployment Summary"
    log_info "========================================"
    
    local service_url
    service_url=$(gcloud run services describe "${SERVICE_NAME}" \
        --region="${GCP_REGION}" \
        --project="${GCP_PROJECT}" \
        --format='value(status.url)')
    
    log_info "Service:  ${SERVICE_NAME}"
    log_info "Region:   ${GCP_REGION}"
    log_info "Image:    ${IMAGE_NAME}:${IMAGE_TAG}"
    log_info "URL:      ${service_url}"
    log_info ""
    log_warning "IMPORTANT: Set the dumbpipe ticket environment variable:"
    log_info "  gcloud run services update ${SERVICE_NAME} \\"
    log_info "      --region=${GCP_REGION} \\"
    log_info "      --set-env-vars='MCP_DUMBPIPE_TICKET=YOUR_TICKET'"
    log_info "========================================"
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------

main() {
    log_info "========================================"
    log_info "TETHER - Cloud Run Deployment"
    log_info "========================================"
    
    check_dependencies
    setup_infrastructure
    build_container
    push_container
    deploy_to_cloud_run
    print_service_info
    
    log_success "========================================"
    log_success "Deployment successful!"
    log_success "========================================"
}

main "$@"
```

---

### Critical Files for Implementation

1. **`/Users/jeffrey/code/tether/Makefile`** - Central build orchestration with all target dependencies, phony declarations, and build flow
2. **`/Users/jeffrey/code/tether/scripts/build-pi.sh`** - Cross-compilation with multiple methods (cross, docker, native) and comprehensive error handling
3. **`/Users/jeffrey/code/tether/scripts/generate-openapi.sh`** - OpenAPI extraction with fallback methods and TypeScript client generation
4. **`/Users/jeffrey/code/tether/scripts/build-web.sh`** - Web UI build pipeline with API client generation dependency
5. **`/Users/jeffrey/code/tether/claude-spec.md`** - Project specification that defines all requirements and architecture (already exists, use as reference)
