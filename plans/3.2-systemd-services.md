Now I have gathered comprehensive information. Let me compile the exhaustive implementation details for all systemd service units.

---

# Excruciating Implementation Details for Tether Systemd Service Units

This document provides complete, copy-paste ready content for all systemd service units, scripts, directory structures, and user/group setup for the tether project on Raspberry Pi.

## Table of Contents

1. [User and Group Setup](#1-user-and-group-setup)
2. [Directory Structure](#2-directory-structure)
3. [D-Bus Configuration](#3-d-bus-configuration)
4. [tether-server.service](#4-tether-serverservice)
5. [tether-dumbpipe.service](#5-tether-dumbpipeservice)
6. [tether-network-watchdog.service](#6-tether-network-watchdogservice)
7. [tether-save-ticket.sh](#7-tether-save-ticketsh)
8. [Installation Script](#8-installation-script)
9. [Ordering and Dependency Graph](#9-ordering-and-dependency-graph)

---

## 1. User and Group Setup

### 1.1 User Creation Script

**Location:** `/usr/local/sbin/tether-setup-user.sh`

```bash
#!/bin/bash
# tether-setup-user.sh
# Creates the tether system user with appropriate group memberships
# Run as root during sdm image build or first boot

set -euo pipefail

TETHER_USER="tether"
TETHER_HOME="/var/lib/tether"

# Check if running as root
if [[ $EUID -ne 0 ]]; then
    echo "ERROR: This script must be run as root" >&2
    exit 1
fi

# Create tether group if it doesn't exist
if ! getent group "${TETHER_USER}" >/dev/null 2>&1; then
    echo "Creating group: ${TETHER_USER}"
    groupadd --system "${TETHER_USER}"
fi

# Create tether user if it doesn't exist
if ! id "${TETHER_USER}" >/dev/null 2>&1; then
    echo "Creating user: ${TETHER_USER}"
    useradd \
        --system \
        --gid "${TETHER_USER}" \
        --home-dir "${TETHER_HOME}" \
        --no-create-home \
        --shell /usr/sbin/nologin \
        --comment "Tether service account" \
        "${TETHER_USER}"
fi

# Add tether user to required groups
# bluetooth: Required for BlueZ D-Bus API access
# netdev: Required for NetworkManager D-Bus API access (wifi management)
echo "Adding ${TETHER_USER} to supplementary groups..."

for group in bluetooth netdev; do
    if getent group "${group}" >/dev/null 2>&1; then
        if ! groups "${TETHER_USER}" | grep -qw "${group}"; then
            echo "  Adding to group: ${group}"
            usermod -aG "${group}" "${TETHER_USER}"
        else
            echo "  Already in group: ${group}"
        fi
    else
        echo "  WARNING: Group ${group} does not exist, skipping"
    fi
done

echo "User ${TETHER_USER} setup complete"
echo "Groups: $(groups ${TETHER_USER})"
```

### 1.2 Understanding Group Memberships

| Group | Purpose | Why Needed |
|-------|---------|------------|
| `tether` | Primary group | Owns tether files and directories |
| `bluetooth` | Bluetooth D-Bus access | Required to communicate with BlueZ daemon via D-Bus for device discovery and RSSI queries |
| `netdev` | Network device management | Required for NetworkManager D-Bus API to configure WiFi networks |

### 1.3 Capability Requirements

The tether services do NOT require elevated capabilities (no `CAP_NET_ADMIN`, `CAP_NET_RAW`) because:

1. **Bluetooth**: We use the BlueZ D-Bus API (not raw HCI sockets). D-Bus access is controlled via group membership (`bluetooth`) and D-Bus policy files.

2. **Network**: We use NetworkManager D-Bus API (not direct socket operations). D-Bus access is controlled via group membership (`netdev`).

**Important**: If you need to use raw Bluetooth HCI commands (e.g., `hcitool`), you would need to either:
- Run as root
- Set capabilities: `setcap 'cap_net_raw,cap_net_admin+eip' /path/to/binary`
- Use `AmbientCapabilities=CAP_NET_RAW CAP_NET_ADMIN` in the service file

For tether, we explicitly avoid this by using D-Bus APIs only.

---

## 2. Directory Structure

### 2.1 Complete Directory Tree

```
/etc/tether/                          # Configuration (root:tether 750)
    config.toml                       # Main configuration file (root:tether 640)
    ticket                            # Dumbpipe ticket (tether:tether 600)

/var/lib/tether/                      # Persistent data (tether:tether 750)
    passes.db                         # SQLite database for pass history (tether:tether 600)
    onboarding.done                   # Sentinel file indicating onboarding complete (tether:tether 644)

/var/log/tether/                      # Log files (tether:tether 750)
    # Note: Primary logging goes to journald
    # This directory exists for any file-based logging needs
    
/run/tether/                          # Runtime data (tether:tether 755)
    # Created automatically by RuntimeDirectory= directive
    # Contains transient runtime files (PIDs, sockets, etc.)

/usr/local/bin/                       # Executables
    tether-server                     # Main HTTP server binary (root:root 755)
    tether-network-watchdog           # Network watchdog script (root:root 755)
    tether-save-ticket.sh             # Ticket capture script (root:root 755)

/usr/share/tether/                    # Static assets (root:root 755)
    web/                              # Built web UI assets (root:root 755)
        index.html
        assets/
            ...
```

### 2.2 Directory Creation Script

**Location:** `/usr/local/sbin/tether-setup-dirs.sh`

```bash
#!/bin/bash
# tether-setup-dirs.sh
# Creates all required directories with correct ownership and permissions
# Run as root during sdm image build or first boot

set -euo pipefail

TETHER_USER="tether"
TETHER_GROUP="tether"

# Check if running as root
if [[ $EUID -ne 0 ]]; then
    echo "ERROR: This script must be run as root" >&2
    exit 1
fi

# Verify tether user exists
if ! id "${TETHER_USER}" >/dev/null 2>&1; then
    echo "ERROR: User ${TETHER_USER} does not exist. Run tether-setup-user.sh first." >&2
    exit 1
fi

echo "Creating tether directory structure..."

# /etc/tether - Configuration directory
# Owner: root (only root can modify config)
# Group: tether (service can read)
# Mode: 750 (rwxr-x---)
echo "Creating /etc/tether..."
install -d -m 750 -o root -g "${TETHER_GROUP}" /etc/tether

# Create empty config.toml if it doesn't exist
if [[ ! -f /etc/tether/config.toml ]]; then
    echo "Creating default /etc/tether/config.toml..."
    cat > /etc/tether/config.toml << 'EOF'
# Tether Configuration
# This file is created during first boot and modified via the web UI

[bluetooth]
# target_device_mac = "AA:BB:CC:DD:EE:FF"
# target_device_name = "iPhone"
# rssi_threshold = -70

[wifi]
# primary_network = "MyNetwork"
# [[wifi.networks]]
# ssid = "MyNetwork"
# psk = "password"

[passes]
monthly_limit = 3

[server]
listen_address = "0.0.0.0"
port = 3000

[timezone]
# tz = "America/Los_Angeles"
EOF
    chown root:"${TETHER_GROUP}" /etc/tether/config.toml
    chmod 640 /etc/tether/config.toml
fi

# /var/lib/tether - Persistent data directory
# Owner: tether (service needs write access)
# Group: tether
# Mode: 750 (rwxr-x---)
echo "Creating /var/lib/tether..."
install -d -m 750 -o "${TETHER_USER}" -g "${TETHER_GROUP}" /var/lib/tether

# /var/log/tether - Log directory (supplementary to journald)
# Owner: tether (service needs write access)
# Group: tether
# Mode: 750 (rwxr-x---)
echo "Creating /var/log/tether..."
install -d -m 750 -o "${TETHER_USER}" -g "${TETHER_GROUP}" /var/log/tether

# /usr/share/tether - Static assets (created during build)
echo "Creating /usr/share/tether..."
install -d -m 755 -o root -g root /usr/share/tether
install -d -m 755 -o root -g root /usr/share/tether/web

echo "Directory structure created successfully"

# Print summary
echo ""
echo "Directory summary:"
ls -la /etc/tether/
ls -la /var/lib/tether/
ls -la /var/log/tether/
```

### 2.3 File Permissions Matrix

| Path | Owner | Group | Mode | Rationale |
|------|-------|-------|------|-----------|
| `/etc/tether/` | root | tether | 750 | Config dir: root writes, service reads |
| `/etc/tether/config.toml` | root | tether | 640 | Contains WiFi passwords |
| `/etc/tether/ticket` | tether | tether | 600 | Sensitive: dumbpipe connection ticket |
| `/var/lib/tether/` | tether | tether | 750 | Data dir: service needs write |
| `/var/lib/tether/passes.db` | tether | tether | 600 | SQLite database |
| `/var/lib/tether/onboarding.done` | tether | tether | 644 | Sentinel file, world-readable OK |
| `/var/log/tether/` | tether | tether | 750 | Log dir |
| `/run/tether/` | tether | tether | 755 | Runtime dir (managed by systemd) |

---

## 3. D-Bus Configuration

### 3.1 Bluetooth D-Bus Policy

**Location:** `/etc/dbus-1/system.d/tether-bluetooth.conf`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE busconfig PUBLIC
 "-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN"
 "http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd">
<busconfig>
  <!-- 
    D-Bus policy for tether service to access BlueZ Bluetooth APIs
    
    This policy allows the 'tether' user to:
    - Query Bluetooth adapters and devices
    - Read RSSI (signal strength) values
    - Discover nearby devices
    
    It does NOT allow:
    - Pairing devices
    - Modifying adapter settings
    - Connecting to devices
  -->
  
  <policy user="tether">
    <!-- Allow sending messages to the BlueZ bus name -->
    <allow send_destination="org.bluez"/>
    
    <!-- Allow introspection for D-Bus discovery -->
    <allow send_interface="org.freedesktop.DBus.Introspectable"/>
    
    <!-- Allow reading properties (device name, RSSI, etc.) -->
    <allow send_interface="org.freedesktop.DBus.Properties"/>
    
    <!-- Allow ObjectManager for device enumeration -->
    <allow send_interface="org.freedesktop.DBus.ObjectManager"/>
    
    <!-- BlueZ specific interfaces for device discovery -->
    <allow send_interface="org.bluez.Adapter1"/>
    <allow send_interface="org.bluez.Device1"/>
  </policy>
</busconfig>
```

### 3.2 NetworkManager D-Bus Policy

**Location:** `/etc/dbus-1/system.d/tether-networkmanager.conf`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE busconfig PUBLIC
 "-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN"
 "http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd">
<busconfig>
  <!--
    D-Bus policy for tether service to access NetworkManager APIs
    
    This policy allows the 'tether' user to:
    - Query connection status
    - List available WiFi networks
    - Add/modify/activate WiFi connections
    - Query device state
  -->
  
  <policy user="tether">
    <!-- Allow sending messages to NetworkManager -->
    <allow send_destination="org.freedesktop.NetworkManager"/>
    
    <!-- Allow introspection -->
    <allow send_interface="org.freedesktop.DBus.Introspectable"/>
    
    <!-- Allow reading properties -->
    <allow send_interface="org.freedesktop.DBus.Properties"/>
    
    <!-- NetworkManager specific interfaces -->
    <allow send_interface="org.freedesktop.NetworkManager"/>
    <allow send_interface="org.freedesktop.NetworkManager.Settings"/>
    <allow send_interface="org.freedesktop.NetworkManager.Settings.Connection"/>
    <allow send_interface="org.freedesktop.NetworkManager.Device"/>
    <allow send_interface="org.freedesktop.NetworkManager.Device.Wireless"/>
    <allow send_interface="org.freedesktop.NetworkManager.AccessPoint"/>
    <allow send_interface="org.freedesktop.NetworkManager.Connection.Active"/>
  </policy>
</busconfig>
```

---

## 4. tether-server.service

**Location:** `/etc/systemd/system/tether-server.service`

```ini
# tether-server.service
# 
# Main HTTP server for the tether application. Provides:
# - REST API for Bluetooth proximity checking
# - REST API for pass management
# - REST API for configuration
# - Web UI hosting
# - OpenAPI specification endpoint
#
# This service runs ONLY on the local network and should NOT be exposed
# directly to the internet. Remote access is provided via dumbpipe.
#
# Dependencies:
# - bluetooth.service: BlueZ daemon for Bluetooth D-Bus API
# - NetworkManager.service: WiFi management
# - network-online.target: Ensures network stack is ready
#
# Started by: multi-user.target (normal boot)
# Wanted by: tether-dumbpipe.service (remote access)

[Unit]
Description=Tether HTTP Server
Documentation=https://github.com/yourrepo/tether

# Ordering dependencies - service starts AFTER these
After=network-online.target
After=bluetooth.service
After=NetworkManager.service

# Weak dependencies - we want these running but don't fail if they're not
Wants=network-online.target
Wants=bluetooth.service

# Binding dependency - if bluetooth stops, restart us
# (commented out - we can operate without bluetooth in degraded mode)
# BindsTo=bluetooth.service

# Required for network-online.target to work
Requires=network.target

# Condition: Skip starting if onboarding hasn't completed
# This prevents the server from starting with invalid/missing config
# Remove this condition if you want the server to run during onboarding
# ConditionPathExists=/var/lib/tether/onboarding.done

[Service]
# Service type: simple because our Rust binary runs in foreground
# We don't use notify because we haven't integrated sd_notify into axum
Type=simple

# User and group to run as (created by tether-setup-user.sh)
User=tether
Group=tether

# Working directory (not strictly needed but good practice)
WorkingDirectory=/var/lib/tether

# The main executable
# Arguments:
#   --config: Path to configuration file
#   --listen: Address to bind (read from config, but can override here)
ExecStart=/usr/local/bin/tether-server --config /etc/tether/config.toml

# ============================================================
# RESTART POLICY
# ============================================================
# Restart on failure, but not on clean exit (exit code 0)
Restart=on-failure

# Wait 5 seconds before restarting to avoid rapid restart loops
RestartSec=5

# Maximum restart attempts: 5 restarts within 60 seconds
# After this, systemd will stop trying and mark service as failed
StartLimitIntervalSec=60
StartLimitBurst=5

# ============================================================
# ENVIRONMENT VARIABLES
# ============================================================
# Rust-specific: Enable backtraces for panic debugging
Environment=RUST_BACKTRACE=1

# Rust log level: info for normal operation
# Change to debug or trace for troubleshooting
Environment=RUST_LOG=info,tether=debug

# Config file path (also passed as argument, but available as env)
Environment=TETHER_CONFIG_PATH=/etc/tether/config.toml

# Data directory for SQLite database
Environment=TETHER_DATA_DIR=/var/lib/tether

# Web UI static assets directory
Environment=TETHER_WEB_DIR=/usr/share/tether/web

# ============================================================
# LOGGING CONFIGURATION
# ============================================================
# Send stdout/stderr to journald with identifier
StandardOutput=journal
StandardError=journal

# Syslog identifier for filtering: journalctl -u tether-server
SyslogIdentifier=tether-server

# Log level passed to journald (info, debug, warning, err)
SyslogLevel=info

# ============================================================
# RUNTIME DIRECTORIES
# ============================================================
# Create /run/tether with correct ownership (cleaned on reboot)
RuntimeDirectory=tether
RuntimeDirectoryMode=0755

# Ensure state directory exists
StateDirectory=tether
StateDirectoryMode=0750

# Ensure log directory exists
LogsDirectory=tether
LogsDirectoryMode=0750

# ============================================================
# SECURITY HARDENING
# ============================================================
# These settings significantly reduce the attack surface

# Prevent privilege escalation through setuid/setgid binaries
NoNewPrivileges=true

# Make entire filesystem read-only except for specific paths
# "strict" = everything read-only, we whitelist writable paths
ProtectSystem=strict

# Make /home, /root, /run/user inaccessible
ProtectHome=true

# Create private /tmp and /var/tmp (isolated from other services)
PrivateTmp=true

# Restrict access to hardware devices
# We DON'T use PrivateDevices=true because we need D-Bus access
# D-Bus socket is in /run/dbus which requires /dev access
PrivateDevices=false

# Protect kernel tunables (/proc/sys, /sys/fs, /sys/kernel)
ProtectKernelTunables=true

# Protect kernel modules (prevent loading/unloading)
ProtectKernelModules=true

# Protect kernel logs (/dev/kmsg, /proc/kmsg)
ProtectKernelLogs=true

# Protect control groups (/sys/fs/cgroup)
ProtectControlGroups=true

# Protect hostname from being changed
ProtectHostname=true

# Protect system clock
ProtectClock=true

# Protect /proc from being modified
# "invisible" hides other processes, "default" shows only owned processes
ProtectProc=default
ProcSubset=pid

# Restrict namespace creation
RestrictNamespaces=true

# Lock down personality system call (prevents changing execution domain)
LockPersonality=true

# Prevent SUID/SGID file creation
RestrictSUIDSGID=true

# Restrict realtime scheduling (not needed for web server)
RestrictRealtime=true

# Memory execution restrictions
# Prevents creating writable+executable memory mappings
# Note: Some JIT compilers need this disabled
MemoryDenyWriteExecute=true

# Restrict address families to only what's needed
# AF_UNIX: Unix domain sockets (D-Bus)
# AF_INET: IPv4 (HTTP server)
# AF_INET6: IPv6 (HTTP server)
# AF_NETLINK: Network configuration queries
RestrictAddressFamilies=AF_UNIX AF_INET AF_INET6 AF_NETLINK

# System call filtering - allow only necessary syscalls
# @system-service is a predefined set for typical services
SystemCallFilter=@system-service
SystemCallFilter=~@privileged @resources

# Use native syscall architecture only (prevents 32-bit compat syscalls)
SystemCallArchitectures=native

# Error code when filtered syscall is attempted
SystemCallErrorNumber=EPERM

# ============================================================
# RESOURCE LIMITS
# ============================================================
# Limit file descriptors (connections + files)
LimitNOFILE=1024

# Limit number of processes/threads
LimitNPROC=64

# Memory limit (adjust based on Pi model)
# Pi Zero 2 W has 512MB RAM
MemoryMax=128M
MemoryHigh=96M

# CPU quota (percentage of one core)
# 100% = one full core, 50% = half a core
CPUQuota=80%

# ============================================================
# WRITABLE PATHS
# ============================================================
# Allow writing to these specific paths (overrides ProtectSystem=strict)
ReadWritePaths=/var/lib/tether
ReadWritePaths=/var/log/tether
ReadWritePaths=/run/tether

# Read-only paths needed for operation
ReadOnlyPaths=/etc/tether
ReadOnlyPaths=/usr/share/tether

# ============================================================
# TIMEOUT CONFIGURATION
# ============================================================
# Time to wait for service to start
TimeoutStartSec=30

# Time to wait for service to stop (before SIGKILL)
TimeoutStopSec=10

# Signal to use for stopping (SIGTERM allows graceful shutdown)
KillSignal=SIGTERM

# Send SIGKILL to remaining processes after main process exits
KillMode=mixed

[Install]
# Start at normal boot (multi-user, no GUI)
WantedBy=multi-user.target
```

---

## 5. tether-dumbpipe.service

**Location:** `/etc/systemd/system/tether-dumbpipe.service`

```ini
# tether-dumbpipe.service
#
# Exposes the tether HTTP server to the internet via dumbpipe/iroh.
# Creates a secure P2P tunnel using QUIC with NAT traversal.
#
# This service:
# 1. Starts dumbpipe in listen-tcp mode
# 2. Captures the generated ticket
# 3. Saves the ticket to /etc/tether/ticket
# 4. Forwards incoming connections to localhost:3000 (tether-server)
#
# The ticket is a cryptographic credential that allows remote clients
# (like the MCP server) to connect to this Raspberry Pi from anywhere.
#
# IMPORTANT: This service only starts AFTER onboarding is complete.
# The ConditionPathExists ensures we don't expose an unconfigured device.
#
# Dependencies:
# - tether-server.service: The HTTP server we're exposing
# - network-online.target: Internet connectivity for iroh relay

[Unit]
Description=Tether Dumbpipe Remote Access Tunnel
Documentation=https://github.com/n0-computer/dumbpipe

# Ordering: Start after the HTTP server is running
After=tether-server.service
After=network-online.target

# Dependency: We need tether-server to be running
# "Requires" means if tether-server fails/stops, we stop too
Requires=tether-server.service
Wants=network-online.target

# Binding: If tether-server stops, stop dumbpipe too
# This prevents orphaned tunnels to non-existent servers
BindsTo=tether-server.service

# CRITICAL CONDITION: Only start if onboarding is complete
# This file is created at the end of the onboarding flow
# Without this, we'd expose an unconfigured device to the internet
ConditionPathExists=/var/lib/tether/onboarding.done

[Service]
# Service type: simple because dumbpipe runs in foreground
Type=simple

# Run as tether user (needs to write ticket file)
User=tether
Group=tether

# Working directory
WorkingDirectory=/var/lib/tether

# ============================================================
# MAIN EXECUTION
# ============================================================
# We use a wrapper script to:
# 1. Start dumbpipe
# 2. Capture the ticket from its output
# 3. Save the ticket to a file
# 4. Continue running dumbpipe

# Option A: Wrapper script approach (RECOMMENDED)
ExecStart=/usr/local/bin/tether-save-ticket.sh

# Option B: Direct execution with ticket capture via ExecStartPost
# This is more complex and less reliable - use Option A
# ExecStart=/usr/local/bin/dumbpipe listen-tcp --host 127.0.0.1:3000

# Pre-start: Ensure ticket file is writable
ExecStartPre=/bin/touch /etc/tether/ticket
ExecStartPre=/bin/chmod 600 /etc/tether/ticket

# ============================================================
# RESTART POLICY
# ============================================================
# Always restart - dumbpipe should be continuously running
Restart=always

# Wait 10 seconds before restart (allows network issues to resolve)
RestartSec=10

# Be more lenient with restart limits for network services
StartLimitIntervalSec=300
StartLimitBurst=10

# ============================================================
# ENVIRONMENT VARIABLES
# ============================================================
# Rust logging for dumbpipe/iroh
Environment=RUST_LOG=info,iroh=debug

# Ticket file location (used by wrapper script)
Environment=TETHER_TICKET_FILE=/etc/tether/ticket

# Local server address to forward to
Environment=TETHER_LOCAL_SERVER=127.0.0.1:3000

# ============================================================
# LOGGING CONFIGURATION
# ============================================================
StandardOutput=journal
StandardError=journal
SyslogIdentifier=tether-dumbpipe

# ============================================================
# SECURITY HARDENING
# ============================================================
# Similar to tether-server, but with some relaxations for networking

NoNewPrivileges=true
ProtectSystem=strict
ProtectHome=true
PrivateTmp=true
PrivateDevices=false
ProtectKernelTunables=true
ProtectKernelModules=true
ProtectKernelLogs=true
ProtectControlGroups=true
ProtectHostname=true
ProtectClock=true
RestrictNamespaces=true
LockPersonality=true
RestrictSUIDSGID=true
RestrictRealtime=true

# Dumbpipe/iroh needs broader network access
RestrictAddressFamilies=AF_UNIX AF_INET AF_INET6 AF_NETLINK

# Memory execution: iroh may need JIT for crypto
# Test with true first, disable if it fails
MemoryDenyWriteExecute=false

SystemCallFilter=@system-service
SystemCallFilter=~@privileged @resources
SystemCallArchitectures=native

# ============================================================
# WRITABLE PATHS
# ============================================================
ReadWritePaths=/etc/tether
ReadWritePaths=/var/lib/tether
ReadWritePaths=/run/tether

# ============================================================
# RESOURCE LIMITS
# ============================================================
LimitNOFILE=1024
MemoryMax=64M
MemoryHigh=48M
CPUQuota=50%

# ============================================================
# TIMEOUT CONFIGURATION
# ============================================================
TimeoutStartSec=60
TimeoutStopSec=10
KillSignal=SIGTERM
KillMode=mixed

[Install]
WantedBy=multi-user.target
```

---

## 6. tether-network-watchdog.service

**Location:** `/etc/systemd/system/tether-network-watchdog.service`

```ini
# tether-network-watchdog.service
#
# Monitors network connectivity and manages WiFi failover.
#
# This service implements the following logic:
# 1. Periodically checks if current WiFi has internet connectivity
# 2. If no internet, tries other configured WiFi networks
# 3. If all networks fail, activates the setup AP for reconfiguration
# 4. When a network becomes available, deactivates the AP
#
# The watchdog runs as a simple loop with configurable check intervals.
# It's designed to be lightweight and resilient.
#
# Dependencies:
# - NetworkManager.service: WiFi management
# - (No dependency on tether-server - watchdog runs independently)

[Unit]
Description=Tether Network Connectivity Watchdog
Documentation=https://github.com/yourrepo/tether

# Ordering: Start after NetworkManager is ready
After=NetworkManager.service
After=network-online.target

# Weak dependency: We want NetworkManager but can start without it
Wants=NetworkManager.service

# Don't bind to NetworkManager - we need to run even if NM restarts
# to detect when connectivity is restored

# Conflict with NetworkManager-wait-online 
# (we do our own connectivity checking)
# Conflicts=NetworkManager-wait-online.service

[Service]
# Service type: simple (runs in foreground with a loop)
Type=simple

# Run as tether user
User=tether
Group=tether

# Working directory
WorkingDirectory=/var/lib/tether

# ============================================================
# MAIN EXECUTION
# ============================================================
# The watchdog script/binary
# Arguments:
#   --interval: Check interval in seconds (default 30)
#   --timeout: Connectivity check timeout in seconds (default 10)
#   --config: Path to config file for WiFi network list
ExecStart=/usr/local/bin/tether-network-watchdog \
    --config /etc/tether/config.toml \
    --interval 30 \
    --timeout 10

# ============================================================
# RESTART POLICY
# ============================================================
# Always restart - this is a critical service
Restart=always

# Short restart delay - network issues need quick response
RestartSec=5

# Generous restart limits
StartLimitIntervalSec=300
StartLimitBurst=20

# ============================================================
# ENVIRONMENT VARIABLES
# ============================================================
Environment=RUST_LOG=info,tether_network_watchdog=debug

# Config file path
Environment=TETHER_CONFIG_PATH=/etc/tether/config.toml

# Connectivity check URL (should be reliable, fast, minimal data)
# Options: http://connectivitycheck.gstatic.com/generate_204
#          http://captive.apple.com/hotspot-detect.html
#          http://nmcheck.gnome.org/check_network_status.txt
Environment=CONNECTIVITY_CHECK_URL=http://connectivitycheck.gstatic.com/generate_204

# ============================================================
# LOGGING CONFIGURATION
# ============================================================
StandardOutput=journal
StandardError=journal
SyslogIdentifier=tether-network-watchdog

# ============================================================
# SECURITY HARDENING
# ============================================================
NoNewPrivileges=true
ProtectSystem=strict
ProtectHome=true
PrivateTmp=true
PrivateDevices=false
ProtectKernelTunables=true
ProtectKernelModules=true
ProtectKernelLogs=true
ProtectControlGroups=true
ProtectHostname=true
ProtectClock=true
RestrictNamespaces=true
LockPersonality=true
RestrictSUIDSGID=true
RestrictRealtime=true
MemoryDenyWriteExecute=true

# Network access required
RestrictAddressFamilies=AF_UNIX AF_INET AF_INET6 AF_NETLINK

SystemCallFilter=@system-service
SystemCallFilter=~@privileged @resources
SystemCallArchitectures=native

# ============================================================
# WRITABLE PATHS
# ============================================================
# Watchdog mostly reads, but may need to write state
ReadWritePaths=/var/lib/tether
ReadOnlyPaths=/etc/tether

# ============================================================
# RESOURCE LIMITS
# ============================================================
# Watchdog is very lightweight
LimitNOFILE=256
MemoryMax=32M
MemoryHigh=24M
CPUQuota=20%

# ============================================================
# TIMEOUT CONFIGURATION
# ============================================================
TimeoutStartSec=30
TimeoutStopSec=10
KillSignal=SIGTERM
KillMode=mixed

[Install]
WantedBy=multi-user.target
```

---

## 7. tether-save-ticket.sh

**Location:** `/usr/local/bin/tether-save-ticket.sh`

```bash
#!/bin/bash
# tether-save-ticket.sh
#
# Wrapper script for dumbpipe that captures the generated ticket.
#
# When dumbpipe starts in listen-tcp mode, it prints the ticket to stdout
# on a single line. This script:
# 1. Starts dumbpipe in the background
# 2. Reads the first line of output (the ticket)
# 3. Saves the ticket to /etc/tether/ticket
# 4. Continues to relay dumbpipe's output to stdout (for journald)
# 5. Properly handles SIGTERM for graceful shutdown
#
# This script is executed by tether-dumbpipe.service

set -euo pipefail

# ============================================================
# CONFIGURATION
# ============================================================
# These can be overridden by environment variables from systemd

# Path to dumbpipe binary
DUMBPIPE_BIN="${DUMBPIPE_BIN:-/usr/local/bin/dumbpipe}"

# Local address to forward connections to (tether-server)
LOCAL_SERVER="${TETHER_LOCAL_SERVER:-127.0.0.1:3000}"

# File to save the ticket
TICKET_FILE="${TETHER_TICKET_FILE:-/etc/tether/ticket}"

# Timeout for waiting for ticket (seconds)
TICKET_TIMEOUT="${TICKET_TIMEOUT:-30}"

# PID of dumbpipe process (for signal handling)
DUMBPIPE_PID=""

# ============================================================
# LOGGING FUNCTIONS
# ============================================================
log_info() {
    echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') $*"
}

log_error() {
    echo "[ERROR] $(date '+%Y-%m-%d %H:%M:%S') $*" >&2
}

log_debug() {
    if [[ "${DEBUG:-false}" == "true" ]]; then
        echo "[DEBUG] $(date '+%Y-%m-%d %H:%M:%S') $*"
    fi
}

# ============================================================
# SIGNAL HANDLING
# ============================================================
cleanup() {
    local signal="${1:-TERM}"
    log_info "Received SIG${signal}, shutting down..."
    
    if [[ -n "${DUMBPIPE_PID}" ]] && kill -0 "${DUMBPIPE_PID}" 2>/dev/null; then
        log_info "Sending SIGTERM to dumbpipe (PID: ${DUMBPIPE_PID})"
        kill -TERM "${DUMBPIPE_PID}" 2>/dev/null || true
        
        # Wait up to 5 seconds for graceful shutdown
        local wait_count=0
        while kill -0 "${DUMBPIPE_PID}" 2>/dev/null && [[ ${wait_count} -lt 50 ]]; do
            sleep 0.1
            ((wait_count++))
        done
        
        # Force kill if still running
        if kill -0 "${DUMBPIPE_PID}" 2>/dev/null; then
            log_info "Sending SIGKILL to dumbpipe"
            kill -KILL "${DUMBPIPE_PID}" 2>/dev/null || true
        fi
    fi
    
    log_info "Cleanup complete, exiting"
    exit 0
}

# Register signal handlers
trap 'cleanup TERM' SIGTERM
trap 'cleanup INT' SIGINT
trap 'cleanup HUP' SIGHUP

# ============================================================
# VALIDATION
# ============================================================
validate_environment() {
    log_info "Validating environment..."
    
    # Check dumbpipe binary exists
    if [[ ! -x "${DUMBPIPE_BIN}" ]]; then
        log_error "dumbpipe binary not found or not executable: ${DUMBPIPE_BIN}"
        exit 1
    fi
    
    # Check ticket file directory exists and is writable
    local ticket_dir
    ticket_dir=$(dirname "${TICKET_FILE}")
    if [[ ! -d "${ticket_dir}" ]]; then
        log_error "Ticket directory does not exist: ${ticket_dir}"
        exit 1
    fi
    if [[ ! -w "${ticket_dir}" ]]; then
        log_error "Ticket directory is not writable: ${ticket_dir}"
        exit 1
    fi
    
    # Check local server format
    if [[ ! "${LOCAL_SERVER}" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+:[0-9]+$ ]] && \
       [[ ! "${LOCAL_SERVER}" =~ ^localhost:[0-9]+$ ]] && \
       [[ ! "${LOCAL_SERVER}" =~ ^\[.*\]:[0-9]+$ ]]; then
        log_error "Invalid LOCAL_SERVER format: ${LOCAL_SERVER}"
        log_error "Expected format: host:port (e.g., 127.0.0.1:3000)"
        exit 1
    fi
    
    log_info "Environment validation passed"
}

# ============================================================
# TICKET EXTRACTION
# ============================================================
# Dumbpipe ticket format is a base32-encoded string starting with specific prefixes
# Example: "endpointealvvv4nwa522qhznqrblv6jxcrgnvpapvakxw5i6mwltmm6ps2r4aica..."
#
# The ticket contains:
# - Version identifier
# - Node public key
# - Relay information
# - Protocol details
is_valid_ticket() {
    local line="$1"
    
    # Ticket characteristics:
    # - Starts with specific prefixes (endpoint, blobdownload, etc.)
    # - Base32 encoded (alphanumeric, no special chars except possibly version suffix)
    # - Typically 50-200 characters
    
    # Check for known ticket prefixes
    if [[ "${line}" =~ ^(endpoint|blobdownload|docsync)[a-z0-9]+ ]]; then
        # Additional validation: minimum length
        if [[ ${#line} -ge 50 ]]; then
            return 0
        fi
    fi
    
    return 1
}

extract_ticket() {
    local input_fd="$1"
    local timeout="${2:-30}"
    local ticket=""
    local line=""
    local elapsed=0
    
    log_info "Waiting for ticket from dumbpipe (timeout: ${timeout}s)..."
    
    # Read lines until we find a valid ticket or timeout
    while [[ ${elapsed} -lt ${timeout} ]]; do
        # Use read with timeout
        if read -r -t 1 line <&"${input_fd}" 2>/dev/null; then
            log_debug "Read line: ${line:0:80}..."
            
            # Check if this line is a ticket
            if is_valid_ticket "${line}"; then
                ticket="${line}"
                log_info "Found valid ticket (${#ticket} chars)"
                break
            fi
            
            # Also relay the line to stdout for logging
            echo "${line}"
        fi
        
        ((elapsed++)) || true
    done
    
    if [[ -z "${ticket}" ]]; then
        log_error "Failed to extract ticket within ${timeout} seconds"
        return 1
    fi
    
    echo "${ticket}"
}

save_ticket() {
    local ticket="$1"
    local file="$2"
    local temp_file="${file}.tmp.$$"
    
    log_info "Saving ticket to ${file}..."
    
    # Write to temp file first (atomic write pattern)
    if ! echo "${ticket}" > "${temp_file}"; then
        log_error "Failed to write ticket to temp file: ${temp_file}"
        rm -f "${temp_file}" 2>/dev/null || true
        return 1
    fi
    
    # Set restrictive permissions
    chmod 600 "${temp_file}"
    
    # Atomic move
    if ! mv "${temp_file}" "${file}"; then
        log_error "Failed to move ticket to final location: ${file}"
        rm -f "${temp_file}" 2>/dev/null || true
        return 1
    fi
    
    log_info "Ticket saved successfully"
    
    # Verify
    if [[ -f "${file}" ]]; then
        local saved_ticket
        saved_ticket=$(cat "${file}")
        if [[ "${saved_ticket}" == "${ticket}" ]]; then
            log_info "Ticket verification passed"
            return 0
        else
            log_error "Ticket verification failed - content mismatch"
            return 1
        fi
    else
        log_error "Ticket file not found after save: ${file}"
        return 1
    fi
}

# ============================================================
# MAIN EXECUTION
# ============================================================
main() {
    log_info "Starting tether-save-ticket.sh"
    log_info "  DUMBPIPE_BIN: ${DUMBPIPE_BIN}"
    log_info "  LOCAL_SERVER: ${LOCAL_SERVER}"
    log_info "  TICKET_FILE: ${TICKET_FILE}"
    
    # Validate environment
    validate_environment
    
    # Create a pipe for capturing dumbpipe output
    # We need to read the ticket from stdout while still allowing dumbpipe to run
    local pipe_dir
    pipe_dir=$(mktemp -d)
    local stdout_pipe="${pipe_dir}/stdout"
    mkfifo "${stdout_pipe}"
    
    # Cleanup function for pipe
    cleanup_pipe() {
        rm -f "${stdout_pipe}" 2>/dev/null || true
        rmdir "${pipe_dir}" 2>/dev/null || true
    }
    trap 'cleanup_pipe; cleanup TERM' SIGTERM SIGINT SIGHUP
    
    log_info "Starting dumbpipe listen-tcp..."
    
    # Start dumbpipe with output to our pipe
    # We redirect stderr to stdout so we capture everything
    "${DUMBPIPE_BIN}" listen-tcp --host "${LOCAL_SERVER}" 2>&1 > "${stdout_pipe}" &
    DUMBPIPE_PID=$!
    
    log_info "dumbpipe started with PID: ${DUMBPIPE_PID}"
    
    # Open pipe for reading
    exec 3< "${stdout_pipe}"
    
    # Extract ticket from the pipe
    local ticket
    if ! ticket=$(extract_ticket 3 "${TICKET_TIMEOUT}"); then
        log_error "Failed to extract ticket, terminating dumbpipe"
        cleanup TERM
        exit 1
    fi
    
    # Save the ticket
    if ! save_ticket "${ticket}" "${TICKET_FILE}"; then
        log_error "Failed to save ticket, but continuing (dumbpipe is running)"
        # Don't exit - the ticket might still work even if we couldn't save it
    fi
    
    log_info "Ticket capture complete, relaying dumbpipe output..."
    
    # Continue relaying dumbpipe output until it exits or we receive a signal
    # This keeps the service running and logs visible in journald
    while kill -0 "${DUMBPIPE_PID}" 2>/dev/null; do
        if read -r -t 1 line <&3 2>/dev/null; then
            echo "${line}"
        fi
    done
    
    # Dumbpipe exited - get exit code
    wait "${DUMBPIPE_PID}" || true
    local exit_code=$?
    
    log_info "dumbpipe exited with code: ${exit_code}"
    
    # Cleanup
    exec 3<&-
    cleanup_pipe
    
    exit "${exit_code}"
}

# Run main function
main "$@"
```

**Make it executable:**
```bash
chmod 755 /usr/local/bin/tether-save-ticket.sh
```

---

## 8. Installation Script

**Location:** `/usr/local/sbin/tether-install-services.sh`

```bash
#!/bin/bash
# tether-install-services.sh
#
# Installs all tether systemd services, creates directories,
# sets up the user, and enables services.
#
# This script is intended to be run:
# - During sdm image build (Phase 1 - customization)
# - Manually during development/testing
#
# Usage: sudo ./tether-install-services.sh [--enable] [--start]
#   --enable: Enable services to start on boot
#   --start: Start services immediately (requires --enable)

set -euo pipefail

# ============================================================
# CONFIGURATION
# ============================================================
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TETHER_USER="tether"
TETHER_GROUP="tether"

# Source locations (adjust based on your build structure)
# During sdm build, these would be in the mounted image
SERVICE_SOURCE_DIR="${SERVICE_SOURCE_DIR:-/path/to/tether/deploy/systemd}"
BINARY_SOURCE_DIR="${BINARY_SOURCE_DIR:-/path/to/tether/target/release}"
WEB_SOURCE_DIR="${WEB_SOURCE_DIR:-/path/to/tether/packages/web-ui/dist}"

# ============================================================
# ARGUMENT PARSING
# ============================================================
ENABLE_SERVICES=false
START_SERVICES=false

while [[ $# -gt 0 ]]; do
    case "$1" in
        --enable)
            ENABLE_SERVICES=true
            shift
            ;;
        --start)
            START_SERVICES=true
            shift
            ;;
        --help)
            echo "Usage: $0 [--enable] [--start]"
            echo "  --enable: Enable services to start on boot"
            echo "  --start: Start services immediately"
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            exit 1
            ;;
    esac
done

# ============================================================
# PREFLIGHT CHECKS
# ============================================================
if [[ $EUID -ne 0 ]]; then
    echo "ERROR: This script must be run as root" >&2
    exit 1
fi

echo "========================================"
echo "Tether Service Installation"
echo "========================================"
echo ""

# ============================================================
# USER SETUP
# ============================================================
echo "Step 1: Setting up tether user..."
/usr/local/sbin/tether-setup-user.sh || {
    echo "ERROR: User setup failed"
    exit 1
}
echo ""

# ============================================================
# DIRECTORY SETUP
# ============================================================
echo "Step 2: Setting up directories..."
/usr/local/sbin/tether-setup-dirs.sh || {
    echo "ERROR: Directory setup failed"
    exit 1
}
echo ""

# ============================================================
# D-BUS CONFIGURATION
# ============================================================
echo "Step 3: Installing D-Bus policies..."

# Bluetooth D-Bus policy
cat > /etc/dbus-1/system.d/tether-bluetooth.conf << 'EOF'
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE busconfig PUBLIC
 "-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN"
 "http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd">
<busconfig>
  <policy user="tether">
    <allow send_destination="org.bluez"/>
    <allow send_interface="org.freedesktop.DBus.Introspectable"/>
    <allow send_interface="org.freedesktop.DBus.Properties"/>
    <allow send_interface="org.freedesktop.DBus.ObjectManager"/>
    <allow send_interface="org.bluez.Adapter1"/>
    <allow send_interface="org.bluez.Device1"/>
  </policy>
</busconfig>
EOF

# NetworkManager D-Bus policy
cat > /etc/dbus-1/system.d/tether-networkmanager.conf << 'EOF'
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE busconfig PUBLIC
 "-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN"
 "http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd">
<busconfig>
  <policy user="tether">
    <allow send_destination="org.freedesktop.NetworkManager"/>
    <allow send_interface="org.freedesktop.DBus.Introspectable"/>
    <allow send_interface="org.freedesktop.DBus.Properties"/>
    <allow send_interface="org.freedesktop.NetworkManager"/>
    <allow send_interface="org.freedesktop.NetworkManager.Settings"/>
    <allow send_interface="org.freedesktop.NetworkManager.Settings.Connection"/>
    <allow send_interface="org.freedesktop.NetworkManager.Device"/>
    <allow send_interface="org.freedesktop.NetworkManager.Device.Wireless"/>
    <allow send_interface="org.freedesktop.NetworkManager.AccessPoint"/>
    <allow send_interface="org.freedesktop.NetworkManager.Connection.Active"/>
  </policy>
</busconfig>
EOF

echo "D-Bus policies installed"
echo ""

# ============================================================
# BINARY INSTALLATION
# ============================================================
echo "Step 4: Installing binaries..."

# These would typically be built and copied during the sdm build process
# For now, we just verify the paths exist or skip

for binary in tether-server tether-network-watchdog; do
    if [[ -f "${BINARY_SOURCE_DIR}/${binary}" ]]; then
        install -m 755 -o root -g root \
            "${BINARY_SOURCE_DIR}/${binary}" \
            "/usr/local/bin/${binary}"
        echo "  Installed: ${binary}"
    else
        echo "  SKIPPED: ${binary} (source not found)"
    fi
done

# Install wrapper script
install -m 755 -o root -g root \
    "$(dirname "$0")/../bin/tether-save-ticket.sh" \
    /usr/local/bin/tether-save-ticket.sh 2>/dev/null || {
    echo "  Note: tether-save-ticket.sh will be installed separately"
}

# Install dumbpipe if available
if [[ -f "${BINARY_SOURCE_DIR}/dumbpipe" ]]; then
    install -m 755 -o root -g root \
        "${BINARY_SOURCE_DIR}/dumbpipe" \
        /usr/local/bin/dumbpipe
    echo "  Installed: dumbpipe"
fi

echo ""

# ============================================================
# WEB UI INSTALLATION
# ============================================================
echo "Step 5: Installing web UI..."

if [[ -d "${WEB_SOURCE_DIR}" ]]; then
    cp -r "${WEB_SOURCE_DIR}"/* /usr/share/tether/web/
    chown -R root:root /usr/share/tether/web/
    echo "  Web UI installed to /usr/share/tether/web/"
else
    echo "  SKIPPED: Web UI source not found"
fi

echo ""

# ============================================================
# SYSTEMD SERVICE INSTALLATION
# ============================================================
echo "Step 6: Installing systemd services..."

# Install service files
for service in tether-server tether-dumbpipe tether-network-watchdog; do
    service_file="${service}.service"
    
    if [[ -f "${SERVICE_SOURCE_DIR}/${service_file}" ]]; then
        install -m 644 -o root -g root \
            "${SERVICE_SOURCE_DIR}/${service_file}" \
            "/etc/systemd/system/${service_file}"
        echo "  Installed: ${service_file}"
    else
        echo "  SKIPPED: ${service_file} (source not found)"
    fi
done

echo ""

# ============================================================
# SYSTEMD DAEMON RELOAD
# ============================================================
echo "Step 7: Reloading systemd daemon..."
systemctl daemon-reload
echo "  Daemon reloaded"
echo ""

# ============================================================
# ENABLE SERVICES
# ============================================================
if [[ "${ENABLE_SERVICES}" == "true" ]]; then
    echo "Step 8: Enabling services..."
    
    for service in tether-server tether-dumbpipe tether-network-watchdog; do
        if systemctl list-unit-files | grep -q "${service}.service"; then
            systemctl enable "${service}.service"
            echo "  Enabled: ${service}"
        fi
    done
    
    echo ""
fi

# ============================================================
# START SERVICES
# ============================================================
if [[ "${START_SERVICES}" == "true" ]]; then
    if [[ "${ENABLE_SERVICES}" != "true" ]]; then
        echo "WARNING: --start requires --enable"
    else
        echo "Step 9: Starting services..."
        
        # Start in dependency order
        for service in tether-network-watchdog tether-server tether-dumbpipe; do
            if systemctl list-unit-files | grep -q "${service}.service"; then
                if systemctl start "${service}.service"; then
                    echo "  Started: ${service}"
                else
                    echo "  FAILED: ${service}"
                fi
            fi
        done
        
        echo ""
    fi
fi

# ============================================================
# SUMMARY
# ============================================================
echo "========================================"
echo "Installation Complete"
echo "========================================"
echo ""
echo "User: ${TETHER_USER}"
echo "Groups: $(groups ${TETHER_USER} 2>/dev/null || echo 'N/A')"
echo ""
echo "Directories:"
echo "  Config: /etc/tether/"
echo "  Data: /var/lib/tether/"
echo "  Logs: /var/log/tether/"
echo ""
echo "Services:"
systemctl list-unit-files 'tether-*.service' 2>/dev/null || echo "  (not yet installed)"
echo ""
echo "Next steps:"
echo "  1. Build and install binaries to /usr/local/bin/"
echo "  2. Build and install web UI to /usr/share/tether/web/"
echo "  3. Run: systemctl enable --now tether-server tether-network-watchdog"
echo "  4. After onboarding: touch /var/lib/tether/onboarding.done"
echo "  5. Then: systemctl enable --now tether-dumbpipe"
```

---

## 9. Ordering and Dependency Graph

### 9.1 Service Dependency Diagram

```
                    ┌─────────────────────────┐
                    │    multi-user.target    │
                    │    (Normal boot)        │
                    └───────────┬─────────────┘
                                │
            ┌───────────────────┼───────────────────┐
            │                   │                   │
            ▼                   ▼                   ▼
┌───────────────────┐ ┌─────────────────┐ ┌─────────────────────┐
│ network-online    │ │ bluetooth       │ │ NetworkManager      │
│ .target           │ │ .service        │ │ .service            │
└─────────┬─────────┘ └────────┬────────┘ └──────────┬──────────┘
          │                    │                     │
          │         After      │ After       After   │
          │          ▼         ▼                     ▼
          │    ┌─────────────────────────────────────────┐
          └───►│         tether-server.service           │
               │                                         │
               │  - Runs HTTP server on localhost:3000   │
               │  - Serves API and Web UI                │
               │  - Queries Bluetooth via D-Bus          │
               │  - Manages WiFi via D-Bus               │
               └───────────────┬─────────────────────────┘
                               │
                               │ Requires + BindsTo + After
                               │
                               ▼
               ┌───────────────────────────────────────────┐
               │       tether-dumbpipe.service             │
               │                                           │
               │  ConditionPathExists=                     │
               │    /var/lib/tether/onboarding.done        │
               │                                           │
               │  - Starts ONLY after onboarding complete  │
               │  - Runs dumbpipe listen-tcp               │
               │  - Captures and saves ticket              │
               │  - Exposes tether-server to internet      │
               └───────────────────────────────────────────┘

          ┌───────────────────────────────────────────┐
          │     tether-network-watchdog.service       │
          │                                           │
          │  After=NetworkManager.service             │
          │                                           │
          │  - Runs independently of tether-server    │
          │  - Monitors connectivity                  │
          │  - Manages WiFi failover                  │
          │  - Activates setup AP if needed           │
          └───────────────────────────────────────────┘
```

### 9.2 Boot Sequence Timeline

```
Time  Event
─────────────────────────────────────────────────────────────────────
T+0   System boot begins
      │
T+2   network.target reached
      │
T+5   bluetooth.service starts
      │
T+6   NetworkManager.service starts
      │
T+10  bluetooth.service ready (D-Bus interface available)
      │
T+12  NetworkManager.service ready
      │
T+15  network-online.target reached (if network available)
      │
T+16  tether-network-watchdog.service starts
      │   - Begins monitoring connectivity
      │   - Runs in parallel with other services
      │
T+17  tether-server.service starts
      │   - Dependencies satisfied: network, bluetooth, nm
      │   - Binds to localhost:3000
      │   - Loads config from /etc/tether/config.toml
      │
T+18  tether-server.service ready
      │   - HTTP API available
      │   - Web UI accessible on local network
      │
T+19  tether-dumbpipe.service attempts start
      │
      ├── IF /var/lib/tether/onboarding.done EXISTS:
      │   │
      │   T+20  dumbpipe listen-tcp starts
      │   │     - Generates ticket
      │   │     - Saves to /etc/tether/ticket
      │   │     - Connects to iroh relay
      │   │
      │   T+25  dumbpipe ready
      │         - Remote access available
      │         - MCP server can connect
      │
      └── IF /var/lib/tether/onboarding.done DOES NOT EXIST:
          │
          T+19  ConditionPathExists fails
                - Service not started
                - No error logged (condition skip is silent)
                - Will start when file is created and service is restarted
```

### 9.3 Relationship Summary Table

| Service | Depends On | Depended By | Condition | Start Order |
|---------|------------|-------------|-----------|-------------|
| `bluetooth.service` | (system) | tether-server | None | 1 |
| `NetworkManager.service` | (system) | tether-server, watchdog | None | 1 |
| `network-online.target` | NM | tether-server, dumbpipe | None | 2 |
| `tether-network-watchdog` | NM | None | None | 3 (parallel) |
| `tether-server` | bluetooth, NM, network | tether-dumbpipe | None | 3 |
| `tether-dumbpipe` | tether-server | None | onboarding.done | 4 |

### 9.4 Restart Behavior

| Service | Restart Policy | RestartSec | StartLimit |
|---------|---------------|------------|------------|
| `tether-server` | on-failure | 5s | 5 in 60s |
| `tether-dumbpipe` | always | 10s | 10 in 300s |
| `tether-network-watchdog` | always | 5s | 20 in 300s |

**Key Points:**
- `tether-server` only restarts on failure (exit != 0), not on clean shutdown
- `tether-dumbpipe` always restarts because network tunnels are critical
- `tether-network-watchdog` always restarts for continuous monitoring
- Start limits prevent rapid restart loops that could indicate deeper issues

### 9.5 Failure Scenarios

| Scenario | Behavior |
|----------|----------|
| bluetooth.service fails | tether-server starts anyway (Wants, not Requires) - Bluetooth features degraded |
| tether-server crashes | Restarts after 5s; tether-dumbpipe stops (BindsTo) and restarts when server does |
| tether-dumbpipe loses connection | Restarts after 10s, generates new ticket |
| Network drops | watchdog detects, tries other networks, may activate setup AP |
| All services crash rapidly | Hit StartLimitBurst, services marked failed, require manual intervention |

### 9.6 Manual Operations Cheat Sheet

```bash
# View service status
systemctl status tether-server tether-dumbpipe tether-network-watchdog

# View logs (all tether services)
journalctl -u 'tether-*' -f

# View logs (specific service, last 100 lines)
journalctl -u tether-server -n 100

# Restart a service
sudo systemctl restart tether-server

# Stop all tether services
sudo systemctl stop tether-dumbpipe tether-server tether-network-watchdog

# Start all tether services
sudo systemctl start tether-network-watchdog tether-server
# Then after onboarding:
sudo systemctl start tether-dumbpipe

# Check why a service isn't starting
systemctl show tether-dumbpipe --property=ConditionResult
systemctl show tether-dumbpipe --property=ActiveState
systemctl show tether-dumbpipe --property=SubState

# Reset failed state (after fixing issues)
sudo systemctl reset-failed tether-server

# Reload service files after editing
sudo systemctl daemon-reload

# Security analysis
systemd-analyze security tether-server
systemd-analyze security tether-dumbpipe

# Boot timing analysis
systemd-analyze blame | grep tether
systemd-analyze critical-chain tether-server.service
```

---

## Appendix A: Complete File Listing

Here is the complete list of files to create:

| File | Purpose |
|------|---------|
| `/usr/local/sbin/tether-setup-user.sh` | Creates tether user and groups |
| `/usr/local/sbin/tether-setup-dirs.sh` | Creates directory structure |
| `/usr/local/sbin/tether-install-services.sh` | Master installation script |
| `/usr/local/bin/tether-save-ticket.sh` | Dumbpipe wrapper for ticket capture |
| `/etc/systemd/system/tether-server.service` | Main HTTP server service |
| `/etc/systemd/system/tether-dumbpipe.service` | Remote access tunnel service |
| `/etc/systemd/system/tether-network-watchdog.service` | Network monitoring service |
| `/etc/dbus-1/system.d/tether-bluetooth.conf` | Bluetooth D-Bus policy |
| `/etc/dbus-1/system.d/tether-networkmanager.conf` | NetworkManager D-Bus policy |
| `/etc/tether/config.toml` | Main configuration file |

---

## Appendix B: sdm Integration

For integration with the sdm build system, add this to your sdm plugin:

```bash
# In your sdm Phase 1 script (running in chroot)

# Install setup scripts
install -m 755 deploy/scripts/tether-setup-user.sh /usr/local/sbin/
install -m 755 deploy/scripts/tether-setup-dirs.sh /usr/local/sbin/
install -m 755 deploy/scripts/tether-install-services.sh /usr/local/sbin/
install -m 755 deploy/scripts/tether-save-ticket.sh /usr/local/bin/

# Install service files
install -m 644 deploy/systemd/tether-server.service /etc/systemd/system/
install -m 644 deploy/systemd/tether-dumbpipe.service /etc/systemd/system/
install -m 644 deploy/systemd/tether-network-watchdog.service /etc/systemd/system/

# Install D-Bus policies
install -m 644 deploy/dbus/tether-bluetooth.conf /etc/dbus-1/system.d/
install -m 644 deploy/dbus/tether-networkmanager.conf /etc/dbus-1/system.d/

# Run setup scripts
/usr/local/sbin/tether-setup-user.sh
/usr/local/sbin/tether-setup-dirs.sh

# Enable services (they won't start until first boot)
systemctl enable tether-server.service
systemctl enable tether-network-watchdog.service
# Note: tether-dumbpipe is NOT enabled here - it starts after onboarding
```

---

### Critical Files for Implementation

List of files most critical for implementing this plan:

- `/etc/systemd/system/tether-server.service` - Core HTTP server service with full security hardening, the foundation for all other services
- `/etc/systemd/system/tether-dumbpipe.service` - Remote access tunnel with ConditionPathExists for onboarding gate
- `/usr/local/bin/tether-save-ticket.sh` - Wrapper script that captures dumbpipe ticket, critical for MCP server connectivity
- `/etc/dbus-1/system.d/tether-bluetooth.conf` - D-Bus policy enabling non-root Bluetooth access via BlueZ API
- `/usr/local/sbin/tether-setup-user.sh` - User/group creation script, must run before any services can start
